// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_fantasy.proto

#ifndef PROTOBUF_dota_5fgcmessages_5fclient_5ffantasy_2eproto__INCLUDED
#define PROTOBUF_dota_5fgcmessages_5fclient_5ffantasy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

class CMsgGCPlayerInfo;
class CMsgGCPlayerInfo_PlayerInfo;
class CMsgGCPlayerInfo_RegionLeaderboard;
class CMsgDOTACreateFantasyLeagueRequest;
class CMsgDOTACreateFantasyLeagueResponse;
class CMsgFantasyLeagueScoring;
class CMsgDOTAFantasyLeagueInfo;
class CMsgDOTAFantasyLeagueInfo_OwnerInfo;
class CMsgDOTAFantasyLeagueEditInfoRequest;
class CMsgDOTAFantasyLeagueEditInfoResponse;
class CMsgDOTAFantasyLeagueFindRequest;
class CMsgDOTAFantasyLeagueFindResponse;
class CMsgDOTAFantasyLeagueInfoRequest;
class CMsgDOTAFantasyLeagueInfoResponse;
class CMsgDOTAFantasyLeagueMatchupsRequest;
class CMsgDOTAFantasyLeagueMatchupsResponse;
class CMsgDOTAFantasyLeagueMatchupsResponse_Matchup;
class CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups;
class CMsgDOTAEditFantasyTeamRequest;
class CMsgDOTAEditFantasyTeamResponse;
class CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID;
class CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID;
class CMsgDOTAFantasyTeamInfoResponse;
class CMsgDOTAFantasyTeamInfo;
class CMsgDOTAFantasyTeamScoreRequest;
class CMsgDOTAFantasyTeamScoreResponse;
class CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore;
class CMsgDOTAFantasyTeamStandingsRequest;
class CMsgDOTAFantasyTeamStandingsResponse;
class CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore;
class CMsgDOTAFantasyPlayerScoreRequest;
class CMsgDOTAFantasyPlayerScoreResponse;
class CMsgDOTAFantasyPlayerStandingsRequest;
class CMsgDOTAFantasyPlayerStandingsResponse;
class CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore;
class CMsgDOTAFantasyPlayerInfoRequest;
class CMsgDOTAFantasyPlayerInfoResponse;
class CMsgDOTAFantasyLeagueCreateRequest;
class CMsgDOTAFantasyLeagueCreateResponse;
class CMsgDOTAFantasyTeamCreateRequest;
class CMsgDOTAFantasyTeamCreateResponse;
class CMsgDOTAFantasyLeagueEditInvitesRequest;
class CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange;
class CMsgDOTAFantasyLeagueEditInvitesResponse;
class CMsgDOTAFantasyLeagueDraftStatusRequest;
class CMsgDOTAFantasyLeagueDraftStatus;
class CMsgDOTAFantasyLeagueDraftPlayerRequest;
class CMsgDOTAFantasyLeagueDraftPlayerResponse;
class CMsgDOTAFantasyTeamRosterSwapRequest;
class CMsgDOTAFantasyTeamRosterSwapResponse;
class CMsgDOTAFantasyTeamRosterAddDropRequest;
class CMsgDOTAFantasyTeamRosterAddDropResponse;
class CMsgDOTAFantasyTeamTradesRequest;
class CMsgDOTAFantasyTeamTradesResponse;
class CMsgDOTAFantasyTeamTradesResponse_Trade;
class CMsgDOTAFantasyTeamTradeCancelRequest;
class CMsgDOTAFantasyTeamTradeCancelResponse;
class CMsgDOTAFantasyTeamRosterRequest;
class CMsgDOTAFantasyTeamRosterResponse;
class CMsgDOTAFantasyPlayerHisoricalStatsRequest;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats;
class CMsgDOTAFantasyMessageAdd;
class CMsgDOTAFantasyMessagesRequest;
class CMsgDOTAFantasyMessagesResponse;
class CMsgDOTAFantasyMessagesResponse_Message;
class CMsgDOTAFantasyRemoveOwner;
class CMsgDOTAFantasyRemoveOwnerResponse;
class CMsgDOTAFantasyScheduledMatchesRequest;
class CMsgDOTAFantasyScheduledMatchesResponse;
class CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays;
class CMsgDOTAFantasyLeaveLeagueRequest;
class CMsgDOTAFantasyLeaveLeagueResponse;
class CMsgDOTAFantasyPlayerScoreDetailsRequest;
class CMsgDOTAFantasyPlayerScoreDetailsResponse;
class CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData;
class CMsgDOTAPassportVoteTeamGuess;
class CMsgDOTAPassportVoteGenericSelection;
class CMsgDOTAPassportStampedPlayer;
class CMsgDOTAPassportPlayerCardChallenge;
class CMsgDOTAPassportVote;
class CMsgClientToGCGetPlayerCardRosterRequest;
class CMsgClientToGCGetPlayerCardRosterResponse;
class CMsgClientToGCSetPlayerCardRosterRequest;
class CMsgClientToGCSetPlayerCardRosterResponse;

enum CMsgDOTACreateFantasyLeagueResponse_EResult {
  CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS = 0,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_TOO_MANY_LEAGUES = 2,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_INVALID_TEAM_COUNT = 3,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED = 4
};
bool CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(int value);
const CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MIN = CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS;
const CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED;
const int CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_ARRAYSIZE = CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTACreateFantasyLeagueResponse_EResult_Name(CMsgDOTACreateFantasyLeagueResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTACreateFantasyLeagueResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTACreateFantasyLeagueResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTACreateFantasyLeagueResponse_EResult>(
    CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Name(CMsgDOTAFantasyLeagueEditInfoResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueEditInfoResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueEditInfoResponse_EResult>(
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueFindResponse_EResult {
  CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_NOT_FOUND = 1,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_BAD_PASSWORD = 2,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_UNSPECIFIED = 3,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_FULL = 4,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_ALREADY_MEMBER = 5,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED = 6
};
bool CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED;
const int CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse_EResult_Name(CMsgDOTAFantasyLeagueFindResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueFindResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueFindResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueFindResponse_EResult>(
    CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueInfoResponse_EResult {
  CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID = 2
};
bool CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID;
const int CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueInfoResponse_EResult_Name(CMsgDOTAFantasyLeagueInfoResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueInfoResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueInfoResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueInfoResponse_EResult>(
    CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_BAD_LEAGUE_ID = 2,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION = 3
};
bool CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Name(CMsgDOTAFantasyLeagueMatchupsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueMatchupsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueMatchupsResponse_EResult>(
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAEditFantasyTeamResponse_EResult {
  CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS = 0,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_INVALID_TEAM_INFO = 2,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NAME_ALREADY_TAKEN = 3,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION = 4
};
bool CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(int value);
const CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MIN = CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS;
const CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAEditFantasyTeamResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAEditFantasyTeamResponse_EResult_Name(CMsgDOTAEditFantasyTeamResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAEditFantasyTeamResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAEditFantasyTeamResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAEditFantasyTeamResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAEditFantasyTeamResponse_EResult>(
    CMsgDOTAEditFantasyTeamResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamScoreResponse_EResult {
  CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 3
};
bool CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
const int CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamScoreResponse_EResult_Name(CMsgDOTAFantasyTeamScoreResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamScoreResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamScoreResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamScoreResponse_EResult>(
    CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamStandingsResponse_EResult {
  CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_EResult_Name(CMsgDOTAFantasyTeamStandingsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamStandingsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamStandingsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamStandingsResponse_EResult>(
    CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerScoreResponse_EResult {
  CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerScoreResponse_EResult_Name(CMsgDOTAFantasyPlayerScoreResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerScoreResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerScoreResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerScoreResponse_EResult>(
    CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerStandingsResponse_EResult {
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerStandingsResponse_EResult_Name(CMsgDOTAFantasyPlayerStandingsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerStandingsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerStandingsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerStandingsResponse_EResult>(
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueCreateResponse_EResult {
  CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_PERMISSION = 1,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_SEASON_ID = 2,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_LEAGUE_NAME = 3,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_TEAM_NAME = 4,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_UNSPECIFIED = 5,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD = 6,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET = 7
};
bool CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET;
const int CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueCreateResponse_EResult_Name(CMsgDOTAFantasyLeagueCreateResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueCreateResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueCreateResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueCreateResponse_EResult>(
    CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamCreateResponse_EResult {
  CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_PERMISSION = 1,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD = 2,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_FANTASY_LEAGUE_ID = 3,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_NAME = 4,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FULL = 5,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_ALREADY_MEMBER = 6,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_PASSWORD = 7,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_UNSPECIFIED = 8,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_TICKET = 9,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED = 10
};
bool CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED;
const int CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamCreateResponse_EResult_Name(CMsgDOTAFantasyTeamCreateResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamCreateResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamCreateResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamCreateResponse_EResult>(
    CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
  CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED = 1
};
bool CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED;
const int CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Name(CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueEditInvitesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>(
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_INVALID_FANTASY_LEAGUE = 2,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_FANTASY_LEAGUE_NOT_DRAFTING = 3,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 4,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_NOT_OWNERS_TURN = 5,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_INVALID = 6,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_UNAVAILABLE = 7,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS = 8
};
bool CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS;
const int CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Name(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>(
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 2,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOTS_INVALID = 3,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED = 4
};
bool CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED;
const int CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Name(CMsgDOTAFantasyTeamRosterSwapResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterSwapResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterSwapResponse_EResult>(
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 2,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_AVAILABLE = 3,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_ON_TEAM = 4,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING = 5
};
bool CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING;
const int CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Name(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterAddDropResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>(
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamTradesResponse_EResult {
  CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamTradesResponse_EResult_Name(CMsgDOTAFantasyTeamTradesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamTradesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamTradesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamTradesResponse_EResult>(
    CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE = 3
};
bool CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE;
const int CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Name(CMsgDOTAFantasyTeamTradeCancelResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamTradeCancelResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamTradeCancelResponse_EResult>(
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterResponse_EResult {
  CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 3
};
bool CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
const int CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterResponse_EResult_Name(CMsgDOTAFantasyTeamRosterResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterResponse_EResult>(
    CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Name(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>(
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyMessagesResponse_EResult {
  CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyMessagesResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyMessagesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse_EResult_EResult_MIN = CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX = CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyMessagesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyMessagesResponse_EResult_Name(CMsgDOTAFantasyMessagesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyMessagesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyMessagesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyMessagesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyMessagesResponse_EResult>(
    CMsgDOTAFantasyMessagesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyRemoveOwnerResponse_EResult {
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_LEAGUE_LOCKED = 3,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER = 4
};
bool CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MIN = CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS;
const CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER;
const int CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyRemoveOwnerResponse_EResult_Name(CMsgDOTAFantasyRemoveOwnerResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyRemoveOwnerResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyRemoveOwnerResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyRemoveOwnerResponse_EResult>(
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyScheduledMatchesResponse_EResult {
  CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED = 1
};
bool CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MIN = CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX = CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED;
const int CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyScheduledMatchesResponse_EResult_Name(CMsgDOTAFantasyScheduledMatchesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyScheduledMatchesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyScheduledMatchesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyScheduledMatchesResponse_EResult>(
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeaveLeagueResponse_EResult {
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_NOT_MEMBER = 2,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_LEAGUE_NOT_FOUND = 3,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE = 4
};
bool CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE;
const int CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeaveLeagueResponse_EResult_Name(CMsgDOTAFantasyLeaveLeagueResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeaveLeagueResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeaveLeagueResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeaveLeagueResponse_EResult>(
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER = 2
};
bool CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER;
const int CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Name(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>(
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor(), name, value);
}
enum CMsgClientToGCGetPlayerCardRosterResponse_Result {
  CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS = 0,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED = 1,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID = 2,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP = 3
};
bool CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(int value);
const CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MIN = CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS;
const CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX = CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
const int CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_ARRAYSIZE = CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
inline const ::std::string& CMsgClientToGCGetPlayerCardRosterResponse_Result_Name(CMsgClientToGCGetPlayerCardRosterResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor(), value);
}
inline bool CMsgClientToGCGetPlayerCardRosterResponse_Result_Parse(
    const ::std::string& name, CMsgClientToGCGetPlayerCardRosterResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgClientToGCGetPlayerCardRosterResponse_Result>(
    CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor(), name, value);
}
enum CMsgClientToGCSetPlayerCardRosterResponse_Result {
  CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS = 0,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED = 1,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID = 2,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP = 3,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_PLAYER_CARD_NOT_OWNED = 4,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_SLOT = 5,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_FAILED_CARD_INFO = 6,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_ACCOUNT_DUPLICATE = 7,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP = 8
};
bool CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(int value);
const CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MIN = CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS;
const CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP;
const int CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_ARRAYSIZE = CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
inline const ::std::string& CMsgClientToGCSetPlayerCardRosterResponse_Result_Name(CMsgClientToGCSetPlayerCardRosterResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor(), value);
}
inline bool CMsgClientToGCSetPlayerCardRosterResponse_Result_Parse(
    const ::std::string& name, CMsgClientToGCSetPlayerCardRosterResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgClientToGCSetPlayerCardRosterResponse_Result>(
    CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor(), name, value);
}
enum DOTA_2013PassportSelectionIndices {
  PP13_SEL_ALLSTAR_PLAYER_0 = 0,
  PP13_SEL_ALLSTAR_PLAYER_1 = 1,
  PP13_SEL_ALLSTAR_PLAYER_2 = 2,
  PP13_SEL_ALLSTAR_PLAYER_3 = 3,
  PP13_SEL_ALLSTAR_PLAYER_4 = 4,
  PP13_SEL_ALLSTAR_PLAYER_5 = 5,
  PP13_SEL_ALLSTAR_PLAYER_6 = 6,
  PP13_SEL_ALLSTAR_PLAYER_7 = 7,
  PP13_SEL_ALLSTAR_PLAYER_8 = 8,
  PP13_SEL_ALLSTAR_PLAYER_9 = 9,
  PP13_SEL_QUALPRED_WEST_0 = 10,
  PP13_SEL_QUALPRED_WEST_1 = 11,
  PP13_SEL_QUALPRED_WEST_2 = 12,
  PP13_SEL_QUALPRED_WEST_3 = 13,
  PP13_SEL_QUALPRED_WEST_4 = 14,
  PP13_SEL_QUALPRED_WEST_5 = 15,
  PP13_SEL_QUALPRED_WEST_6 = 16,
  PP13_SEL_QUALPRED_WEST_7 = 17,
  PP13_SEL_QUALPRED_WEST_8 = 18,
  PP13_SEL_QUALPRED_WEST_9 = 19,
  PP13_SEL_QUALPRED_WEST_10 = 20,
  PP13_SEL_QUALPRED_WEST_11 = 21,
  PP13_SEL_QUALPRED_WEST_12 = 22,
  PP13_SEL_QUALPRED_WEST_13 = 23,
  PP13_SEL_QUALPRED_WEST_14 = 24,
  PP13_SEL_QUALPRED_EAST_0 = 25,
  PP13_SEL_QUALPRED_EAST_1 = 26,
  PP13_SEL_QUALPRED_EAST_2 = 27,
  PP13_SEL_QUALPRED_EAST_3 = 28,
  PP13_SEL_QUALPRED_EAST_4 = 29,
  PP13_SEL_QUALPRED_EAST_5 = 30,
  PP13_SEL_QUALPRED_EAST_6 = 31,
  PP13_SEL_QUALPRED_EAST_7 = 32,
  PP13_SEL_QUALPRED_EAST_8 = 33,
  PP13_SEL_QUALPRED_EAST_9 = 34,
  PP13_SEL_QUALPRED_EAST_10 = 35,
  PP13_SEL_QUALPRED_EAST_11 = 36,
  PP13_SEL_QUALPRED_EAST_12 = 37,
  PP13_SEL_QUALPRED_EAST_13 = 38,
  PP13_SEL_QUALPRED_EAST_14 = 39,
  PP13_SEL_TEAMCUP_TEAM = 40,
  PP13_SEL_TEAMCUP_PLAYER = 41,
  PP13_SEL_TEAMCUP_TEAM_LOCK = 42,
  PP13_SEL_TEAMCUP_PLAYER_LOCK = 43,
  PP13_SEL_EVENTPRED_0 = 44,
  PP13_SEL_EVENTPRED_1 = 45,
  PP13_SEL_EVENTPRED_2 = 46,
  PP13_SEL_EVENTPRED_3 = 47,
  PP13_SEL_EVENTPRED_4 = 48,
  PP13_SEL_EVENTPRED_5 = 49,
  PP13_SEL_EVENTPRED_6 = 50,
  PP13_SEL_EVENTPRED_7 = 51,
  PP13_SEL_EVENTPRED_8 = 52,
  PP13_SEL_EVENTPRED_9 = 53,
  PP13_SEL_EVENTPRED_10 = 54,
  PP13_SEL_EVENTPRED_11 = 55,
  PP13_SEL_EVENTPRED_12 = 56,
  PP13_SEL_EVENTPRED_13 = 57,
  PP13_SEL_EVENTPRED_14 = 58,
  PP13_SEL_EVENTPRED_15 = 59,
  PP13_SEL_EVENTPRED_16 = 60,
  PP13_SEL_EVENTPRED_17 = 61,
  PP13_SEL_EVENTPRED_18 = 62,
  PP13_SEL_EVENTPRED_19 = 63,
  PP13_SEL_EVENTPRED_20 = 64,
  PP13_SEL_EVENTPRED_21 = 65,
  PP13_SEL_EVENTPRED_22 = 66,
  PP13_SEL_EVENTPRED_23 = 67,
  PP13_SEL_EVENTPRED_24 = 68,
  PP13_SEL_EVENTPRED_25 = 69,
  PP13_SEL_EVENTPRED_26 = 70,
  PP13_SEL_EVENTPRED_27 = 71,
  PP13_SEL_EVENTPRED_28 = 72,
  PP13_SEL_EVENTPRED_29 = 73,
  PP13_SEL_EVENTPRED_30 = 74,
  PP13_SEL_EVENTPRED_31 = 75,
  PP13_SEL_EVENTPRED_32 = 76,
  PP13_SEL_EVENTPRED_33 = 77,
  PP13_SEL_EVENTPRED_34 = 78,
  PP13_SEL_EVENTPRED_35 = 79,
  PP13_SEL_EVENTPRED_36 = 80,
  PP13_SEL_EVENTPRED_37 = 81,
  PP13_SEL_EVENTPRED_38 = 82,
  PP13_SEL_EVENTPRED_39 = 83,
  PP13_SEL_EVENTPRED_40 = 84,
  PP13_SEL_EVENTPRED_41 = 85,
  PP13_SEL_EVENTPRED_42 = 86,
  PP13_SEL_EVENTPRED_43 = 87,
  PP13_SEL_SOLO_0 = 88,
  PP13_SEL_SOLO_1 = 89,
  PP13_SEL_SOLO_2 = 90,
  PP13_SEL_SOLO_3 = 91,
  PP13_SEL_SOLO_4 = 92,
  PP13_SEL_SOLO_5 = 93,
  PP13_SEL_SOLO_6 = 94,
  PP13_SEL_SOLO_7 = 95
};
bool DOTA_2013PassportSelectionIndices_IsValid(int value);
const DOTA_2013PassportSelectionIndices DOTA_2013PassportSelectionIndices_MIN = PP13_SEL_ALLSTAR_PLAYER_0;
const DOTA_2013PassportSelectionIndices DOTA_2013PassportSelectionIndices_MAX = PP13_SEL_SOLO_7;
const int DOTA_2013PassportSelectionIndices_ARRAYSIZE = DOTA_2013PassportSelectionIndices_MAX + 1;

const ::google::protobuf::EnumDescriptor* DOTA_2013PassportSelectionIndices_descriptor();
inline const ::std::string& DOTA_2013PassportSelectionIndices_Name(DOTA_2013PassportSelectionIndices value) {
  return ::google::protobuf::internal::NameOfEnum(
    DOTA_2013PassportSelectionIndices_descriptor(), value);
}
inline bool DOTA_2013PassportSelectionIndices_Parse(
    const ::std::string& name, DOTA_2013PassportSelectionIndices* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DOTA_2013PassportSelectionIndices>(
    DOTA_2013PassportSelectionIndices_descriptor(), name, value);
}
// ===================================================================

class CMsgGCPlayerInfo_PlayerInfo : public ::google::protobuf::Message {
 public:
  CMsgGCPlayerInfo_PlayerInfo();
  virtual ~CMsgGCPlayerInfo_PlayerInfo();

  CMsgGCPlayerInfo_PlayerInfo(const CMsgGCPlayerInfo_PlayerInfo& from);

  inline CMsgGCPlayerInfo_PlayerInfo& operator=(const CMsgGCPlayerInfo_PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgGCPlayerInfo_PlayerInfo& default_instance();

  void Swap(CMsgGCPlayerInfo_PlayerInfo* other);

  // implements Message ----------------------------------------------

  CMsgGCPlayerInfo_PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgGCPlayerInfo_PlayerInfo& from);
  void MergeFrom(const CMsgGCPlayerInfo_PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string country_code = 3;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 3;
  inline const ::std::string& country_code() const;
  inline void set_country_code(const ::std::string& value);
  inline void set_country_code(const char* value);
  inline void set_country_code(const char* value, size_t size);
  inline ::std::string* mutable_country_code();
  inline ::std::string* release_country_code();
  inline void set_allocated_country_code(::std::string* country_code);

  // optional uint32 fantasy_role = 4;
  inline bool has_fantasy_role() const;
  inline void clear_fantasy_role();
  static const int kFantasyRoleFieldNumber = 4;
  inline ::google::protobuf::uint32 fantasy_role() const;
  inline void set_fantasy_role(::google::protobuf::uint32 value);

  // optional uint32 team_id = 5;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 5;
  inline ::google::protobuf::uint32 team_id() const;
  inline void set_team_id(::google::protobuf::uint32 value);

  // optional string team_name = 6;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 6;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional string team_tag = 7;
  inline bool has_team_tag() const;
  inline void clear_team_tag();
  static const int kTeamTagFieldNumber = 7;
  inline const ::std::string& team_tag() const;
  inline void set_team_tag(const ::std::string& value);
  inline void set_team_tag(const char* value);
  inline void set_team_tag(const char* value, size_t size);
  inline ::std::string* mutable_team_tag();
  inline ::std::string* release_team_tag();
  inline void set_allocated_team_tag(::std::string* team_tag);

  // optional string sponsor = 8;
  inline bool has_sponsor() const;
  inline void clear_sponsor();
  static const int kSponsorFieldNumber = 8;
  inline const ::std::string& sponsor() const;
  inline void set_sponsor(const ::std::string& value);
  inline void set_sponsor(const char* value);
  inline void set_sponsor(const char* value, size_t size);
  inline ::std::string* mutable_sponsor();
  inline ::std::string* release_sponsor();
  inline void set_allocated_sponsor(::std::string* sponsor);

  // optional bool is_locked = 9;
  inline bool has_is_locked() const;
  inline void clear_is_locked();
  static const int kIsLockedFieldNumber = 9;
  inline bool is_locked() const;
  inline void set_is_locked(bool value);

  // optional bool is_pro = 10;
  inline bool has_is_pro() const;
  inline void clear_is_pro();
  static const int kIsProFieldNumber = 10;
  inline bool is_pro() const;
  inline void set_is_pro(bool value);

  // optional uint32 locked_until = 11;
  inline bool has_locked_until() const;
  inline void clear_locked_until();
  static const int kLockedUntilFieldNumber = 11;
  inline ::google::protobuf::uint32 locked_until() const;
  inline void set_locked_until(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 12;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 12;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgGCPlayerInfo.PlayerInfo)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_fantasy_role();
  inline void clear_has_fantasy_role();
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_team_tag();
  inline void clear_has_team_tag();
  inline void set_has_sponsor();
  inline void clear_has_sponsor();
  inline void set_has_is_locked();
  inline void clear_has_is_locked();
  inline void set_has_is_pro();
  inline void clear_has_is_pro();
  inline void set_has_locked_until();
  inline void clear_has_locked_until();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 fantasy_role_;
  ::std::string* country_code_;
  ::std::string* team_name_;
  ::std::string* team_tag_;
  ::std::string* sponsor_;
  ::google::protobuf::uint32 team_id_;
  bool is_locked_;
  bool is_pro_;
  ::google::protobuf::uint32 locked_until_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgGCPlayerInfo_PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGCPlayerInfo_RegionLeaderboard : public ::google::protobuf::Message {
 public:
  CMsgGCPlayerInfo_RegionLeaderboard();
  virtual ~CMsgGCPlayerInfo_RegionLeaderboard();

  CMsgGCPlayerInfo_RegionLeaderboard(const CMsgGCPlayerInfo_RegionLeaderboard& from);

  inline CMsgGCPlayerInfo_RegionLeaderboard& operator=(const CMsgGCPlayerInfo_RegionLeaderboard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgGCPlayerInfo_RegionLeaderboard& default_instance();

  void Swap(CMsgGCPlayerInfo_RegionLeaderboard* other);

  // implements Message ----------------------------------------------

  CMsgGCPlayerInfo_RegionLeaderboard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgGCPlayerInfo_RegionLeaderboard& from);
  void MergeFrom(const CMsgGCPlayerInfo_RegionLeaderboard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 division = 1;
  inline bool has_division() const;
  inline void clear_division();
  static const int kDivisionFieldNumber = 1;
  inline ::google::protobuf::uint32 division() const;
  inline void set_division(::google::protobuf::uint32 value);

  // repeated uint32 account_ids = 2;
  inline int account_ids_size() const;
  inline void clear_account_ids();
  static const int kAccountIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 account_ids(int index) const;
  inline void set_account_ids(int index, ::google::protobuf::uint32 value);
  inline void add_account_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      account_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_account_ids();

  // @@protoc_insertion_point(class_scope:CMsgGCPlayerInfo.RegionLeaderboard)
 private:
  inline void set_has_division();
  inline void clear_has_division();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > account_ids_;
  ::google::protobuf::uint32 division_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgGCPlayerInfo_RegionLeaderboard* default_instance_;
};
// -------------------------------------------------------------------

class CMsgGCPlayerInfo : public ::google::protobuf::Message {
 public:
  CMsgGCPlayerInfo();
  virtual ~CMsgGCPlayerInfo();

  CMsgGCPlayerInfo(const CMsgGCPlayerInfo& from);

  inline CMsgGCPlayerInfo& operator=(const CMsgGCPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgGCPlayerInfo& default_instance();

  void Swap(CMsgGCPlayerInfo* other);

  // implements Message ----------------------------------------------

  CMsgGCPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgGCPlayerInfo& from);
  void MergeFrom(const CMsgGCPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgGCPlayerInfo_PlayerInfo PlayerInfo;
  typedef CMsgGCPlayerInfo_RegionLeaderboard RegionLeaderboard;

  // accessors -------------------------------------------------------

  // repeated .CMsgGCPlayerInfo.PlayerInfo player_infos = 1;
  inline int player_infos_size() const;
  inline void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 1;
  inline const ::CMsgGCPlayerInfo_PlayerInfo& player_infos(int index) const;
  inline ::CMsgGCPlayerInfo_PlayerInfo* mutable_player_infos(int index);
  inline ::CMsgGCPlayerInfo_PlayerInfo* add_player_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_PlayerInfo >&
      player_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_PlayerInfo >*
      mutable_player_infos();

  // repeated .CMsgGCPlayerInfo.RegionLeaderboard leaderboards = 2;
  inline int leaderboards_size() const;
  inline void clear_leaderboards();
  static const int kLeaderboardsFieldNumber = 2;
  inline const ::CMsgGCPlayerInfo_RegionLeaderboard& leaderboards(int index) const;
  inline ::CMsgGCPlayerInfo_RegionLeaderboard* mutable_leaderboards(int index);
  inline ::CMsgGCPlayerInfo_RegionLeaderboard* add_leaderboards();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_RegionLeaderboard >&
      leaderboards() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_RegionLeaderboard >*
      mutable_leaderboards();

  // @@protoc_insertion_point(class_scope:CMsgGCPlayerInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_PlayerInfo > player_infos_;
  ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_RegionLeaderboard > leaderboards_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgGCPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTACreateFantasyLeagueRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTACreateFantasyLeagueRequest();
  virtual ~CMsgDOTACreateFantasyLeagueRequest();

  CMsgDOTACreateFantasyLeagueRequest(const CMsgDOTACreateFantasyLeagueRequest& from);

  inline CMsgDOTACreateFantasyLeagueRequest& operator=(const CMsgDOTACreateFantasyLeagueRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTACreateFantasyLeagueRequest& default_instance();

  void Swap(CMsgDOTACreateFantasyLeagueRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTACreateFantasyLeagueRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTACreateFantasyLeagueRequest& from);
  void MergeFrom(const CMsgDOTACreateFantasyLeagueRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string league_name = 1;
  inline bool has_league_name() const;
  inline void clear_league_name();
  static const int kLeagueNameFieldNumber = 1;
  inline const ::std::string& league_name() const;
  inline void set_league_name(const ::std::string& value);
  inline void set_league_name(const char* value);
  inline void set_league_name(const char* value, size_t size);
  inline ::std::string* mutable_league_name();
  inline ::std::string* release_league_name();
  inline void set_allocated_league_name(::std::string* league_name);

  // optional uint64 league_logo = 2;
  inline bool has_league_logo() const;
  inline void clear_league_logo();
  static const int kLeagueLogoFieldNumber = 2;
  inline ::google::protobuf::uint64 league_logo() const;
  inline void set_league_logo(::google::protobuf::uint64 value);

  // optional .Fantasy_Selection_Mode selection_mode = 3 [default = FANTASY_SELECTION_INVALID];
  inline bool has_selection_mode() const;
  inline void clear_selection_mode();
  static const int kSelectionModeFieldNumber = 3;
  inline ::Fantasy_Selection_Mode selection_mode() const;
  inline void set_selection_mode(::Fantasy_Selection_Mode value);

  // optional uint32 team_count = 4;
  inline bool has_team_count() const;
  inline void clear_team_count();
  static const int kTeamCountFieldNumber = 4;
  inline ::google::protobuf::uint32 team_count() const;
  inline void set_team_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTACreateFantasyLeagueRequest)
 private:
  inline void set_has_league_name();
  inline void clear_has_league_name();
  inline void set_has_league_logo();
  inline void clear_has_league_logo();
  inline void set_has_selection_mode();
  inline void clear_has_selection_mode();
  inline void set_has_team_count();
  inline void clear_has_team_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* league_name_;
  ::google::protobuf::uint64 league_logo_;
  int selection_mode_;
  ::google::protobuf::uint32 team_count_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTACreateFantasyLeagueRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTACreateFantasyLeagueResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTACreateFantasyLeagueResponse();
  virtual ~CMsgDOTACreateFantasyLeagueResponse();

  CMsgDOTACreateFantasyLeagueResponse(const CMsgDOTACreateFantasyLeagueResponse& from);

  inline CMsgDOTACreateFantasyLeagueResponse& operator=(const CMsgDOTACreateFantasyLeagueResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTACreateFantasyLeagueResponse& default_instance();

  void Swap(CMsgDOTACreateFantasyLeagueResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTACreateFantasyLeagueResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTACreateFantasyLeagueResponse& from);
  void MergeFrom(const CMsgDOTACreateFantasyLeagueResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTACreateFantasyLeagueResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_TOO_MANY_LEAGUES = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_TOO_MANY_LEAGUES;
  static const EResult ERROR_INVALID_TEAM_COUNT = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_INVALID_TEAM_COUNT;
  static const EResult ERROR_CREATION_DISABLED = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTACreateFantasyLeagueResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTACreateFantasyLeagueResponse_EResult result() const;
  inline void set_result(::CMsgDOTACreateFantasyLeagueResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTACreateFantasyLeagueResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTACreateFantasyLeagueResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgFantasyLeagueScoring : public ::google::protobuf::Message {
 public:
  CMsgFantasyLeagueScoring();
  virtual ~CMsgFantasyLeagueScoring();

  CMsgFantasyLeagueScoring(const CMsgFantasyLeagueScoring& from);

  inline CMsgFantasyLeagueScoring& operator=(const CMsgFantasyLeagueScoring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgFantasyLeagueScoring& default_instance();

  void Swap(CMsgFantasyLeagueScoring* other);

  // implements Message ----------------------------------------------

  CMsgFantasyLeagueScoring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgFantasyLeagueScoring& from);
  void MergeFrom(const CMsgFantasyLeagueScoring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline float level() const;
  inline void set_level(float value);

  // optional float kills = 2;
  inline bool has_kills() const;
  inline void clear_kills();
  static const int kKillsFieldNumber = 2;
  inline float kills() const;
  inline void set_kills(float value);

  // optional float deaths = 3;
  inline bool has_deaths() const;
  inline void clear_deaths();
  static const int kDeathsFieldNumber = 3;
  inline float deaths() const;
  inline void set_deaths(float value);

  // optional float assists = 4;
  inline bool has_assists() const;
  inline void clear_assists();
  static const int kAssistsFieldNumber = 4;
  inline float assists() const;
  inline void set_assists(float value);

  // optional float last_hits = 5;
  inline bool has_last_hits() const;
  inline void clear_last_hits();
  static const int kLastHitsFieldNumber = 5;
  inline float last_hits() const;
  inline void set_last_hits(float value);

  // optional float denies = 6;
  inline bool has_denies() const;
  inline void clear_denies();
  static const int kDeniesFieldNumber = 6;
  inline float denies() const;
  inline void set_denies(float value);

  // optional float gpm = 7;
  inline bool has_gpm() const;
  inline void clear_gpm();
  static const int kGpmFieldNumber = 7;
  inline float gpm() const;
  inline void set_gpm(float value);

  // optional float xppm = 8;
  inline bool has_xppm() const;
  inline void clear_xppm();
  static const int kXppmFieldNumber = 8;
  inline float xppm() const;
  inline void set_xppm(float value);

  // optional float stuns = 9;
  inline bool has_stuns() const;
  inline void clear_stuns();
  static const int kStunsFieldNumber = 9;
  inline float stuns() const;
  inline void set_stuns(float value);

  // optional float healing = 10;
  inline bool has_healing() const;
  inline void clear_healing();
  static const int kHealingFieldNumber = 10;
  inline float healing() const;
  inline void set_healing(float value);

  // optional float tower_kills = 11;
  inline bool has_tower_kills() const;
  inline void clear_tower_kills();
  static const int kTowerKillsFieldNumber = 11;
  inline float tower_kills() const;
  inline void set_tower_kills(float value);

  // optional float roshan_kills = 12;
  inline bool has_roshan_kills() const;
  inline void clear_roshan_kills();
  static const int kRoshanKillsFieldNumber = 12;
  inline float roshan_kills() const;
  inline void set_roshan_kills(float value);

  // optional float multiplier_premium = 13;
  inline bool has_multiplier_premium() const;
  inline void clear_multiplier_premium();
  static const int kMultiplierPremiumFieldNumber = 13;
  inline float multiplier_premium() const;
  inline void set_multiplier_premium(float value);

  // optional float multiplier_professional = 14;
  inline bool has_multiplier_professional() const;
  inline void clear_multiplier_professional();
  static const int kMultiplierProfessionalFieldNumber = 14;
  inline float multiplier_professional() const;
  inline void set_multiplier_professional(float value);

  // @@protoc_insertion_point(class_scope:CMsgFantasyLeagueScoring)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_kills();
  inline void clear_has_kills();
  inline void set_has_deaths();
  inline void clear_has_deaths();
  inline void set_has_assists();
  inline void clear_has_assists();
  inline void set_has_last_hits();
  inline void clear_has_last_hits();
  inline void set_has_denies();
  inline void clear_has_denies();
  inline void set_has_gpm();
  inline void clear_has_gpm();
  inline void set_has_xppm();
  inline void clear_has_xppm();
  inline void set_has_stuns();
  inline void clear_has_stuns();
  inline void set_has_healing();
  inline void clear_has_healing();
  inline void set_has_tower_kills();
  inline void clear_has_tower_kills();
  inline void set_has_roshan_kills();
  inline void clear_has_roshan_kills();
  inline void set_has_multiplier_premium();
  inline void clear_has_multiplier_premium();
  inline void set_has_multiplier_professional();
  inline void clear_has_multiplier_professional();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float level_;
  float kills_;
  float deaths_;
  float assists_;
  float last_hits_;
  float denies_;
  float gpm_;
  float xppm_;
  float stuns_;
  float healing_;
  float tower_kills_;
  float roshan_kills_;
  float multiplier_premium_;
  float multiplier_professional_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgFantasyLeagueScoring* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfo_OwnerInfo : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueInfo_OwnerInfo();
  virtual ~CMsgDOTAFantasyLeagueInfo_OwnerInfo();

  CMsgDOTAFantasyLeagueInfo_OwnerInfo(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);

  inline CMsgDOTAFantasyLeagueInfo_OwnerInfo& operator=(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueInfo_OwnerInfo& default_instance();

  void Swap(CMsgDOTAFantasyLeagueInfo_OwnerInfo* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueInfo_OwnerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 owner_account_id = 1;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional bool left_league = 2;
  inline bool has_left_league() const;
  inline void clear_left_league();
  static const int kLeftLeagueFieldNumber = 2;
  inline bool left_league() const;
  inline void set_left_league(bool value);

  // repeated uint32 player_account_id = 3;
  inline int player_account_id_size() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint32 player_account_id(int index) const;
  inline void set_player_account_id(int index, ::google::protobuf::uint32 value);
  inline void add_player_account_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_account_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_account_id();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueInfo.OwnerInfo)
 private:
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_left_league();
  inline void clear_has_left_league();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 owner_account_id_;
  bool left_league_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_account_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueInfo_OwnerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfo : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueInfo();
  virtual ~CMsgDOTAFantasyLeagueInfo();

  CMsgDOTAFantasyLeagueInfo(const CMsgDOTAFantasyLeagueInfo& from);

  inline CMsgDOTAFantasyLeagueInfo& operator=(const CMsgDOTAFantasyLeagueInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueInfo& default_instance();

  void Swap(CMsgDOTAFantasyLeagueInfo* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueInfo& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueInfo_OwnerInfo OwnerInfo;

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 commissioner_account_id = 2;
  inline bool has_commissioner_account_id() const;
  inline void clear_commissioner_account_id();
  static const int kCommissionerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 commissioner_account_id() const;
  inline void set_commissioner_account_id(::google::protobuf::uint32 value);

  // optional string fantasy_league_name = 3;
  inline bool has_fantasy_league_name() const;
  inline void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 3;
  inline const ::std::string& fantasy_league_name() const;
  inline void set_fantasy_league_name(const ::std::string& value);
  inline void set_fantasy_league_name(const char* value);
  inline void set_fantasy_league_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_league_name();
  inline ::std::string* release_fantasy_league_name();
  inline void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional .Fantasy_Selection_Mode selection_mode = 4 [default = FANTASY_SELECTION_INVALID];
  inline bool has_selection_mode() const;
  inline void clear_selection_mode();
  static const int kSelectionModeFieldNumber = 4;
  inline ::Fantasy_Selection_Mode selection_mode() const;
  inline void set_selection_mode(::Fantasy_Selection_Mode value);

  // optional uint32 team_count = 5;
  inline bool has_team_count() const;
  inline void clear_team_count();
  static const int kTeamCountFieldNumber = 5;
  inline ::google::protobuf::uint32 team_count() const;
  inline void set_team_count(::google::protobuf::uint32 value);

  // optional uint64 logo = 6;
  inline bool has_logo() const;
  inline void clear_logo();
  static const int kLogoFieldNumber = 6;
  inline ::google::protobuf::uint64 logo() const;
  inline void set_logo(::google::protobuf::uint64 value);

  // optional .CMsgFantasyLeagueScoring scoring = 7;
  inline bool has_scoring() const;
  inline void clear_scoring();
  static const int kScoringFieldNumber = 7;
  inline const ::CMsgFantasyLeagueScoring& scoring() const;
  inline ::CMsgFantasyLeagueScoring* mutable_scoring();
  inline ::CMsgFantasyLeagueScoring* release_scoring();
  inline void set_allocated_scoring(::CMsgFantasyLeagueScoring* scoring);

  // optional uint32 draft_time = 12;
  inline bool has_draft_time() const;
  inline void clear_draft_time();
  static const int kDraftTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 draft_time() const;
  inline void set_draft_time(::google::protobuf::uint32 value);

  // optional uint32 draft_pick_time = 13;
  inline bool has_draft_pick_time() const;
  inline void clear_draft_pick_time();
  static const int kDraftPickTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 draft_pick_time() const;
  inline void set_draft_pick_time(::google::protobuf::uint32 value);

  // optional uint32 season_start = 15;
  inline bool has_season_start() const;
  inline void clear_season_start();
  static const int kSeasonStartFieldNumber = 15;
  inline ::google::protobuf::uint32 season_start() const;
  inline void set_season_start(::google::protobuf::uint32 value);

  // optional uint32 season_length = 16;
  inline bool has_season_length() const;
  inline void clear_season_length();
  static const int kSeasonLengthFieldNumber = 16;
  inline ::google::protobuf::uint32 season_length() const;
  inline void set_season_length(::google::protobuf::uint32 value);

  // optional uint32 veto_votes = 17;
  inline bool has_veto_votes() const;
  inline void clear_veto_votes();
  static const int kVetoVotesFieldNumber = 17;
  inline ::google::protobuf::uint32 veto_votes() const;
  inline void set_veto_votes(::google::protobuf::uint32 value);

  // optional uint32 acquisitions = 18;
  inline bool has_acquisitions() const;
  inline void clear_acquisitions();
  static const int kAcquisitionsFieldNumber = 18;
  inline ::google::protobuf::uint32 acquisitions() const;
  inline void set_acquisitions(::google::protobuf::uint32 value);

  // optional uint32 slot_1 = 19;
  inline bool has_slot_1() const;
  inline void clear_slot_1();
  static const int kSlot1FieldNumber = 19;
  inline ::google::protobuf::uint32 slot_1() const;
  inline void set_slot_1(::google::protobuf::uint32 value);

  // optional uint32 slot_2 = 20;
  inline bool has_slot_2() const;
  inline void clear_slot_2();
  static const int kSlot2FieldNumber = 20;
  inline ::google::protobuf::uint32 slot_2() const;
  inline void set_slot_2(::google::protobuf::uint32 value);

  // optional uint32 slot_3 = 21;
  inline bool has_slot_3() const;
  inline void clear_slot_3();
  static const int kSlot3FieldNumber = 21;
  inline ::google::protobuf::uint32 slot_3() const;
  inline void set_slot_3(::google::protobuf::uint32 value);

  // optional uint32 slot_4 = 22;
  inline bool has_slot_4() const;
  inline void clear_slot_4();
  static const int kSlot4FieldNumber = 22;
  inline ::google::protobuf::uint32 slot_4() const;
  inline void set_slot_4(::google::protobuf::uint32 value);

  // optional uint32 slot_5 = 23;
  inline bool has_slot_5() const;
  inline void clear_slot_5();
  static const int kSlot5FieldNumber = 23;
  inline ::google::protobuf::uint32 slot_5() const;
  inline void set_slot_5(::google::protobuf::uint32 value);

  // optional uint32 bench_slots = 24;
  inline bool has_bench_slots() const;
  inline void clear_bench_slots();
  static const int kBenchSlotsFieldNumber = 24;
  inline ::google::protobuf::uint32 bench_slots() const;
  inline void set_bench_slots(::google::protobuf::uint32 value);

  // repeated .CMsgDOTAFantasyLeagueInfo.OwnerInfo owner_info = 25;
  inline int owner_info_size() const;
  inline void clear_owner_info();
  static const int kOwnerInfoFieldNumber = 25;
  inline const ::CMsgDOTAFantasyLeagueInfo_OwnerInfo& owner_info(int index) const;
  inline ::CMsgDOTAFantasyLeagueInfo_OwnerInfo* mutable_owner_info(int index);
  inline ::CMsgDOTAFantasyLeagueInfo_OwnerInfo* add_owner_info();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueInfo_OwnerInfo >&
      owner_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueInfo_OwnerInfo >*
      mutable_owner_info();

  // repeated uint32 players = 26;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 26;
  inline ::google::protobuf::uint32 players(int index) const;
  inline void set_players(int index, ::google::protobuf::uint32 value);
  inline void add_players(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      players() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_players();

  // optional uint32 time_zone = 27;
  inline bool has_time_zone() const;
  inline void clear_time_zone();
  static const int kTimeZoneFieldNumber = 27;
  inline ::google::protobuf::uint32 time_zone() const;
  inline void set_time_zone(::google::protobuf::uint32 value);

  // optional uint32 season = 28;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 28;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional string password = 29;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 29;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueInfo)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_commissioner_account_id();
  inline void clear_has_commissioner_account_id();
  inline void set_has_fantasy_league_name();
  inline void clear_has_fantasy_league_name();
  inline void set_has_selection_mode();
  inline void clear_has_selection_mode();
  inline void set_has_team_count();
  inline void clear_has_team_count();
  inline void set_has_logo();
  inline void clear_has_logo();
  inline void set_has_scoring();
  inline void clear_has_scoring();
  inline void set_has_draft_time();
  inline void clear_has_draft_time();
  inline void set_has_draft_pick_time();
  inline void clear_has_draft_pick_time();
  inline void set_has_season_start();
  inline void clear_has_season_start();
  inline void set_has_season_length();
  inline void clear_has_season_length();
  inline void set_has_veto_votes();
  inline void clear_has_veto_votes();
  inline void set_has_acquisitions();
  inline void clear_has_acquisitions();
  inline void set_has_slot_1();
  inline void clear_has_slot_1();
  inline void set_has_slot_2();
  inline void clear_has_slot_2();
  inline void set_has_slot_3();
  inline void clear_has_slot_3();
  inline void set_has_slot_4();
  inline void clear_has_slot_4();
  inline void set_has_slot_5();
  inline void clear_has_slot_5();
  inline void set_has_bench_slots();
  inline void clear_has_bench_slots();
  inline void set_has_time_zone();
  inline void clear_has_time_zone();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 commissioner_account_id_;
  ::std::string* fantasy_league_name_;
  int selection_mode_;
  ::google::protobuf::uint32 team_count_;
  ::google::protobuf::uint64 logo_;
  ::CMsgFantasyLeagueScoring* scoring_;
  ::google::protobuf::uint32 draft_time_;
  ::google::protobuf::uint32 draft_pick_time_;
  ::google::protobuf::uint32 season_start_;
  ::google::protobuf::uint32 season_length_;
  ::google::protobuf::uint32 veto_votes_;
  ::google::protobuf::uint32 acquisitions_;
  ::google::protobuf::uint32 slot_1_;
  ::google::protobuf::uint32 slot_2_;
  ::google::protobuf::uint32 slot_3_;
  ::google::protobuf::uint32 slot_4_;
  ::google::protobuf::uint32 slot_5_;
  ::google::protobuf::uint32 bench_slots_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueInfo_OwnerInfo > owner_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > players_;
  ::google::protobuf::uint32 time_zone_;
  ::google::protobuf::uint32 season_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInfoRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueEditInfoRequest();
  virtual ~CMsgDOTAFantasyLeagueEditInfoRequest();

  CMsgDOTAFantasyLeagueEditInfoRequest(const CMsgDOTAFantasyLeagueEditInfoRequest& from);

  inline CMsgDOTAFantasyLeagueEditInfoRequest& operator=(const CMsgDOTAFantasyLeagueEditInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueEditInfoRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueEditInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueEditInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInfoRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional .CMsgDOTAFantasyLeagueInfo edit_info = 2;
  inline bool has_edit_info() const;
  inline void clear_edit_info();
  static const int kEditInfoFieldNumber = 2;
  inline const ::CMsgDOTAFantasyLeagueInfo& edit_info() const;
  inline ::CMsgDOTAFantasyLeagueInfo* mutable_edit_info();
  inline ::CMsgDOTAFantasyLeagueInfo* release_edit_info();
  inline void set_allocated_edit_info(::CMsgDOTAFantasyLeagueInfo* edit_info);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueEditInfoRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_edit_info();
  inline void clear_has_edit_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CMsgDOTAFantasyLeagueInfo* edit_info_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueEditInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInfoResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueEditInfoResponse();
  virtual ~CMsgDOTAFantasyLeagueEditInfoResponse();

  CMsgDOTAFantasyLeagueEditInfoResponse(const CMsgDOTAFantasyLeagueEditInfoResponse& from);

  inline CMsgDOTAFantasyLeagueEditInfoResponse& operator=(const CMsgDOTAFantasyLeagueEditInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueEditInfoResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueEditInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueEditInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInfoResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueEditInfoResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueEditInfoResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueEditInfoResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueEditInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueFindRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueFindRequest();
  virtual ~CMsgDOTAFantasyLeagueFindRequest();

  CMsgDOTAFantasyLeagueFindRequest(const CMsgDOTAFantasyLeagueFindRequest& from);

  inline CMsgDOTAFantasyLeagueFindRequest& operator=(const CMsgDOTAFantasyLeagueFindRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueFindRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueFindRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueFindRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueFindRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueFindRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueFindRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueFindRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueFindResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueFindResponse();
  virtual ~CMsgDOTAFantasyLeagueFindResponse();

  CMsgDOTAFantasyLeagueFindResponse(const CMsgDOTAFantasyLeagueFindResponse& from);

  inline CMsgDOTAFantasyLeagueFindResponse& operator=(const CMsgDOTAFantasyLeagueFindResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueFindResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueFindResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueFindResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueFindResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueFindResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueFindResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS;
  static const EResult ERROR_LEAGUE_NOT_FOUND = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_NOT_FOUND;
  static const EResult ERROR_BAD_PASSWORD = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_BAD_PASSWORD;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_FULL = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_FULL;
  static const EResult ERROR_ALREADY_MEMBER = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_ALREADY_MEMBER;
  static const EResult ERROR_LEAGUE_LOCKED = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueFindResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueFindResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueFindResponse_EResult value);

  // optional string fantasy_league_name = 2;
  inline bool has_fantasy_league_name() const;
  inline void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 2;
  inline const ::std::string& fantasy_league_name() const;
  inline void set_fantasy_league_name(const ::std::string& value);
  inline void set_fantasy_league_name(const char* value);
  inline void set_fantasy_league_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_league_name();
  inline ::std::string* release_fantasy_league_name();
  inline void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional string commissioner_name = 3;
  inline bool has_commissioner_name() const;
  inline void clear_commissioner_name();
  static const int kCommissionerNameFieldNumber = 3;
  inline const ::std::string& commissioner_name() const;
  inline void set_commissioner_name(const ::std::string& value);
  inline void set_commissioner_name(const char* value);
  inline void set_commissioner_name(const char* value, size_t size);
  inline ::std::string* mutable_commissioner_name();
  inline ::std::string* release_commissioner_name();
  inline void set_allocated_commissioner_name(::std::string* commissioner_name);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueFindResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_league_name();
  inline void clear_has_fantasy_league_name();
  inline void set_has_commissioner_name();
  inline void clear_has_commissioner_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fantasy_league_name_;
  ::std::string* commissioner_name_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueFindResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfoRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueInfoRequest();
  virtual ~CMsgDOTAFantasyLeagueInfoRequest();

  CMsgDOTAFantasyLeagueInfoRequest(const CMsgDOTAFantasyLeagueInfoRequest& from);

  inline CMsgDOTAFantasyLeagueInfoRequest& operator=(const CMsgDOTAFantasyLeagueInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueInfoRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueInfoRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueInfoRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfoResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueInfoResponse();
  virtual ~CMsgDOTAFantasyLeagueInfoResponse();

  CMsgDOTAFantasyLeagueInfoResponse(const CMsgDOTAFantasyLeagueInfoResponse& from);

  inline CMsgDOTAFantasyLeagueInfoResponse& operator=(const CMsgDOTAFantasyLeagueInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueInfoResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueInfoResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_BAD_LEAGUE_ID = CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueInfoResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueInfoResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueInfoResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueInfoResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueMatchupsRequest();
  virtual ~CMsgDOTAFantasyLeagueMatchupsRequest();

  CMsgDOTAFantasyLeagueMatchupsRequest(const CMsgDOTAFantasyLeagueMatchupsRequest& from);

  inline CMsgDOTAFantasyLeagueMatchupsRequest& operator=(const CMsgDOTAFantasyLeagueMatchupsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueMatchupsRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueMatchupsRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueMatchupsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueMatchupsRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueMatchupsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse_Matchup : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse_Matchup();

  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& default_instance();

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 owner_account_id_1 = 1;
  inline bool has_owner_account_id_1() const;
  inline void clear_owner_account_id_1();
  static const int kOwnerAccountId1FieldNumber = 1;
  inline ::google::protobuf::uint32 owner_account_id_1() const;
  inline void set_owner_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 2;
  inline bool has_owner_account_id_2() const;
  inline void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id_2() const;
  inline void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional float score_1 = 3;
  inline bool has_score_1() const;
  inline void clear_score_1();
  static const int kScore1FieldNumber = 3;
  inline float score_1() const;
  inline void set_score_1(float value);

  // optional float score_2 = 4;
  inline bool has_score_2() const;
  inline void clear_score_2();
  static const int kScore2FieldNumber = 4;
  inline float score_2() const;
  inline void set_score_2(float value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup)
 private:
  inline void set_has_owner_account_id_1();
  inline void clear_has_owner_account_id_1();
  inline void set_has_owner_account_id_2();
  inline void clear_has_owner_account_id_2();
  inline void set_has_score_1();
  inline void clear_has_score_1();
  inline void set_has_score_2();
  inline void clear_has_score_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 owner_account_id_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  float score_1_;
  float score_2_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups();

  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& default_instance();

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CMsgDOTAFantasyLeagueMatchupsResponse.Matchup matchup = 1;
  inline int matchup_size() const;
  inline void clear_matchup();
  static const int kMatchupFieldNumber = 1;
  inline const ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& matchup(int index) const;
  inline ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* mutable_matchup(int index);
  inline ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* add_matchup();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >&
      matchup() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >*
      mutable_matchup();

  // optional uint32 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup > matchup_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse();

  CMsgDOTAFantasyLeagueMatchupsResponse(const CMsgDOTAFantasyLeagueMatchupsResponse& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueMatchupsResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueMatchupsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueMatchupsResponse_Matchup Matchup;
  typedef CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups WeeklyMatchups;

  typedef CMsgDOTAFantasyLeagueMatchupsResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_BAD_LEAGUE_ID = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_BAD_LEAGUE_ID;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueMatchupsResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueMatchupsResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // repeated .CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups weekly_matchups = 3;
  inline int weekly_matchups_size() const;
  inline void clear_weekly_matchups();
  static const int kWeeklyMatchupsFieldNumber = 3;
  inline const ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& weekly_matchups(int index) const;
  inline ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* mutable_weekly_matchups(int index);
  inline ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* add_weekly_matchups();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >&
      weekly_matchups() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >*
      mutable_weekly_matchups();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueMatchupsResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups > weekly_matchups_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueMatchupsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAEditFantasyTeamRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAEditFantasyTeamRequest();
  virtual ~CMsgDOTAEditFantasyTeamRequest();

  CMsgDOTAEditFantasyTeamRequest(const CMsgDOTAEditFantasyTeamRequest& from);

  inline CMsgDOTAEditFantasyTeamRequest& operator=(const CMsgDOTAEditFantasyTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAEditFantasyTeamRequest& default_instance();

  void Swap(CMsgDOTAEditFantasyTeamRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAEditFantasyTeamRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAEditFantasyTeamRequest& from);
  void MergeFrom(const CMsgDOTAEditFantasyTeamRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // optional string team_name = 3;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional uint64 team_logo = 4;
  inline bool has_team_logo() const;
  inline void clear_team_logo();
  static const int kTeamLogoFieldNumber = 4;
  inline ::google::protobuf::uint64 team_logo() const;
  inline void set_team_logo(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAEditFantasyTeamRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_team_logo();
  inline void clear_has_team_logo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::std::string* team_name_;
  ::google::protobuf::uint64 team_logo_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAEditFantasyTeamRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAEditFantasyTeamResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAEditFantasyTeamResponse();
  virtual ~CMsgDOTAEditFantasyTeamResponse();

  CMsgDOTAEditFantasyTeamResponse(const CMsgDOTAEditFantasyTeamResponse& from);

  inline CMsgDOTAEditFantasyTeamResponse& operator=(const CMsgDOTAEditFantasyTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAEditFantasyTeamResponse& default_instance();

  void Swap(CMsgDOTAEditFantasyTeamResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAEditFantasyTeamResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAEditFantasyTeamResponse& from);
  void MergeFrom(const CMsgDOTAEditFantasyTeamResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAEditFantasyTeamResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_INVALID_TEAM_INFO = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_INVALID_TEAM_INFO;
  static const EResult ERROR_NAME_ALREADY_TAKEN = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NAME_ALREADY_TAKEN;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAEditFantasyTeamResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAEditFantasyTeamResponse_EResult result() const;
  inline void set_result(::CMsgDOTAEditFantasyTeamResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAEditFantasyTeamResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAEditFantasyTeamResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();
  virtual ~CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();

  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);

  inline CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& operator=(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& default_instance();

  void Swap(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();
  virtual ~CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();

  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);

  inline CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& operator=(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& default_instance();

  void Swap(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 owner_account_id = 1;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID)
 private:
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 owner_account_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamInfoResponse();
  virtual ~CMsgDOTAFantasyTeamInfoResponse();

  CMsgDOTAFantasyTeamInfoResponse(const CMsgDOTAFantasyTeamInfoResponse& from);

  inline CMsgDOTAFantasyTeamInfoResponse& operator=(const CMsgDOTAFantasyTeamInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamInfoResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CMsgDOTAFantasyTeamInfo results = 1;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 1;
  inline const ::CMsgDOTAFantasyTeamInfo& results(int index) const;
  inline ::CMsgDOTAFantasyTeamInfo* mutable_results(int index);
  inline ::CMsgDOTAFantasyTeamInfo* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamInfo >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamInfo >*
      mutable_results();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamInfoResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamInfo > results_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfo : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamInfo();
  virtual ~CMsgDOTAFantasyTeamInfo();

  CMsgDOTAFantasyTeamInfo(const CMsgDOTAFantasyTeamInfo& from);

  inline CMsgDOTAFantasyTeamInfo& operator=(const CMsgDOTAFantasyTeamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamInfo& default_instance();

  void Swap(CMsgDOTAFantasyTeamInfo* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamInfo& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 3;
  inline bool has_fantasy_team_index() const;
  inline void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 fantasy_team_index() const;
  inline void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional string team_name = 4;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional uint64 team_logo = 5;
  inline bool has_team_logo() const;
  inline void clear_team_logo();
  static const int kTeamLogoFieldNumber = 5;
  inline ::google::protobuf::uint64 team_logo() const;
  inline void set_team_logo(::google::protobuf::uint64 value);

  // optional uint32 wins = 6;
  inline bool has_wins() const;
  inline void clear_wins();
  static const int kWinsFieldNumber = 6;
  inline ::google::protobuf::uint32 wins() const;
  inline void set_wins(::google::protobuf::uint32 value);

  // optional uint32 losses = 7;
  inline bool has_losses() const;
  inline void clear_losses();
  static const int kLossesFieldNumber = 7;
  inline ::google::protobuf::uint32 losses() const;
  inline void set_losses(::google::protobuf::uint32 value);

  // repeated uint32 current_roster = 8;
  inline int current_roster_size() const;
  inline void clear_current_roster();
  static const int kCurrentRosterFieldNumber = 8;
  inline ::google::protobuf::uint32 current_roster(int index) const;
  inline void set_current_roster(int index, ::google::protobuf::uint32 value);
  inline void add_current_roster(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      current_roster() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_current_roster();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamInfo)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_fantasy_team_index();
  inline void clear_has_fantasy_team_index();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_team_logo();
  inline void clear_has_team_logo();
  inline void set_has_wins();
  inline void clear_has_wins();
  inline void set_has_losses();
  inline void clear_has_losses();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::std::string* team_name_;
  ::google::protobuf::uint32 fantasy_team_index_;
  ::google::protobuf::uint32 wins_;
  ::google::protobuf::uint64 team_logo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > current_roster_;
  ::google::protobuf::uint32 losses_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamScoreRequest();
  virtual ~CMsgDOTAFantasyTeamScoreRequest();

  CMsgDOTAFantasyTeamScoreRequest(const CMsgDOTAFantasyTeamScoreRequest& from);

  inline CMsgDOTAFantasyTeamScoreRequest& operator=(const CMsgDOTAFantasyTeamScoreRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamScoreRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamScoreRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamScoreRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamScoreRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 3;
  inline bool has_fantasy_team_index() const;
  inline void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 fantasy_team_index() const;
  inline void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 4;
  inline bool has_filter_match_id() const;
  inline void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 4;
  inline ::google::protobuf::uint64 filter_match_id() const;
  inline void set_filter_match_id(::google::protobuf::uint64 value);

  // optional uint32 filter_start_time = 5;
  inline bool has_filter_start_time() const;
  inline void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 filter_start_time() const;
  inline void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 6;
  inline bool has_filter_end_time() const;
  inline void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 filter_end_time() const;
  inline void set_filter_end_time(::google::protobuf::uint32 value);

  // optional bool include_bench = 7;
  inline bool has_include_bench() const;
  inline void clear_include_bench();
  static const int kIncludeBenchFieldNumber = 7;
  inline bool include_bench() const;
  inline void set_include_bench(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamScoreRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_fantasy_team_index();
  inline void clear_has_fantasy_team_index();
  inline void set_has_filter_match_id();
  inline void clear_has_filter_match_id();
  inline void set_has_filter_start_time();
  inline void clear_has_filter_start_time();
  inline void set_has_filter_end_time();
  inline void clear_has_filter_end_time();
  inline void set_has_include_bench();
  inline void clear_has_include_bench();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint64 filter_match_id_;
  ::google::protobuf::uint32 fantasy_team_index_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  bool include_bench_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamScoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore();
  virtual ~CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore();

  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);

  inline CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& operator=(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& default_instance();

  void Swap(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // optional float score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  float score_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamScoreResponse();
  virtual ~CMsgDOTAFantasyTeamScoreResponse();

  CMsgDOTAFantasyTeamScoreResponse(const CMsgDOTAFantasyTeamScoreResponse& from);

  inline CMsgDOTAFantasyTeamScoreResponse& operator=(const CMsgDOTAFantasyTeamScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamScoreResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamScoreResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamScoreResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamScoreResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore CMsgPlayerScore;

  typedef CMsgDOTAFantasyTeamScoreResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE = CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamScoreResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamScoreResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamScoreResponse_EResult value);

  // optional float fantasy_team_score = 2;
  inline bool has_fantasy_team_score() const;
  inline void clear_fantasy_team_score();
  static const int kFantasyTeamScoreFieldNumber = 2;
  inline float fantasy_team_score() const;
  inline void set_fantasy_team_score(float value);

  // repeated .CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore fantasy_player_score = 3;
  inline int fantasy_player_score_size() const;
  inline void clear_fantasy_player_score();
  static const int kFantasyPlayerScoreFieldNumber = 3;
  inline const ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& fantasy_player_score(int index) const;
  inline ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* mutable_fantasy_player_score(int index);
  inline ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* add_fantasy_player_score();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >&
      fantasy_player_score() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >*
      mutable_fantasy_player_score();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamScoreResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_team_score();
  inline void clear_has_fantasy_team_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  float fantasy_team_score_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore > fantasy_player_score_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamScoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamStandingsRequest();
  virtual ~CMsgDOTAFantasyTeamStandingsRequest();

  CMsgDOTAFantasyTeamStandingsRequest(const CMsgDOTAFantasyTeamStandingsRequest& from);

  inline CMsgDOTAFantasyTeamStandingsRequest& operator=(const CMsgDOTAFantasyTeamStandingsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamStandingsRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamStandingsRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamStandingsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 3;
  inline bool has_filter_start_time() const;
  inline void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 filter_start_time() const;
  inline void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 4;
  inline bool has_filter_end_time() const;
  inline void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 filter_end_time() const;
  inline void set_filter_end_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 5;
  inline bool has_filter_match_id() const;
  inline void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 5;
  inline ::google::protobuf::uint64 filter_match_id() const;
  inline void set_filter_match_id(::google::protobuf::uint64 value);

  // optional bool filter_last_match = 6;
  inline bool has_filter_last_match() const;
  inline void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 6;
  inline bool filter_last_match() const;
  inline void set_filter_last_match(bool value);

  // optional bool filter_in_hall = 7;
  inline bool has_filter_in_hall() const;
  inline void clear_filter_in_hall();
  static const int kFilterInHallFieldNumber = 7;
  inline bool filter_in_hall() const;
  inline void set_filter_in_hall(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamStandingsRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_filter_start_time();
  inline void clear_has_filter_start_time();
  inline void set_has_filter_end_time();
  inline void clear_has_filter_end_time();
  inline void set_has_filter_match_id();
  inline void clear_has_filter_match_id();
  inline void set_has_filter_last_match();
  inline void clear_has_filter_last_match();
  inline void set_has_filter_in_hall();
  inline void clear_has_filter_in_hall();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  ::google::protobuf::uint64 filter_match_id_;
  bool filter_last_match_;
  bool filter_in_hall_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamStandingsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore();
  virtual ~CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore();

  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);

  inline CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& operator=(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& default_instance();

  void Swap(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 3;
  inline bool has_fantasy_team_index() const;
  inline void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 fantasy_team_index() const;
  inline void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional uint64 fantasy_team_logo = 4;
  inline bool has_fantasy_team_logo() const;
  inline void clear_fantasy_team_logo();
  static const int kFantasyTeamLogoFieldNumber = 4;
  inline ::google::protobuf::uint64 fantasy_team_logo() const;
  inline void set_fantasy_team_logo(::google::protobuf::uint64 value);

  // optional string owner_name = 5;
  inline bool has_owner_name() const;
  inline void clear_owner_name();
  static const int kOwnerNameFieldNumber = 5;
  inline const ::std::string& owner_name() const;
  inline void set_owner_name(const ::std::string& value);
  inline void set_owner_name(const char* value);
  inline void set_owner_name(const char* value, size_t size);
  inline ::std::string* mutable_owner_name();
  inline ::std::string* release_owner_name();
  inline void set_allocated_owner_name(::std::string* owner_name);

  // optional string fantasy_team_name = 6;
  inline bool has_fantasy_team_name() const;
  inline void clear_fantasy_team_name();
  static const int kFantasyTeamNameFieldNumber = 6;
  inline const ::std::string& fantasy_team_name() const;
  inline void set_fantasy_team_name(const ::std::string& value);
  inline void set_fantasy_team_name(const char* value);
  inline void set_fantasy_team_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_team_name();
  inline ::std::string* release_fantasy_team_name();
  inline void set_allocated_fantasy_team_name(::std::string* fantasy_team_name);

  // optional float score = 7;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline float score() const;
  inline void set_score(float value);

  // optional float score_against = 8;
  inline bool has_score_against() const;
  inline void clear_score_against();
  static const int kScoreAgainstFieldNumber = 8;
  inline float score_against() const;
  inline void set_score_against(float value);

  // optional uint32 wins = 9;
  inline bool has_wins() const;
  inline void clear_wins();
  static const int kWinsFieldNumber = 9;
  inline ::google::protobuf::uint32 wins() const;
  inline void set_wins(::google::protobuf::uint32 value);

  // optional uint32 losses = 10;
  inline bool has_losses() const;
  inline void clear_losses();
  static const int kLossesFieldNumber = 10;
  inline ::google::protobuf::uint32 losses() const;
  inline void set_losses(::google::protobuf::uint32 value);

  // optional int32 streak = 11;
  inline bool has_streak() const;
  inline void clear_streak();
  static const int kStreakFieldNumber = 11;
  inline ::google::protobuf::int32 streak() const;
  inline void set_streak(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_fantasy_team_index();
  inline void clear_has_fantasy_team_index();
  inline void set_has_fantasy_team_logo();
  inline void clear_has_fantasy_team_logo();
  inline void set_has_owner_name();
  inline void clear_has_owner_name();
  inline void set_has_fantasy_team_name();
  inline void clear_has_fantasy_team_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_score_against();
  inline void clear_has_score_against();
  inline void set_has_wins();
  inline void clear_has_wins();
  inline void set_has_losses();
  inline void clear_has_losses();
  inline void set_has_streak();
  inline void clear_has_streak();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint64 fantasy_team_logo_;
  ::std::string* owner_name_;
  ::google::protobuf::uint32 fantasy_team_index_;
  float score_;
  ::std::string* fantasy_team_name_;
  float score_against_;
  ::google::protobuf::uint32 wins_;
  ::google::protobuf::uint32 losses_;
  ::google::protobuf::int32 streak_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamStandingsResponse();
  virtual ~CMsgDOTAFantasyTeamStandingsResponse();

  CMsgDOTAFantasyTeamStandingsResponse(const CMsgDOTAFantasyTeamStandingsResponse& from);

  inline CMsgDOTAFantasyTeamStandingsResponse& operator=(const CMsgDOTAFantasyTeamStandingsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamStandingsResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamStandingsResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamStandingsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore CMsgTeamScore;

  typedef CMsgDOTAFantasyTeamStandingsResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamStandingsResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamStandingsResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamStandingsResponse_EResult value);

  // repeated .CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore team_scores = 3;
  inline int team_scores_size() const;
  inline void clear_team_scores();
  static const int kTeamScoresFieldNumber = 3;
  inline const ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& team_scores(int index) const;
  inline ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* mutable_team_scores(int index);
  inline ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* add_team_scores();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >&
      team_scores() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >*
      mutable_team_scores();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamStandingsResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore > team_scores_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamStandingsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerScoreRequest();
  virtual ~CMsgDOTAFantasyPlayerScoreRequest();

  CMsgDOTAFantasyPlayerScoreRequest(const CMsgDOTAFantasyPlayerScoreRequest& from);

  inline CMsgDOTAFantasyPlayerScoreRequest& operator=(const CMsgDOTAFantasyPlayerScoreRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerScoreRequest& default_instance();

  void Swap(CMsgDOTAFantasyPlayerScoreRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerScoreRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 2;
  inline bool has_player_account_id() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_account_id() const;
  inline void set_player_account_id(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 3;
  inline bool has_filter_start_time() const;
  inline void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 filter_start_time() const;
  inline void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 4;
  inline bool has_filter_end_time() const;
  inline void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 filter_end_time() const;
  inline void set_filter_end_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 5;
  inline bool has_filter_match_id() const;
  inline void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 5;
  inline ::google::protobuf::uint64 filter_match_id() const;
  inline void set_filter_match_id(::google::protobuf::uint64 value);

  // optional bool filter_last_match = 6;
  inline bool has_filter_last_match() const;
  inline void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 6;
  inline bool filter_last_match() const;
  inline void set_filter_last_match(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerScoreRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_player_account_id();
  inline void clear_has_player_account_id();
  inline void set_has_filter_start_time();
  inline void clear_has_filter_start_time();
  inline void set_has_filter_end_time();
  inline void clear_has_filter_end_time();
  inline void set_has_filter_match_id();
  inline void clear_has_filter_match_id();
  inline void set_has_filter_last_match();
  inline void clear_has_filter_last_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 player_account_id_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  ::google::protobuf::uint64 filter_match_id_;
  bool filter_last_match_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerScoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerScoreResponse();
  virtual ~CMsgDOTAFantasyPlayerScoreResponse();

  CMsgDOTAFantasyPlayerScoreResponse(const CMsgDOTAFantasyPlayerScoreResponse& from);

  inline CMsgDOTAFantasyPlayerScoreResponse& operator=(const CMsgDOTAFantasyPlayerScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerScoreResponse& default_instance();

  void Swap(CMsgDOTAFantasyPlayerScoreResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerScoreResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerScoreResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyPlayerScoreResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyPlayerScoreResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyPlayerScoreResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 3;
  inline bool has_player_account_id() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint32 player_account_id() const;
  inline void set_player_account_id(::google::protobuf::uint32 value);

  // optional string player_name = 4;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 4;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional float score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerScoreResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_player_account_id();
  inline void clear_has_player_account_id();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::std::string* player_name_;
  ::google::protobuf::uint32 player_account_id_;
  float score_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerScoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerStandingsRequest();
  virtual ~CMsgDOTAFantasyPlayerStandingsRequest();

  CMsgDOTAFantasyPlayerStandingsRequest(const CMsgDOTAFantasyPlayerStandingsRequest& from);

  inline CMsgDOTAFantasyPlayerStandingsRequest& operator=(const CMsgDOTAFantasyPlayerStandingsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerStandingsRequest& default_instance();

  void Swap(CMsgDOTAFantasyPlayerStandingsRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerStandingsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline ::google::protobuf::uint32 role() const;
  inline void set_role(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 4;
  inline bool has_filter_start_time() const;
  inline void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 filter_start_time() const;
  inline void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 5;
  inline bool has_filter_end_time() const;
  inline void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 filter_end_time() const;
  inline void set_filter_end_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 6;
  inline bool has_filter_match_id() const;
  inline void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 6;
  inline ::google::protobuf::uint64 filter_match_id() const;
  inline void set_filter_match_id(::google::protobuf::uint64 value);

  // optional bool filter_last_match = 7;
  inline bool has_filter_last_match() const;
  inline void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 7;
  inline bool filter_last_match() const;
  inline void set_filter_last_match(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerStandingsRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_filter_start_time();
  inline void clear_has_filter_start_time();
  inline void set_has_filter_end_time();
  inline void clear_has_filter_end_time();
  inline void set_has_filter_match_id();
  inline void clear_has_filter_match_id();
  inline void set_has_filter_last_match();
  inline void clear_has_filter_last_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 role_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint64 filter_match_id_;
  ::google::protobuf::uint32 filter_end_time_;
  bool filter_last_match_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerStandingsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore();
  virtual ~CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore();

  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);

  inline CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& operator=(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& default_instance();

  void Swap(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_account_id = 1;
  inline bool has_player_account_id() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_account_id() const;
  inline void set_player_account_id(::google::protobuf::uint32 value);

  // optional string player_name = 2;
  inline bool has_player_name() const;
  inline void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  inline const ::std::string& player_name() const;
  inline void set_player_name(const ::std::string& value);
  inline void set_player_name(const char* value);
  inline void set_player_name(const char* value, size_t size);
  inline ::std::string* mutable_player_name();
  inline ::std::string* release_player_name();
  inline void set_allocated_player_name(::std::string* player_name);

  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore)
 private:
  inline void set_has_player_account_id();
  inline void clear_has_player_account_id();
  inline void set_has_player_name();
  inline void clear_has_player_name();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* player_name_;
  ::google::protobuf::uint32 player_account_id_;
  float score_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerStandingsResponse();
  virtual ~CMsgDOTAFantasyPlayerStandingsResponse();

  CMsgDOTAFantasyPlayerStandingsResponse(const CMsgDOTAFantasyPlayerStandingsResponse& from);

  inline CMsgDOTAFantasyPlayerStandingsResponse& operator=(const CMsgDOTAFantasyPlayerStandingsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerStandingsResponse& default_instance();

  void Swap(CMsgDOTAFantasyPlayerStandingsResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerStandingsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore CMsgPlayerScore;

  typedef CMsgDOTAFantasyPlayerStandingsResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyPlayerStandingsResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyPlayerStandingsResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyPlayerStandingsResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline ::google::protobuf::uint32 role() const;
  inline void set_role(::google::protobuf::uint32 value);

  // repeated .CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore player_scores = 4;
  inline int player_scores_size() const;
  inline void clear_player_scores();
  static const int kPlayerScoresFieldNumber = 4;
  inline const ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& player_scores(int index) const;
  inline ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* mutable_player_scores(int index);
  inline ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* add_player_scores();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >&
      player_scores() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >*
      mutable_player_scores();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerStandingsResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore > player_scores_;
  ::google::protobuf::uint32 role_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerStandingsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerInfoRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerInfoRequest();
  virtual ~CMsgDOTAFantasyPlayerInfoRequest();

  CMsgDOTAFantasyPlayerInfoRequest(const CMsgDOTAFantasyPlayerInfoRequest& from);

  inline CMsgDOTAFantasyPlayerInfoRequest& operator=(const CMsgDOTAFantasyPlayerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerInfoRequest& default_instance();

  void Swap(CMsgDOTAFantasyPlayerInfoRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerInfoRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerInfoRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerInfoResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerInfoResponse();
  virtual ~CMsgDOTAFantasyPlayerInfoResponse();

  CMsgDOTAFantasyPlayerInfoResponse(const CMsgDOTAFantasyPlayerInfoResponse& from);

  inline CMsgDOTAFantasyPlayerInfoResponse& operator=(const CMsgDOTAFantasyPlayerInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerInfoResponse& default_instance();

  void Swap(CMsgDOTAFantasyPlayerInfoResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CMsgGCPlayerInfo msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::CMsgGCPlayerInfo& msg() const;
  inline ::CMsgGCPlayerInfo* mutable_msg();
  inline ::CMsgGCPlayerInfo* release_msg();
  inline void set_allocated_msg(::CMsgGCPlayerInfo* msg);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerInfoResponse)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CMsgGCPlayerInfo* msg_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueCreateRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueCreateRequest();
  virtual ~CMsgDOTAFantasyLeagueCreateRequest();

  CMsgDOTAFantasyLeagueCreateRequest(const CMsgDOTAFantasyLeagueCreateRequest& from);

  inline CMsgDOTAFantasyLeagueCreateRequest& operator=(const CMsgDOTAFantasyLeagueCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueCreateRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueCreateRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueCreateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueCreateRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueCreateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 season_id = 1;
  inline bool has_season_id() const;
  inline void clear_season_id();
  static const int kSeasonIdFieldNumber = 1;
  inline ::google::protobuf::uint32 season_id() const;
  inline void set_season_id(::google::protobuf::uint32 value);

  // optional string fantasy_league_name = 2;
  inline bool has_fantasy_league_name() const;
  inline void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 2;
  inline const ::std::string& fantasy_league_name() const;
  inline void set_fantasy_league_name(const ::std::string& value);
  inline void set_fantasy_league_name(const char* value);
  inline void set_fantasy_league_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_league_name();
  inline ::std::string* release_fantasy_league_name();
  inline void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string team_name = 4;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional uint64 logo = 5;
  inline bool has_logo() const;
  inline void clear_logo();
  static const int kLogoFieldNumber = 5;
  inline ::google::protobuf::uint64 logo() const;
  inline void set_logo(::google::protobuf::uint64 value);

  // optional uint64 ticket_item_id = 6;
  inline bool has_ticket_item_id() const;
  inline void clear_ticket_item_id();
  static const int kTicketItemIdFieldNumber = 6;
  inline ::google::protobuf::uint64 ticket_item_id() const;
  inline void set_ticket_item_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueCreateRequest)
 private:
  inline void set_has_season_id();
  inline void clear_has_season_id();
  inline void set_has_fantasy_league_name();
  inline void clear_has_fantasy_league_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_logo();
  inline void clear_has_logo();
  inline void set_has_ticket_item_id();
  inline void clear_has_ticket_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fantasy_league_name_;
  ::std::string* password_;
  ::std::string* team_name_;
  ::google::protobuf::uint64 logo_;
  ::google::protobuf::uint64 ticket_item_id_;
  ::google::protobuf::uint32 season_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueCreateRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueCreateResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueCreateResponse();
  virtual ~CMsgDOTAFantasyLeagueCreateResponse();

  CMsgDOTAFantasyLeagueCreateResponse(const CMsgDOTAFantasyLeagueCreateResponse& from);

  inline CMsgDOTAFantasyLeagueCreateResponse& operator=(const CMsgDOTAFantasyLeagueCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueCreateResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueCreateResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueCreateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueCreateResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueCreateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueCreateResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_BAD_SEASON_ID = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_SEASON_ID;
  static const EResult ERROR_BAD_LEAGUE_NAME = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_LEAGUE_NAME;
  static const EResult ERROR_BAD_TEAM_NAME = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_TEAM_NAME;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_FAILED_LOGO_UPLOAD = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD;
  static const EResult ERROR_NO_TICKET = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueCreateResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueCreateResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueCreateResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueCreateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueCreateResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamCreateRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamCreateRequest();
  virtual ~CMsgDOTAFantasyTeamCreateRequest();

  CMsgDOTAFantasyTeamCreateRequest(const CMsgDOTAFantasyTeamCreateRequest& from);

  inline CMsgDOTAFantasyTeamCreateRequest& operator=(const CMsgDOTAFantasyTeamCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamCreateRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamCreateRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamCreateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamCreateRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamCreateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string team_name = 3;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional uint64 logo = 4;
  inline bool has_logo() const;
  inline void clear_logo();
  static const int kLogoFieldNumber = 4;
  inline ::google::protobuf::uint64 logo() const;
  inline void set_logo(::google::protobuf::uint64 value);

  // optional uint64 ticket_item_id = 5;
  inline bool has_ticket_item_id() const;
  inline void clear_ticket_item_id();
  static const int kTicketItemIdFieldNumber = 5;
  inline ::google::protobuf::uint64 ticket_item_id() const;
  inline void set_ticket_item_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamCreateRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_logo();
  inline void clear_has_logo();
  inline void set_has_ticket_item_id();
  inline void clear_has_ticket_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::std::string* team_name_;
  ::google::protobuf::uint64 logo_;
  ::google::protobuf::uint64 ticket_item_id_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamCreateRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamCreateResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamCreateResponse();
  virtual ~CMsgDOTAFantasyTeamCreateResponse();

  CMsgDOTAFantasyTeamCreateResponse(const CMsgDOTAFantasyTeamCreateResponse& from);

  inline CMsgDOTAFantasyTeamCreateResponse& operator=(const CMsgDOTAFantasyTeamCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamCreateResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamCreateResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamCreateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamCreateResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamCreateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamCreateResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_FAILED_LOGO_UPLOAD = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD;
  static const EResult ERROR_BAD_FANTASY_LEAGUE_ID = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_FANTASY_LEAGUE_ID;
  static const EResult ERROR_BAD_NAME = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_NAME;
  static const EResult ERROR_FULL = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FULL;
  static const EResult ERROR_ALREADY_MEMBER = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_ALREADY_MEMBER;
  static const EResult ERROR_BAD_PASSWORD = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_PASSWORD;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_TICKET = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_TICKET;
  static const EResult ERROR_LEAGUE_LOCKED = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamCreateResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamCreateResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamCreateResponse_EResult value);

  // optional uint32 fantasy_team_index = 2;
  inline bool has_fantasy_team_index() const;
  inline void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_team_index() const;
  inline void set_fantasy_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamCreateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fantasy_team_index();
  inline void clear_has_fantasy_team_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_team_index_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamCreateResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange();

  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);

  inline CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& operator=(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& default_instance();

  void Swap(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // optional bool invited = 2;
  inline bool has_invited() const;
  inline void clear_invited();
  static const int kInvitedFieldNumber = 2;
  inline bool invited() const;
  inline void set_invited(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_invited();
  inline void clear_has_invited();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  bool invited_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueEditInvitesRequest();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesRequest();

  CMsgDOTAFantasyLeagueEditInvitesRequest(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);

  inline CMsgDOTAFantasyLeagueEditInvitesRequest& operator=(const CMsgDOTAFantasyLeagueEditInvitesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueEditInvitesRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueEditInvitesRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueEditInvitesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange InviteChange;

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // repeated .CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange invite_change = 3;
  inline int invite_change_size() const;
  inline void clear_invite_change();
  static const int kInviteChangeFieldNumber = 3;
  inline const ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& invite_change(int index) const;
  inline ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* mutable_invite_change(int index);
  inline ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* add_invite_change();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >&
      invite_change() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >*
      mutable_invite_change();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueEditInvitesRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange > invite_change_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueEditInvitesRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueEditInvitesResponse();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesResponse();

  CMsgDOTAFantasyLeagueEditInvitesResponse(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);

  inline CMsgDOTAFantasyLeagueEditInvitesResponse& operator=(const CMsgDOTAFantasyLeagueEditInvitesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueEditInvitesResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueEditInvitesResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueEditInvitesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInvitesResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueEditInvitesResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueEditInvitesResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueEditInvitesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftStatusRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueDraftStatusRequest();
  virtual ~CMsgDOTAFantasyLeagueDraftStatusRequest();

  CMsgDOTAFantasyLeagueDraftStatusRequest(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);

  inline CMsgDOTAFantasyLeagueDraftStatusRequest& operator=(const CMsgDOTAFantasyLeagueDraftStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueDraftStatusRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueDraftStatusRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueDraftStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueDraftStatusRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueDraftStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftStatus : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueDraftStatus();
  virtual ~CMsgDOTAFantasyLeagueDraftStatus();

  CMsgDOTAFantasyLeagueDraftStatus(const CMsgDOTAFantasyLeagueDraftStatus& from);

  inline CMsgDOTAFantasyLeagueDraftStatus& operator=(const CMsgDOTAFantasyLeagueDraftStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueDraftStatus& default_instance();

  void Swap(CMsgDOTAFantasyLeagueDraftStatus* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueDraftStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftStatus& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // repeated uint32 draft_order = 2;
  inline int draft_order_size() const;
  inline void clear_draft_order();
  static const int kDraftOrderFieldNumber = 2;
  inline ::google::protobuf::uint32 draft_order(int index) const;
  inline void set_draft_order(int index, ::google::protobuf::uint32 value);
  inline void add_draft_order(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      draft_order() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_draft_order();

  // optional uint32 current_pick = 3;
  inline bool has_current_pick() const;
  inline void clear_current_pick();
  static const int kCurrentPickFieldNumber = 3;
  inline ::google::protobuf::uint32 current_pick() const;
  inline void set_current_pick(::google::protobuf::uint32 value);

  // optional uint32 time_remaining = 4;
  inline bool has_time_remaining() const;
  inline void clear_time_remaining();
  static const int kTimeRemainingFieldNumber = 4;
  inline ::google::protobuf::uint32 time_remaining() const;
  inline void set_time_remaining(::google::protobuf::uint32 value);

  // optional bool pending_resume = 5;
  inline bool has_pending_resume() const;
  inline void clear_pending_resume();
  static const int kPendingResumeFieldNumber = 5;
  inline bool pending_resume() const;
  inline void set_pending_resume(bool value);

  // optional bool completed = 6;
  inline bool has_completed() const;
  inline void clear_completed();
  static const int kCompletedFieldNumber = 6;
  inline bool completed() const;
  inline void set_completed(bool value);

  // repeated uint32 available_players = 7;
  inline int available_players_size() const;
  inline void clear_available_players();
  static const int kAvailablePlayersFieldNumber = 7;
  inline ::google::protobuf::uint32 available_players(int index) const;
  inline void set_available_players(int index, ::google::protobuf::uint32 value);
  inline void add_available_players(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      available_players() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_available_players();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueDraftStatus)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_current_pick();
  inline void clear_has_current_pick();
  inline void set_has_time_remaining();
  inline void clear_has_time_remaining();
  inline void set_has_pending_resume();
  inline void clear_has_pending_resume();
  inline void set_has_completed();
  inline void clear_has_completed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > draft_order_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 current_pick_;
  ::google::protobuf::uint32 time_remaining_;
  bool pending_resume_;
  bool completed_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > available_players_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueDraftStatus* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftPlayerRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueDraftPlayerRequest();
  virtual ~CMsgDOTAFantasyLeagueDraftPlayerRequest();

  CMsgDOTAFantasyLeagueDraftPlayerRequest(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);

  inline CMsgDOTAFantasyLeagueDraftPlayerRequest& operator=(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueDraftPlayerRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeagueDraftPlayerRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueDraftPlayerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 3;
  inline bool has_player_account_id() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint32 player_account_id() const;
  inline void set_player_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueDraftPlayerRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();
  inline void set_has_player_account_id();
  inline void clear_has_player_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 player_account_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueDraftPlayerRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftPlayerResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeagueDraftPlayerResponse();
  virtual ~CMsgDOTAFantasyLeagueDraftPlayerResponse();

  CMsgDOTAFantasyLeagueDraftPlayerResponse(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);

  inline CMsgDOTAFantasyLeagueDraftPlayerResponse& operator=(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeagueDraftPlayerResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeagueDraftPlayerResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeagueDraftPlayerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_INVALID_FANTASY_LEAGUE = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_INVALID_FANTASY_LEAGUE;
  static const EResult ERROR_FANTASY_LEAGUE_NOT_DRAFTING = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_FANTASY_LEAGUE_NOT_DRAFTING;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_NOT_OWNERS_TURN = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_NOT_OWNERS_TURN;
  static const EResult ERROR_PLAYER_INVALID = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_INVALID;
  static const EResult ERROR_PLAYER_UNAVAILABLE = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_UNAVAILABLE;
  static const EResult ERROR_PLAYER_NO_VALID_SLOTS = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeagueDraftPlayerResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeagueDraftPlayerResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterSwapRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterSwapRequest();
  virtual ~CMsgDOTAFantasyTeamRosterSwapRequest();

  CMsgDOTAFantasyTeamRosterSwapRequest(const CMsgDOTAFantasyTeamRosterSwapRequest& from);

  inline CMsgDOTAFantasyTeamRosterSwapRequest& operator=(const CMsgDOTAFantasyTeamRosterSwapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterSwapRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterSwapRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterSwapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterSwapRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterSwapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 slot_1 = 4;
  inline bool has_slot_1() const;
  inline void clear_slot_1();
  static const int kSlot1FieldNumber = 4;
  inline ::google::protobuf::uint32 slot_1() const;
  inline void set_slot_1(::google::protobuf::uint32 value);

  // optional uint32 slot_2 = 5;
  inline bool has_slot_2() const;
  inline void clear_slot_2();
  static const int kSlot2FieldNumber = 5;
  inline ::google::protobuf::uint32 slot_2() const;
  inline void set_slot_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterSwapRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_slot_1();
  inline void clear_has_slot_1();
  inline void set_has_slot_2();
  inline void clear_has_slot_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 slot_1_;
  ::google::protobuf::uint32 slot_2_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterSwapRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterSwapResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterSwapResponse();
  virtual ~CMsgDOTAFantasyTeamRosterSwapResponse();

  CMsgDOTAFantasyTeamRosterSwapResponse(const CMsgDOTAFantasyTeamRosterSwapResponse& from);

  inline CMsgDOTAFantasyTeamRosterSwapResponse& operator=(const CMsgDOTAFantasyTeamRosterSwapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterSwapResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterSwapResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterSwapResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterSwapResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterSwapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterSwapResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_SLOTS_INVALID = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOTS_INVALID;
  static const EResult ERROR_SLOT_LOCKED = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamRosterSwapResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamRosterSwapResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterSwapResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterSwapResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterAddDropRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterAddDropRequest();
  virtual ~CMsgDOTAFantasyTeamRosterAddDropRequest();

  CMsgDOTAFantasyTeamRosterAddDropRequest(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);

  inline CMsgDOTAFantasyTeamRosterAddDropRequest& operator=(const CMsgDOTAFantasyTeamRosterAddDropRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterAddDropRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterAddDropRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterAddDropRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 add_account_id = 5;
  inline bool has_add_account_id() const;
  inline void clear_add_account_id();
  static const int kAddAccountIdFieldNumber = 5;
  inline ::google::protobuf::uint32 add_account_id() const;
  inline void set_add_account_id(::google::protobuf::uint32 value);

  // optional uint32 drop_account_id = 6;
  inline bool has_drop_account_id() const;
  inline void clear_drop_account_id();
  static const int kDropAccountIdFieldNumber = 6;
  inline ::google::protobuf::uint32 drop_account_id() const;
  inline void set_drop_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterAddDropRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();
  inline void set_has_add_account_id();
  inline void clear_has_add_account_id();
  inline void set_has_drop_account_id();
  inline void clear_has_drop_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 add_account_id_;
  ::google::protobuf::uint32 drop_account_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterAddDropRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterAddDropResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterAddDropResponse();
  virtual ~CMsgDOTAFantasyTeamRosterAddDropResponse();

  CMsgDOTAFantasyTeamRosterAddDropResponse(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);

  inline CMsgDOTAFantasyTeamRosterAddDropResponse& operator=(const CMsgDOTAFantasyTeamRosterAddDropResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterAddDropResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterAddDropResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterAddDropResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterAddDropResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_PLAYER_NOT_AVAILABLE = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_AVAILABLE;
  static const EResult ERROR_PLAYER_NOT_ON_TEAM = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_ON_TEAM;
  static const EResult ERROR_TRADE_ALREADY_PENDING = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamRosterAddDropResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterAddDropResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterAddDropResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamTradesRequest();
  virtual ~CMsgDOTAFantasyTeamTradesRequest();

  CMsgDOTAFantasyTeamTradesRequest(const CMsgDOTAFantasyTeamTradesRequest& from);

  inline CMsgDOTAFantasyTeamTradesRequest& operator=(const CMsgDOTAFantasyTeamTradesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamTradesRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamTradesRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamTradesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamTradesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamTradesRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamTradesRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesResponse_Trade : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamTradesResponse_Trade();
  virtual ~CMsgDOTAFantasyTeamTradesResponse_Trade();

  CMsgDOTAFantasyTeamTradesResponse_Trade(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);

  inline CMsgDOTAFantasyTeamTradesResponse_Trade& operator=(const CMsgDOTAFantasyTeamTradesResponse_Trade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamTradesResponse_Trade& default_instance();

  void Swap(CMsgDOTAFantasyTeamTradesResponse_Trade* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamTradesResponse_Trade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_1 = 2;
  inline bool has_owner_account_id_1() const;
  inline void clear_owner_account_id_1();
  static const int kOwnerAccountId1FieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id_1() const;
  inline void set_owner_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 3;
  inline bool has_owner_account_id_2() const;
  inline void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 3;
  inline ::google::protobuf::uint32 owner_account_id_2() const;
  inline void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 player_account_id_1 = 4;
  inline bool has_player_account_id_1() const;
  inline void clear_player_account_id_1();
  static const int kPlayerAccountId1FieldNumber = 4;
  inline ::google::protobuf::uint32 player_account_id_1() const;
  inline void set_player_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 player_account_id_2 = 5;
  inline bool has_player_account_id_2() const;
  inline void clear_player_account_id_2();
  static const int kPlayerAccountId2FieldNumber = 5;
  inline ::google::protobuf::uint32 player_account_id_2() const;
  inline void set_player_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamTradesResponse.Trade)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_owner_account_id_1();
  inline void clear_has_owner_account_id_1();
  inline void set_has_owner_account_id_2();
  inline void clear_has_owner_account_id_2();
  inline void set_has_player_account_id_1();
  inline void clear_has_player_account_id_1();
  inline void set_has_player_account_id_2();
  inline void clear_has_player_account_id_2();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 owner_account_id_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  ::google::protobuf::uint32 player_account_id_1_;
  ::google::protobuf::uint32 player_account_id_2_;
  ::google::protobuf::uint32 status_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamTradesResponse_Trade* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamTradesResponse();
  virtual ~CMsgDOTAFantasyTeamTradesResponse();

  CMsgDOTAFantasyTeamTradesResponse(const CMsgDOTAFantasyTeamTradesResponse& from);

  inline CMsgDOTAFantasyTeamTradesResponse& operator=(const CMsgDOTAFantasyTeamTradesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamTradesResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamTradesResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamTradesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamTradesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamTradesResponse_Trade Trade;

  typedef CMsgDOTAFantasyTeamTradesResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamTradesResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamTradesResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamTradesResponse_EResult value);

  // repeated .CMsgDOTAFantasyTeamTradesResponse.Trade trades = 2;
  inline int trades_size() const;
  inline void clear_trades();
  static const int kTradesFieldNumber = 2;
  inline const ::CMsgDOTAFantasyTeamTradesResponse_Trade& trades(int index) const;
  inline ::CMsgDOTAFantasyTeamTradesResponse_Trade* mutable_trades(int index);
  inline ::CMsgDOTAFantasyTeamTradesResponse_Trade* add_trades();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamTradesResponse_Trade >&
      trades() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamTradesResponse_Trade >*
      mutable_trades();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamTradesResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamTradesResponse_Trade > trades_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamTradesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradeCancelRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamTradeCancelRequest();
  virtual ~CMsgDOTAFantasyTeamTradeCancelRequest();

  CMsgDOTAFantasyTeamTradeCancelRequest(const CMsgDOTAFantasyTeamTradeCancelRequest& from);

  inline CMsgDOTAFantasyTeamTradeCancelRequest& operator=(const CMsgDOTAFantasyTeamTradeCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamTradeCancelRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamTradeCancelRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamTradeCancelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamTradeCancelRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradeCancelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index_1 = 3;
  inline bool has_team_index_1() const;
  inline void clear_team_index_1();
  static const int kTeamIndex1FieldNumber = 3;
  inline ::google::protobuf::uint32 team_index_1() const;
  inline void set_team_index_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 4;
  inline bool has_owner_account_id_2() const;
  inline void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 4;
  inline ::google::protobuf::uint32 owner_account_id_2() const;
  inline void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 team_index_2 = 5;
  inline bool has_team_index_2() const;
  inline void clear_team_index_2();
  static const int kTeamIndex2FieldNumber = 5;
  inline ::google::protobuf::uint32 team_index_2() const;
  inline void set_team_index_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamTradeCancelRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index_1();
  inline void clear_has_team_index_1();
  inline void set_has_owner_account_id_2();
  inline void clear_has_owner_account_id_2();
  inline void set_has_team_index_2();
  inline void clear_has_team_index_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  ::google::protobuf::uint32 team_index_2_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamTradeCancelRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradeCancelResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamTradeCancelResponse();
  virtual ~CMsgDOTAFantasyTeamTradeCancelResponse();

  CMsgDOTAFantasyTeamTradeCancelResponse(const CMsgDOTAFantasyTeamTradeCancelResponse& from);

  inline CMsgDOTAFantasyTeamTradeCancelResponse& operator=(const CMsgDOTAFantasyTeamTradeCancelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamTradeCancelResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamTradeCancelResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamTradeCancelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamTradeCancelResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradeCancelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamTradeCancelResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_NO_TRADE = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamTradeCancelResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamTradeCancelResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamTradeCancelResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamTradeCancelResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterRequest();
  virtual ~CMsgDOTAFantasyTeamRosterRequest();

  CMsgDOTAFantasyTeamRosterRequest(const CMsgDOTAFantasyTeamRosterRequest& from);

  inline CMsgDOTAFantasyTeamRosterRequest& operator=(const CMsgDOTAFantasyTeamRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterRequest& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 3;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyTeamRosterResponse();
  virtual ~CMsgDOTAFantasyTeamRosterResponse();

  CMsgDOTAFantasyTeamRosterResponse(const CMsgDOTAFantasyTeamRosterResponse& from);

  inline CMsgDOTAFantasyTeamRosterResponse& operator=(const CMsgDOTAFantasyTeamRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyTeamRosterResponse& default_instance();

  void Swap(CMsgDOTAFantasyTeamRosterResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyTeamRosterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyTeamRosterResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE = CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyTeamRosterResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyTeamRosterResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyTeamRosterResponse_EResult value);

  // repeated uint32 player_account_ids = 2;
  inline int player_account_ids_size() const;
  inline void clear_player_account_ids();
  static const int kPlayerAccountIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 player_account_ids(int index) const;
  inline void set_player_account_ids(int index, ::google::protobuf::uint32 value);
  inline void add_player_account_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_account_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_account_ids();

  // repeated bool player_locked = 3;
  inline int player_locked_size() const;
  inline void clear_player_locked();
  static const int kPlayerLockedFieldNumber = 3;
  inline bool player_locked(int index) const;
  inline void set_player_locked(int index, bool value);
  inline void add_player_locked(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      player_locked() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_player_locked();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyTeamRosterResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_account_ids_;
  ::google::protobuf::RepeatedField< bool > player_locked_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyTeamRosterResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsRequest();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsRequest();

  CMsgDOTAFantasyPlayerHisoricalStatsRequest(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsRequest& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerHisoricalStatsRequest& default_instance();

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerHisoricalStatsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerHisoricalStatsRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerHisoricalStatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& default_instance();

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 matches = 1;
  inline bool has_matches() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline ::google::protobuf::uint32 matches() const;
  inline void set_matches(::google::protobuf::uint32 value);

  // optional float levels = 2;
  inline bool has_levels() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 2;
  inline float levels() const;
  inline void set_levels(float value);

  // optional float kills = 3;
  inline bool has_kills() const;
  inline void clear_kills();
  static const int kKillsFieldNumber = 3;
  inline float kills() const;
  inline void set_kills(float value);

  // optional float deaths = 4;
  inline bool has_deaths() const;
  inline void clear_deaths();
  static const int kDeathsFieldNumber = 4;
  inline float deaths() const;
  inline void set_deaths(float value);

  // optional float assists = 5;
  inline bool has_assists() const;
  inline void clear_assists();
  static const int kAssistsFieldNumber = 5;
  inline float assists() const;
  inline void set_assists(float value);

  // optional float last_hits = 6;
  inline bool has_last_hits() const;
  inline void clear_last_hits();
  static const int kLastHitsFieldNumber = 6;
  inline float last_hits() const;
  inline void set_last_hits(float value);

  // optional float denies = 7;
  inline bool has_denies() const;
  inline void clear_denies();
  static const int kDeniesFieldNumber = 7;
  inline float denies() const;
  inline void set_denies(float value);

  // optional float gpm = 8;
  inline bool has_gpm() const;
  inline void clear_gpm();
  static const int kGpmFieldNumber = 8;
  inline float gpm() const;
  inline void set_gpm(float value);

  // optional float xppm = 9;
  inline bool has_xppm() const;
  inline void clear_xppm();
  static const int kXppmFieldNumber = 9;
  inline float xppm() const;
  inline void set_xppm(float value);

  // optional float stuns = 10;
  inline bool has_stuns() const;
  inline void clear_stuns();
  static const int kStunsFieldNumber = 10;
  inline float stuns() const;
  inline void set_stuns(float value);

  // optional float healing = 11;
  inline bool has_healing() const;
  inline void clear_healing();
  static const int kHealingFieldNumber = 11;
  inline float healing() const;
  inline void set_healing(float value);

  // optional float tower_kills = 12;
  inline bool has_tower_kills() const;
  inline void clear_tower_kills();
  static const int kTowerKillsFieldNumber = 12;
  inline float tower_kills() const;
  inline void set_tower_kills(float value);

  // optional float roshan_kills = 13;
  inline bool has_roshan_kills() const;
  inline void clear_roshan_kills();
  static const int kRoshanKillsFieldNumber = 13;
  inline float roshan_kills() const;
  inline void set_roshan_kills(float value);

  // optional float score = 14;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 14;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator)
 private:
  inline void set_has_matches();
  inline void clear_has_matches();
  inline void set_has_levels();
  inline void clear_has_levels();
  inline void set_has_kills();
  inline void clear_has_kills();
  inline void set_has_deaths();
  inline void clear_has_deaths();
  inline void set_has_assists();
  inline void clear_has_assists();
  inline void set_has_last_hits();
  inline void clear_has_last_hits();
  inline void set_has_denies();
  inline void clear_has_denies();
  inline void set_has_gpm();
  inline void clear_has_gpm();
  inline void set_has_xppm();
  inline void clear_has_xppm();
  inline void set_has_stuns();
  inline void clear_has_stuns();
  inline void set_has_healing();
  inline void clear_has_healing();
  inline void set_has_tower_kills();
  inline void clear_has_tower_kills();
  inline void set_has_roshan_kills();
  inline void clear_has_roshan_kills();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 matches_;
  float levels_;
  float kills_;
  float deaths_;
  float assists_;
  float last_hits_;
  float denies_;
  float gpm_;
  float xppm_;
  float stuns_;
  float healing_;
  float tower_kills_;
  float roshan_kills_;
  float score_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& default_instance();

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 weeks = 2;
  inline bool has_weeks() const;
  inline void clear_weeks();
  static const int kWeeksFieldNumber = 2;
  inline ::google::protobuf::uint32 weeks() const;
  inline void set_weeks(::google::protobuf::uint32 value);

  // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_premium = 4;
  inline bool has_stats_premium() const;
  inline void clear_stats_premium();
  static const int kStatsPremiumFieldNumber = 4;
  inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& stats_premium() const;
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* mutable_stats_premium();
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* release_stats_premium();
  inline void set_allocated_stats_premium(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium);

  // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_professional = 5;
  inline bool has_stats_professional() const;
  inline void clear_stats_professional();
  static const int kStatsProfessionalFieldNumber = 5;
  inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& stats_professional() const;
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* mutable_stats_professional();
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* release_stats_professional();
  inline void set_allocated_stats_professional(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_weeks();
  inline void clear_has_weeks();
  inline void set_has_stats_premium();
  inline void clear_has_stats_premium();
  inline void set_has_stats_professional();
  inline void clear_has_stats_professional();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 weeks_;
  ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium_;
  ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse& default_instance();

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerHisoricalStatsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator PlayerScoreAccumulator;
  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats PlayerStats;

  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value);

  // repeated .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats stats = 2;
  inline int stats_size() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& stats(int index) const;
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* mutable_stats(int index);
  inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* add_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >&
      stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >*
      mutable_stats();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerHisoricalStatsResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats > stats_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerHisoricalStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessageAdd : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyMessageAdd();
  virtual ~CMsgDOTAFantasyMessageAdd();

  CMsgDOTAFantasyMessageAdd(const CMsgDOTAFantasyMessageAdd& from);

  inline CMsgDOTAFantasyMessageAdd& operator=(const CMsgDOTAFantasyMessageAdd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyMessageAdd& default_instance();

  void Swap(CMsgDOTAFantasyMessageAdd* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyMessageAdd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyMessageAdd& from);
  void MergeFrom(const CMsgDOTAFantasyMessageAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyMessageAdd)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyMessageAdd* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyMessagesRequest();
  virtual ~CMsgDOTAFantasyMessagesRequest();

  CMsgDOTAFantasyMessagesRequest(const CMsgDOTAFantasyMessagesRequest& from);

  inline CMsgDOTAFantasyMessagesRequest& operator=(const CMsgDOTAFantasyMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyMessagesRequest& default_instance();

  void Swap(CMsgDOTAFantasyMessagesRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyMessagesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyMessagesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 start_message = 2;
  inline bool has_start_message() const;
  inline void clear_start_message();
  static const int kStartMessageFieldNumber = 2;
  inline ::google::protobuf::uint32 start_message() const;
  inline void set_start_message(::google::protobuf::uint32 value);

  // optional uint32 end_message = 3;
  inline bool has_end_message() const;
  inline void clear_end_message();
  static const int kEndMessageFieldNumber = 3;
  inline ::google::protobuf::uint32 end_message() const;
  inline void set_end_message(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyMessagesRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_start_message();
  inline void clear_has_start_message();
  inline void set_has_end_message();
  inline void clear_has_end_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 start_message_;
  ::google::protobuf::uint32 end_message_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyMessagesRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesResponse_Message : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyMessagesResponse_Message();
  virtual ~CMsgDOTAFantasyMessagesResponse_Message();

  CMsgDOTAFantasyMessagesResponse_Message(const CMsgDOTAFantasyMessagesResponse_Message& from);

  inline CMsgDOTAFantasyMessagesResponse_Message& operator=(const CMsgDOTAFantasyMessagesResponse_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyMessagesResponse_Message& default_instance();

  void Swap(CMsgDOTAFantasyMessagesResponse_Message* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyMessagesResponse_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyMessagesResponse_Message& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesResponse_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 message_id() const;
  inline void set_message_id(::google::protobuf::uint32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional uint32 author_account_id = 3;
  inline bool has_author_account_id() const;
  inline void clear_author_account_id();
  static const int kAuthorAccountIdFieldNumber = 3;
  inline ::google::protobuf::uint32 author_account_id() const;
  inline void set_author_account_id(::google::protobuf::uint32 value);

  // optional uint32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyMessagesResponse.Message)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_author_account_id();
  inline void clear_has_author_account_id();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  ::google::protobuf::uint32 message_id_;
  ::google::protobuf::uint32 author_account_id_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyMessagesResponse_Message* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyMessagesResponse();
  virtual ~CMsgDOTAFantasyMessagesResponse();

  CMsgDOTAFantasyMessagesResponse(const CMsgDOTAFantasyMessagesResponse& from);

  inline CMsgDOTAFantasyMessagesResponse& operator=(const CMsgDOTAFantasyMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyMessagesResponse& default_instance();

  void Swap(CMsgDOTAFantasyMessagesResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyMessagesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyMessagesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyMessagesResponse_Message Message;

  typedef CMsgDOTAFantasyMessagesResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyMessagesResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyMessagesResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyMessagesResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyMessagesResponse_EResult value);

  // repeated .CMsgDOTAFantasyMessagesResponse.Message messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::CMsgDOTAFantasyMessagesResponse_Message& messages(int index) const;
  inline ::CMsgDOTAFantasyMessagesResponse_Message* mutable_messages(int index);
  inline ::CMsgDOTAFantasyMessagesResponse_Message* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyMessagesResponse_Message >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyMessagesResponse_Message >*
      mutable_messages();

  // optional uint32 num_total_messages = 3;
  inline bool has_num_total_messages() const;
  inline void clear_num_total_messages();
  static const int kNumTotalMessagesFieldNumber = 3;
  inline ::google::protobuf::uint32 num_total_messages() const;
  inline void set_num_total_messages(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyMessagesResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_num_total_messages();
  inline void clear_has_num_total_messages();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyMessagesResponse_Message > messages_;
  int result_;
  ::google::protobuf::uint32 num_total_messages_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyMessagesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyRemoveOwner : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyRemoveOwner();
  virtual ~CMsgDOTAFantasyRemoveOwner();

  CMsgDOTAFantasyRemoveOwner(const CMsgDOTAFantasyRemoveOwner& from);

  inline CMsgDOTAFantasyRemoveOwner& operator=(const CMsgDOTAFantasyRemoveOwner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyRemoveOwner& default_instance();

  void Swap(CMsgDOTAFantasyRemoveOwner* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyRemoveOwner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyRemoveOwner& from);
  void MergeFrom(const CMsgDOTAFantasyRemoveOwner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  inline bool has_owner_account_id() const;
  inline void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 owner_account_id() const;
  inline void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 3;
  inline bool has_team_index() const;
  inline void clear_team_index();
  static const int kTeamIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 team_index() const;
  inline void set_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyRemoveOwner)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_owner_account_id();
  inline void clear_has_owner_account_id();
  inline void set_has_team_index();
  inline void clear_has_team_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint32 team_index_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyRemoveOwner* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyRemoveOwnerResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyRemoveOwnerResponse();
  virtual ~CMsgDOTAFantasyRemoveOwnerResponse();

  CMsgDOTAFantasyRemoveOwnerResponse(const CMsgDOTAFantasyRemoveOwnerResponse& from);

  inline CMsgDOTAFantasyRemoveOwnerResponse& operator=(const CMsgDOTAFantasyRemoveOwnerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyRemoveOwnerResponse& default_instance();

  void Swap(CMsgDOTAFantasyRemoveOwnerResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyRemoveOwnerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyRemoveOwnerResponse& from);
  void MergeFrom(const CMsgDOTAFantasyRemoveOwnerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyRemoveOwnerResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_LEAGUE_LOCKED = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_LEAGUE_LOCKED;
  static const EResult ERROR_NOT_A_MEMBER = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyRemoveOwnerResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyRemoveOwnerResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyRemoveOwnerResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyRemoveOwnerResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyRemoveOwnerResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyScheduledMatchesRequest();
  virtual ~CMsgDOTAFantasyScheduledMatchesRequest();

  CMsgDOTAFantasyScheduledMatchesRequest(const CMsgDOTAFantasyScheduledMatchesRequest& from);

  inline CMsgDOTAFantasyScheduledMatchesRequest& operator=(const CMsgDOTAFantasyScheduledMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyScheduledMatchesRequest& default_instance();

  void Swap(CMsgDOTAFantasyScheduledMatchesRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyScheduledMatchesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyScheduledMatchesRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyScheduledMatchesRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays();
  virtual ~CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays();

  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);

  inline CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& operator=(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& default_instance();

  void Swap(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // repeated uint32 team_ids = 2;
  inline int team_ids_size() const;
  inline void clear_team_ids();
  static const int kTeamIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 team_ids(int index) const;
  inline void set_team_ids(int index, ::google::protobuf::uint32 value);
  inline void add_team_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      team_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_team_ids();

  // repeated uint32 league_ids = 3;
  inline int league_ids_size() const;
  inline void clear_league_ids();
  static const int kLeagueIdsFieldNumber = 3;
  inline ::google::protobuf::uint32 league_ids(int index) const;
  inline void set_league_ids(int index, ::google::protobuf::uint32 value);
  inline void add_league_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      league_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_league_ids();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > team_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > league_ids_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyScheduledMatchesResponse();
  virtual ~CMsgDOTAFantasyScheduledMatchesResponse();

  CMsgDOTAFantasyScheduledMatchesResponse(const CMsgDOTAFantasyScheduledMatchesResponse& from);

  inline CMsgDOTAFantasyScheduledMatchesResponse& operator=(const CMsgDOTAFantasyScheduledMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyScheduledMatchesResponse& default_instance();

  void Swap(CMsgDOTAFantasyScheduledMatchesResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyScheduledMatchesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays ScheduledMatchDays;

  typedef CMsgDOTAFantasyScheduledMatchesResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyScheduledMatchesResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyScheduledMatchesResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyScheduledMatchesResponse_EResult value);

  // repeated .CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays scheduled_match_days = 2;
  inline int scheduled_match_days_size() const;
  inline void clear_scheduled_match_days();
  static const int kScheduledMatchDaysFieldNumber = 2;
  inline const ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& scheduled_match_days(int index) const;
  inline ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* mutable_scheduled_match_days(int index);
  inline ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* add_scheduled_match_days();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >&
      scheduled_match_days() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >*
      mutable_scheduled_match_days();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyScheduledMatchesResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays > scheduled_match_days_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyScheduledMatchesResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeaveLeagueRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeaveLeagueRequest();
  virtual ~CMsgDOTAFantasyLeaveLeagueRequest();

  CMsgDOTAFantasyLeaveLeagueRequest(const CMsgDOTAFantasyLeaveLeagueRequest& from);

  inline CMsgDOTAFantasyLeaveLeagueRequest& operator=(const CMsgDOTAFantasyLeaveLeagueRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeaveLeagueRequest& default_instance();

  void Swap(CMsgDOTAFantasyLeaveLeagueRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeaveLeagueRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeaveLeagueRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeaveLeagueRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 2;
  inline bool has_fantasy_team_index() const;
  inline void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 fantasy_team_index() const;
  inline void set_fantasy_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeaveLeagueRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_fantasy_team_index();
  inline void clear_has_fantasy_team_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 fantasy_team_index_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeaveLeagueRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeaveLeagueResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyLeaveLeagueResponse();
  virtual ~CMsgDOTAFantasyLeaveLeagueResponse();

  CMsgDOTAFantasyLeaveLeagueResponse(const CMsgDOTAFantasyLeaveLeagueResponse& from);

  inline CMsgDOTAFantasyLeaveLeagueResponse& operator=(const CMsgDOTAFantasyLeaveLeagueResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyLeaveLeagueResponse& default_instance();

  void Swap(CMsgDOTAFantasyLeaveLeagueResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyLeaveLeagueResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyLeaveLeagueResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeaveLeagueResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeaveLeagueResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NOT_MEMBER = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_NOT_MEMBER;
  static const EResult ERROR_LEAGUE_NOT_FOUND = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_LEAGUE_NOT_FOUND;
  static const EResult ERROR_DRAFT_ACTIVE = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyLeaveLeagueResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyLeaveLeagueResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyLeaveLeagueResponse_EResult value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyLeaveLeagueResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyLeaveLeagueResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsRequest : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsRequest();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsRequest();

  CMsgDOTAFantasyPlayerScoreDetailsRequest(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsRequest& operator=(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerScoreDetailsRequest& default_instance();

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsRequest* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerScoreDetailsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  inline bool has_fantasy_league_id() const;
  inline void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fantasy_league_id() const;
  inline void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 2;
  inline bool has_player_account_id() const;
  inline void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 player_account_id() const;
  inline void set_player_account_id(::google::protobuf::uint32 value);

  // optional uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 4;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerScoreDetailsRequest)
 private:
  inline void set_has_fantasy_league_id();
  inline void clear_has_fantasy_league_id();
  inline void set_has_player_account_id();
  inline void clear_has_player_account_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 player_account_id_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerScoreDetailsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData();

  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& operator=(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& default_instance();

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 match_id = 1;
  inline bool has_match_id() const;
  inline void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  inline ::google::protobuf::uint64 match_id() const;
  inline void set_match_id(::google::protobuf::uint64 value);

  // optional uint32 series_id = 2;
  inline bool has_series_id() const;
  inline void clear_series_id();
  static const int kSeriesIdFieldNumber = 2;
  inline ::google::protobuf::uint32 series_id() const;
  inline void set_series_id(::google::protobuf::uint32 value);

  // optional uint32 series_num = 3;
  inline bool has_series_num() const;
  inline void clear_series_num();
  static const int kSeriesNumFieldNumber = 3;
  inline ::google::protobuf::uint32 series_num() const;
  inline void set_series_num(::google::protobuf::uint32 value);

  // optional uint32 series_type = 4;
  inline bool has_series_type() const;
  inline void clear_series_type();
  static const int kSeriesTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 series_type() const;
  inline void set_series_type(::google::protobuf::uint32 value);

  // optional uint32 league_tier = 5;
  inline bool has_league_tier() const;
  inline void clear_league_tier();
  static const int kLeagueTierFieldNumber = 5;
  inline ::google::protobuf::uint32 league_tier() const;
  inline void set_league_tier(::google::protobuf::uint32 value);

  // optional uint32 league_id = 6;
  inline bool has_league_id() const;
  inline void clear_league_id();
  static const int kLeagueIdFieldNumber = 6;
  inline ::google::protobuf::uint32 league_id() const;
  inline void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 opposing_team_id = 7;
  inline bool has_opposing_team_id() const;
  inline void clear_opposing_team_id();
  static const int kOpposingTeamIdFieldNumber = 7;
  inline ::google::protobuf::uint32 opposing_team_id() const;
  inline void set_opposing_team_id(::google::protobuf::uint32 value);

  // optional uint64 opposing_team_logo = 8;
  inline bool has_opposing_team_logo() const;
  inline void clear_opposing_team_logo();
  static const int kOpposingTeamLogoFieldNumber = 8;
  inline ::google::protobuf::uint64 opposing_team_logo() const;
  inline void set_opposing_team_logo(::google::protobuf::uint64 value);

  // optional string opposing_team_name = 9;
  inline bool has_opposing_team_name() const;
  inline void clear_opposing_team_name();
  static const int kOpposingTeamNameFieldNumber = 9;
  inline const ::std::string& opposing_team_name() const;
  inline void set_opposing_team_name(const ::std::string& value);
  inline void set_opposing_team_name(const char* value);
  inline void set_opposing_team_name(const char* value, size_t size);
  inline ::std::string* mutable_opposing_team_name();
  inline ::std::string* release_opposing_team_name();
  inline void set_allocated_opposing_team_name(::std::string* opposing_team_name);

  // optional uint32 owned_by = 11;
  inline bool has_owned_by() const;
  inline void clear_owned_by();
  static const int kOwnedByFieldNumber = 11;
  inline ::google::protobuf::uint32 owned_by() const;
  inline void set_owned_by(::google::protobuf::uint32 value);

  // optional bool benched = 12;
  inline bool has_benched() const;
  inline void clear_benched();
  static const int kBenchedFieldNumber = 12;
  inline bool benched() const;
  inline void set_benched(bool value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData)
 private:
  inline void set_has_match_id();
  inline void clear_has_match_id();
  inline void set_has_series_id();
  inline void clear_has_series_id();
  inline void set_has_series_num();
  inline void clear_has_series_num();
  inline void set_has_series_type();
  inline void clear_has_series_type();
  inline void set_has_league_tier();
  inline void clear_has_league_tier();
  inline void set_has_league_id();
  inline void clear_has_league_id();
  inline void set_has_opposing_team_id();
  inline void clear_has_opposing_team_id();
  inline void set_has_opposing_team_logo();
  inline void clear_has_opposing_team_logo();
  inline void set_has_opposing_team_name();
  inline void clear_has_opposing_team_name();
  inline void set_has_owned_by();
  inline void clear_has_owned_by();
  inline void set_has_benched();
  inline void clear_has_benched();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 match_id_;
  ::google::protobuf::uint32 series_id_;
  ::google::protobuf::uint32 series_num_;
  ::google::protobuf::uint32 series_type_;
  ::google::protobuf::uint32 league_tier_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 opposing_team_id_;
  ::google::protobuf::uint64 opposing_team_logo_;
  ::std::string* opposing_team_name_;
  ::google::protobuf::uint32 owned_by_;
  bool benched_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsResponse : public ::google::protobuf::Message {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsResponse();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsResponse();

  CMsgDOTAFantasyPlayerScoreDetailsResponse(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse& operator=(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAFantasyPlayerScoreDetailsResponse& default_instance();

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsResponse* other);

  // implements Message ----------------------------------------------

  CMsgDOTAFantasyPlayerScoreDetailsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData PlayerMatchData;

  typedef CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult EResult;
  static const EResult SUCCESS = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NOT_MEMBER = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult result() const;
  inline void set_result(::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value);

  // repeated .CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& data(int index) const;
  inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* mutable_data(int index);
  inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:CMsgDOTAFantasyPlayerScoreDetailsResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData > data_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAFantasyPlayerScoreDetailsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVoteTeamGuess : public ::google::protobuf::Message {
 public:
  CMsgDOTAPassportVoteTeamGuess();
  virtual ~CMsgDOTAPassportVoteTeamGuess();

  CMsgDOTAPassportVoteTeamGuess(const CMsgDOTAPassportVoteTeamGuess& from);

  inline CMsgDOTAPassportVoteTeamGuess& operator=(const CMsgDOTAPassportVoteTeamGuess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAPassportVoteTeamGuess& default_instance();

  void Swap(CMsgDOTAPassportVoteTeamGuess* other);

  // implements Message ----------------------------------------------

  CMsgDOTAPassportVoteTeamGuess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAPassportVoteTeamGuess& from);
  void MergeFrom(const CMsgDOTAPassportVoteTeamGuess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  inline bool has_league_id() const;
  inline void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 league_id() const;
  inline void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 winner_id = 2;
  inline bool has_winner_id() const;
  inline void clear_winner_id();
  static const int kWinnerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 winner_id() const;
  inline void set_winner_id(::google::protobuf::uint32 value);

  // optional uint32 runnerup_id = 3;
  inline bool has_runnerup_id() const;
  inline void clear_runnerup_id();
  static const int kRunnerupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 runnerup_id() const;
  inline void set_runnerup_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAPassportVoteTeamGuess)
 private:
  inline void set_has_league_id();
  inline void clear_has_league_id();
  inline void set_has_winner_id();
  inline void clear_has_winner_id();
  inline void set_has_runnerup_id();
  inline void clear_has_runnerup_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 winner_id_;
  ::google::protobuf::uint32 runnerup_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAPassportVoteTeamGuess* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVoteGenericSelection : public ::google::protobuf::Message {
 public:
  CMsgDOTAPassportVoteGenericSelection();
  virtual ~CMsgDOTAPassportVoteGenericSelection();

  CMsgDOTAPassportVoteGenericSelection(const CMsgDOTAPassportVoteGenericSelection& from);

  inline CMsgDOTAPassportVoteGenericSelection& operator=(const CMsgDOTAPassportVoteGenericSelection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAPassportVoteGenericSelection& default_instance();

  void Swap(CMsgDOTAPassportVoteGenericSelection* other);

  // implements Message ----------------------------------------------

  CMsgDOTAPassportVoteGenericSelection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAPassportVoteGenericSelection& from);
  void MergeFrom(const CMsgDOTAPassportVoteGenericSelection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DOTA_2013PassportSelectionIndices selection_index = 1 [default = PP13_SEL_ALLSTAR_PLAYER_0];
  inline bool has_selection_index() const;
  inline void clear_selection_index();
  static const int kSelectionIndexFieldNumber = 1;
  inline ::DOTA_2013PassportSelectionIndices selection_index() const;
  inline void set_selection_index(::DOTA_2013PassportSelectionIndices value);

  // optional uint32 selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline ::google::protobuf::uint32 selection() const;
  inline void set_selection(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAPassportVoteGenericSelection)
 private:
  inline void set_has_selection_index();
  inline void clear_has_selection_index();
  inline void set_has_selection();
  inline void clear_has_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int selection_index_;
  ::google::protobuf::uint32 selection_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAPassportVoteGenericSelection* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportStampedPlayer : public ::google::protobuf::Message {
 public:
  CMsgDOTAPassportStampedPlayer();
  virtual ~CMsgDOTAPassportStampedPlayer();

  CMsgDOTAPassportStampedPlayer(const CMsgDOTAPassportStampedPlayer& from);

  inline CMsgDOTAPassportStampedPlayer& operator=(const CMsgDOTAPassportStampedPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAPassportStampedPlayer& default_instance();

  void Swap(CMsgDOTAPassportStampedPlayer* other);

  // implements Message ----------------------------------------------

  CMsgDOTAPassportStampedPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAPassportStampedPlayer& from);
  void MergeFrom(const CMsgDOTAPassportStampedPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 steam_id = 1;
  inline bool has_steam_id() const;
  inline void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 steam_id() const;
  inline void set_steam_id(::google::protobuf::uint64 value);

  // optional uint32 stamp_level = 2;
  inline bool has_stamp_level() const;
  inline void clear_stamp_level();
  static const int kStampLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 stamp_level() const;
  inline void set_stamp_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAPassportStampedPlayer)
 private:
  inline void set_has_steam_id();
  inline void clear_has_steam_id();
  inline void set_has_stamp_level();
  inline void clear_has_stamp_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint32 stamp_level_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAPassportStampedPlayer* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportPlayerCardChallenge : public ::google::protobuf::Message {
 public:
  CMsgDOTAPassportPlayerCardChallenge();
  virtual ~CMsgDOTAPassportPlayerCardChallenge();

  CMsgDOTAPassportPlayerCardChallenge(const CMsgDOTAPassportPlayerCardChallenge& from);

  inline CMsgDOTAPassportPlayerCardChallenge& operator=(const CMsgDOTAPassportPlayerCardChallenge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAPassportPlayerCardChallenge& default_instance();

  void Swap(CMsgDOTAPassportPlayerCardChallenge* other);

  // implements Message ----------------------------------------------

  CMsgDOTAPassportPlayerCardChallenge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAPassportPlayerCardChallenge& from);
  void MergeFrom(const CMsgDOTAPassportPlayerCardChallenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 challenge_id = 1;
  inline bool has_challenge_id() const;
  inline void clear_challenge_id();
  static const int kChallengeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 challenge_id() const;
  inline void set_challenge_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgDOTAPassportPlayerCardChallenge)
 private:
  inline void set_has_challenge_id();
  inline void clear_has_challenge_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 challenge_id_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAPassportPlayerCardChallenge* default_instance_;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVote : public ::google::protobuf::Message {
 public:
  CMsgDOTAPassportVote();
  virtual ~CMsgDOTAPassportVote();

  CMsgDOTAPassportVote(const CMsgDOTAPassportVote& from);

  inline CMsgDOTAPassportVote& operator=(const CMsgDOTAPassportVote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgDOTAPassportVote& default_instance();

  void Swap(CMsgDOTAPassportVote* other);

  // implements Message ----------------------------------------------

  CMsgDOTAPassportVote* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgDOTAPassportVote& from);
  void MergeFrom(const CMsgDOTAPassportVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CMsgDOTAPassportVoteTeamGuess team_votes = 1;
  inline int team_votes_size() const;
  inline void clear_team_votes();
  static const int kTeamVotesFieldNumber = 1;
  inline const ::CMsgDOTAPassportVoteTeamGuess& team_votes(int index) const;
  inline ::CMsgDOTAPassportVoteTeamGuess* mutable_team_votes(int index);
  inline ::CMsgDOTAPassportVoteTeamGuess* add_team_votes();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteTeamGuess >&
      team_votes() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteTeamGuess >*
      mutable_team_votes();

  // repeated .CMsgDOTAPassportVoteGenericSelection generic_selections = 2;
  inline int generic_selections_size() const;
  inline void clear_generic_selections();
  static const int kGenericSelectionsFieldNumber = 2;
  inline const ::CMsgDOTAPassportVoteGenericSelection& generic_selections(int index) const;
  inline ::CMsgDOTAPassportVoteGenericSelection* mutable_generic_selections(int index);
  inline ::CMsgDOTAPassportVoteGenericSelection* add_generic_selections();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteGenericSelection >&
      generic_selections() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteGenericSelection >*
      mutable_generic_selections();

  // repeated .CMsgDOTAPassportStampedPlayer stamped_players = 3;
  inline int stamped_players_size() const;
  inline void clear_stamped_players();
  static const int kStampedPlayersFieldNumber = 3;
  inline const ::CMsgDOTAPassportStampedPlayer& stamped_players(int index) const;
  inline ::CMsgDOTAPassportStampedPlayer* mutable_stamped_players(int index);
  inline ::CMsgDOTAPassportStampedPlayer* add_stamped_players();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportStampedPlayer >&
      stamped_players() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportStampedPlayer >*
      mutable_stamped_players();

  // repeated .CMsgDOTAPassportPlayerCardChallenge player_card_challenges = 4;
  inline int player_card_challenges_size() const;
  inline void clear_player_card_challenges();
  static const int kPlayerCardChallengesFieldNumber = 4;
  inline const ::CMsgDOTAPassportPlayerCardChallenge& player_card_challenges(int index) const;
  inline ::CMsgDOTAPassportPlayerCardChallenge* mutable_player_card_challenges(int index);
  inline ::CMsgDOTAPassportPlayerCardChallenge* add_player_card_challenges();
  inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportPlayerCardChallenge >&
      player_card_challenges() const;
  inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportPlayerCardChallenge >*
      mutable_player_card_challenges();

  // @@protoc_insertion_point(class_scope:CMsgDOTAPassportVote)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteTeamGuess > team_votes_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteGenericSelection > generic_selections_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportStampedPlayer > stamped_players_;
  ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportPlayerCardChallenge > player_card_challenges_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgDOTAPassportVote* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientToGCGetPlayerCardRosterRequest : public ::google::protobuf::Message {
 public:
  CMsgClientToGCGetPlayerCardRosterRequest();
  virtual ~CMsgClientToGCGetPlayerCardRosterRequest();

  CMsgClientToGCGetPlayerCardRosterRequest(const CMsgClientToGCGetPlayerCardRosterRequest& from);

  inline CMsgClientToGCGetPlayerCardRosterRequest& operator=(const CMsgClientToGCGetPlayerCardRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientToGCGetPlayerCardRosterRequest& default_instance();

  void Swap(CMsgClientToGCGetPlayerCardRosterRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientToGCGetPlayerCardRosterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientToGCGetPlayerCardRosterRequest& from);
  void MergeFrom(const CMsgClientToGCGetPlayerCardRosterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  inline bool has_league_id() const;
  inline void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 league_id() const;
  inline void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientToGCGetPlayerCardRosterRequest)
 private:
  inline void set_has_league_id();
  inline void clear_has_league_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientToGCGetPlayerCardRosterRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientToGCGetPlayerCardRosterResponse : public ::google::protobuf::Message {
 public:
  CMsgClientToGCGetPlayerCardRosterResponse();
  virtual ~CMsgClientToGCGetPlayerCardRosterResponse();

  CMsgClientToGCGetPlayerCardRosterResponse(const CMsgClientToGCGetPlayerCardRosterResponse& from);

  inline CMsgClientToGCGetPlayerCardRosterResponse& operator=(const CMsgClientToGCGetPlayerCardRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientToGCGetPlayerCardRosterResponse& default_instance();

  void Swap(CMsgClientToGCGetPlayerCardRosterResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientToGCGetPlayerCardRosterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientToGCGetPlayerCardRosterResponse& from);
  void MergeFrom(const CMsgClientToGCGetPlayerCardRosterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCGetPlayerCardRosterResponse_Result Result;
  static const Result SUCCESS = CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS;
  static const Result ERROR_UNSPECIFIED = CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED;
  static const Result ERROR_INVALID_LEAGUE_ID = CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID;
  static const Result ERROR_INVALID_TIMESTAMP = CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
  static inline bool Result_IsValid(int value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgClientToGCGetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgClientToGCGetPlayerCardRosterResponse_Result result() const;
  inline void set_result(::CMsgClientToGCGetPlayerCardRosterResponse_Result value);

  // repeated uint64 player_card_item_id = 2;
  inline int player_card_item_id_size() const;
  inline void clear_player_card_item_id();
  static const int kPlayerCardItemIdFieldNumber = 2;
  inline ::google::protobuf::uint64 player_card_item_id(int index) const;
  inline void set_player_card_item_id(int index, ::google::protobuf::uint64 value);
  inline void add_player_card_item_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      player_card_item_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_player_card_item_id();

  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // optional bool finalized = 4;
  inline bool has_finalized() const;
  inline void clear_finalized();
  static const int kFinalizedFieldNumber = 4;
  inline bool finalized() const;
  inline void set_finalized(bool value);

  // optional float percentile = 5;
  inline bool has_percentile() const;
  inline void clear_percentile();
  static const int kPercentileFieldNumber = 5;
  inline float percentile() const;
  inline void set_percentile(float value);

  // @@protoc_insertion_point(class_scope:CMsgClientToGCGetPlayerCardRosterResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_finalized();
  inline void clear_has_finalized();
  inline void set_has_percentile();
  inline void clear_has_percentile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > player_card_item_id_;
  int result_;
  float score_;
  bool finalized_;
  float percentile_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientToGCGetPlayerCardRosterResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientToGCSetPlayerCardRosterRequest : public ::google::protobuf::Message {
 public:
  CMsgClientToGCSetPlayerCardRosterRequest();
  virtual ~CMsgClientToGCSetPlayerCardRosterRequest();

  CMsgClientToGCSetPlayerCardRosterRequest(const CMsgClientToGCSetPlayerCardRosterRequest& from);

  inline CMsgClientToGCSetPlayerCardRosterRequest& operator=(const CMsgClientToGCSetPlayerCardRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientToGCSetPlayerCardRosterRequest& default_instance();

  void Swap(CMsgClientToGCSetPlayerCardRosterRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientToGCSetPlayerCardRosterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientToGCSetPlayerCardRosterRequest& from);
  void MergeFrom(const CMsgClientToGCSetPlayerCardRosterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  inline bool has_league_id() const;
  inline void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 league_id() const;
  inline void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 slot = 3;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 3;
  inline ::google::protobuf::uint32 slot() const;
  inline void set_slot(::google::protobuf::uint32 value);

  // optional uint64 player_card_item_id = 4;
  inline bool has_player_card_item_id() const;
  inline void clear_player_card_item_id();
  static const int kPlayerCardItemIdFieldNumber = 4;
  inline ::google::protobuf::uint64 player_card_item_id() const;
  inline void set_player_card_item_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientToGCSetPlayerCardRosterRequest)
 private:
  inline void set_has_league_id();
  inline void clear_has_league_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_player_card_item_id();
  inline void clear_has_player_card_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint64 player_card_item_id_;
  ::google::protobuf::uint32 slot_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientToGCSetPlayerCardRosterRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientToGCSetPlayerCardRosterResponse : public ::google::protobuf::Message {
 public:
  CMsgClientToGCSetPlayerCardRosterResponse();
  virtual ~CMsgClientToGCSetPlayerCardRosterResponse();

  CMsgClientToGCSetPlayerCardRosterResponse(const CMsgClientToGCSetPlayerCardRosterResponse& from);

  inline CMsgClientToGCSetPlayerCardRosterResponse& operator=(const CMsgClientToGCSetPlayerCardRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientToGCSetPlayerCardRosterResponse& default_instance();

  void Swap(CMsgClientToGCSetPlayerCardRosterResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientToGCSetPlayerCardRosterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientToGCSetPlayerCardRosterResponse& from);
  void MergeFrom(const CMsgClientToGCSetPlayerCardRosterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCSetPlayerCardRosterResponse_Result Result;
  static const Result SUCCESS = CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS;
  static const Result ERROR_UNSPECIFIED = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED;
  static const Result ERROR_INVALID_LEAGUE_ID = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID;
  static const Result ERROR_INVALID_TIMESTAMP = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
  static const Result ERROR_PLAYER_CARD_NOT_OWNED = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_PLAYER_CARD_NOT_OWNED;
  static const Result ERROR_INVALID_SLOT = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_SLOT;
  static const Result ERROR_FAILED_CARD_INFO = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_FAILED_CARD_INFO;
  static const Result ERROR_ACCOUNT_DUPLICATE = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_ACCOUNT_DUPLICATE;
  static const Result ERROR_LOCKED_TIMESTAMP = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP;
  static inline bool Result_IsValid(int value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CMsgClientToGCSetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CMsgClientToGCSetPlayerCardRosterResponse_Result result() const;
  inline void set_result(::CMsgClientToGCSetPlayerCardRosterResponse_Result value);

  // @@protoc_insertion_point(class_scope:CMsgClientToGCSetPlayerCardRosterResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_AssignDesc_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
  friend void protobuf_ShutdownFile_dota_5fgcmessages_5fclient_5ffantasy_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientToGCSetPlayerCardRosterResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// CMsgGCPlayerInfo_PlayerInfo

// optional uint32 account_id = 1;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_PlayerInfo::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.account_id)
  return account_id_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.account_id)
}

// optional string name = 2;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMsgGCPlayerInfo_PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.name)
  return *name_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.name)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGCPlayerInfo.PlayerInfo.name)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGCPlayerInfo.PlayerInfo.name)
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.PlayerInfo.name)
  return name_;
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgGCPlayerInfo.PlayerInfo.name)
}

// optional string country_code = 3;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_country_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_country_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_country_code() {
  if (country_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_code_->clear();
  }
  clear_has_country_code();
}
inline const ::std::string& CMsgGCPlayerInfo_PlayerInfo::country_code() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.country_code)
  return *country_code_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_country_code(const ::std::string& value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.country_code)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_country_code(const char* value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGCPlayerInfo.PlayerInfo.country_code)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_country_code(const char* value, size_t size) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGCPlayerInfo.PlayerInfo.country_code)
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::mutable_country_code() {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.PlayerInfo.country_code)
  return country_code_;
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::release_country_code() {
  clear_has_country_code();
  if (country_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_code_;
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_allocated_country_code(::std::string* country_code) {
  if (country_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_code_;
  }
  if (country_code) {
    set_has_country_code();
    country_code_ = country_code;
  } else {
    clear_has_country_code();
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgGCPlayerInfo.PlayerInfo.country_code)
}

// optional uint32 fantasy_role = 4;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_fantasy_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_fantasy_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_fantasy_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_fantasy_role() {
  fantasy_role_ = 0u;
  clear_has_fantasy_role();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_PlayerInfo::fantasy_role() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.fantasy_role)
  return fantasy_role_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_fantasy_role(::google::protobuf::uint32 value) {
  set_has_fantasy_role();
  fantasy_role_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.fantasy_role)
}

// optional uint32 team_id = 5;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_team_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_team_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_team_id() {
  team_id_ = 0u;
  clear_has_team_id();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_PlayerInfo::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.team_id)
  return team_id_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_id(::google::protobuf::uint32 value) {
  set_has_team_id();
  team_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.team_id)
}

// optional string team_name = 6;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_team_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_team_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& CMsgGCPlayerInfo_PlayerInfo::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.team_name)
  return *team_name_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.team_name)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGCPlayerInfo.PlayerInfo.team_name)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGCPlayerInfo.PlayerInfo.team_name)
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.PlayerInfo.team_name)
  return team_name_;
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgGCPlayerInfo.PlayerInfo.team_name)
}

// optional string team_tag = 7;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_team_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_team_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_team_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_team_tag() {
  if (team_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_tag_->clear();
  }
  clear_has_team_tag();
}
inline const ::std::string& CMsgGCPlayerInfo_PlayerInfo::team_tag() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.team_tag)
  return *team_tag_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_tag(const ::std::string& value) {
  set_has_team_tag();
  if (team_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_tag_ = new ::std::string;
  }
  team_tag_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.team_tag)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_tag(const char* value) {
  set_has_team_tag();
  if (team_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_tag_ = new ::std::string;
  }
  team_tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGCPlayerInfo.PlayerInfo.team_tag)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_team_tag(const char* value, size_t size) {
  set_has_team_tag();
  if (team_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_tag_ = new ::std::string;
  }
  team_tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGCPlayerInfo.PlayerInfo.team_tag)
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::mutable_team_tag() {
  set_has_team_tag();
  if (team_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.PlayerInfo.team_tag)
  return team_tag_;
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::release_team_tag() {
  clear_has_team_tag();
  if (team_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_tag_;
    team_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_allocated_team_tag(::std::string* team_tag) {
  if (team_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_tag_;
  }
  if (team_tag) {
    set_has_team_tag();
    team_tag_ = team_tag;
  } else {
    clear_has_team_tag();
    team_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgGCPlayerInfo.PlayerInfo.team_tag)
}

// optional string sponsor = 8;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_sponsor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_sponsor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_sponsor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_sponsor() {
  if (sponsor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sponsor_->clear();
  }
  clear_has_sponsor();
}
inline const ::std::string& CMsgGCPlayerInfo_PlayerInfo::sponsor() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.sponsor)
  return *sponsor_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_sponsor(const ::std::string& value) {
  set_has_sponsor();
  if (sponsor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sponsor_ = new ::std::string;
  }
  sponsor_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.sponsor)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_sponsor(const char* value) {
  set_has_sponsor();
  if (sponsor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sponsor_ = new ::std::string;
  }
  sponsor_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGCPlayerInfo.PlayerInfo.sponsor)
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_sponsor(const char* value, size_t size) {
  set_has_sponsor();
  if (sponsor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sponsor_ = new ::std::string;
  }
  sponsor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGCPlayerInfo.PlayerInfo.sponsor)
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::mutable_sponsor() {
  set_has_sponsor();
  if (sponsor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sponsor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.PlayerInfo.sponsor)
  return sponsor_;
}
inline ::std::string* CMsgGCPlayerInfo_PlayerInfo::release_sponsor() {
  clear_has_sponsor();
  if (sponsor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sponsor_;
    sponsor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_allocated_sponsor(::std::string* sponsor) {
  if (sponsor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sponsor_;
  }
  if (sponsor) {
    set_has_sponsor();
    sponsor_ = sponsor;
  } else {
    clear_has_sponsor();
    sponsor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgGCPlayerInfo.PlayerInfo.sponsor)
}

// optional bool is_locked = 9;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_is_locked() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_is_locked() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_is_locked() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_is_locked() {
  is_locked_ = false;
  clear_has_is_locked();
}
inline bool CMsgGCPlayerInfo_PlayerInfo::is_locked() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.is_locked)
  return is_locked_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_is_locked(bool value) {
  set_has_is_locked();
  is_locked_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.is_locked)
}

// optional bool is_pro = 10;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_is_pro() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_is_pro() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_is_pro() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_is_pro() {
  is_pro_ = false;
  clear_has_is_pro();
}
inline bool CMsgGCPlayerInfo_PlayerInfo::is_pro() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.is_pro)
  return is_pro_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_is_pro(bool value) {
  set_has_is_pro();
  is_pro_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.is_pro)
}

// optional uint32 locked_until = 11;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_locked_until() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_locked_until() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_locked_until() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_locked_until() {
  locked_until_ = 0u;
  clear_has_locked_until();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_PlayerInfo::locked_until() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.locked_until)
  return locked_until_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_locked_until(::google::protobuf::uint32 value) {
  set_has_locked_until();
  locked_until_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.locked_until)
}

// optional uint32 timestamp = 12;
inline bool CMsgGCPlayerInfo_PlayerInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgGCPlayerInfo_PlayerInfo::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_PlayerInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.PlayerInfo.timestamp)
  return timestamp_;
}
inline void CMsgGCPlayerInfo_PlayerInfo::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.PlayerInfo.timestamp)
}

// -------------------------------------------------------------------

// CMsgGCPlayerInfo_RegionLeaderboard

// optional uint32 division = 1;
inline bool CMsgGCPlayerInfo_RegionLeaderboard::has_division() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::set_has_division() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::clear_has_division() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::clear_division() {
  division_ = 0u;
  clear_has_division();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_RegionLeaderboard::division() const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.RegionLeaderboard.division)
  return division_;
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::set_division(::google::protobuf::uint32 value) {
  set_has_division();
  division_ = value;
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.RegionLeaderboard.division)
}

// repeated uint32 account_ids = 2;
inline int CMsgGCPlayerInfo_RegionLeaderboard::account_ids_size() const {
  return account_ids_.size();
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::clear_account_ids() {
  account_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgGCPlayerInfo_RegionLeaderboard::account_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.RegionLeaderboard.account_ids)
  return account_ids_.Get(index);
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::set_account_ids(int index, ::google::protobuf::uint32 value) {
  account_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgGCPlayerInfo.RegionLeaderboard.account_ids)
}
inline void CMsgGCPlayerInfo_RegionLeaderboard::add_account_ids(::google::protobuf::uint32 value) {
  account_ids_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgGCPlayerInfo.RegionLeaderboard.account_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgGCPlayerInfo_RegionLeaderboard::account_ids() const {
  // @@protoc_insertion_point(field_list:CMsgGCPlayerInfo.RegionLeaderboard.account_ids)
  return account_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgGCPlayerInfo_RegionLeaderboard::mutable_account_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGCPlayerInfo.RegionLeaderboard.account_ids)
  return &account_ids_;
}

// -------------------------------------------------------------------

// CMsgGCPlayerInfo

// repeated .CMsgGCPlayerInfo.PlayerInfo player_infos = 1;
inline int CMsgGCPlayerInfo::player_infos_size() const {
  return player_infos_.size();
}
inline void CMsgGCPlayerInfo::clear_player_infos() {
  player_infos_.Clear();
}
inline const ::CMsgGCPlayerInfo_PlayerInfo& CMsgGCPlayerInfo::player_infos(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.player_infos)
  return player_infos_.Get(index);
}
inline ::CMsgGCPlayerInfo_PlayerInfo* CMsgGCPlayerInfo::mutable_player_infos(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.player_infos)
  return player_infos_.Mutable(index);
}
inline ::CMsgGCPlayerInfo_PlayerInfo* CMsgGCPlayerInfo::add_player_infos() {
  // @@protoc_insertion_point(field_add:CMsgGCPlayerInfo.player_infos)
  return player_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_PlayerInfo >&
CMsgGCPlayerInfo::player_infos() const {
  // @@protoc_insertion_point(field_list:CMsgGCPlayerInfo.player_infos)
  return player_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_PlayerInfo >*
CMsgGCPlayerInfo::mutable_player_infos() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGCPlayerInfo.player_infos)
  return &player_infos_;
}

// repeated .CMsgGCPlayerInfo.RegionLeaderboard leaderboards = 2;
inline int CMsgGCPlayerInfo::leaderboards_size() const {
  return leaderboards_.size();
}
inline void CMsgGCPlayerInfo::clear_leaderboards() {
  leaderboards_.Clear();
}
inline const ::CMsgGCPlayerInfo_RegionLeaderboard& CMsgGCPlayerInfo::leaderboards(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGCPlayerInfo.leaderboards)
  return leaderboards_.Get(index);
}
inline ::CMsgGCPlayerInfo_RegionLeaderboard* CMsgGCPlayerInfo::mutable_leaderboards(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGCPlayerInfo.leaderboards)
  return leaderboards_.Mutable(index);
}
inline ::CMsgGCPlayerInfo_RegionLeaderboard* CMsgGCPlayerInfo::add_leaderboards() {
  // @@protoc_insertion_point(field_add:CMsgGCPlayerInfo.leaderboards)
  return leaderboards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_RegionLeaderboard >&
CMsgGCPlayerInfo::leaderboards() const {
  // @@protoc_insertion_point(field_list:CMsgGCPlayerInfo.leaderboards)
  return leaderboards_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgGCPlayerInfo_RegionLeaderboard >*
CMsgGCPlayerInfo::mutable_leaderboards() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGCPlayerInfo.leaderboards)
  return &leaderboards_;
}

// -------------------------------------------------------------------

// CMsgDOTACreateFantasyLeagueRequest

// optional string league_name = 1;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_has_league_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_has_league_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_league_name() {
  if (league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    league_name_->clear();
  }
  clear_has_league_name();
}
inline const ::std::string& CMsgDOTACreateFantasyLeagueRequest::league_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateFantasyLeagueRequest.league_name)
  return *league_name_;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const ::std::string& value) {
  set_has_league_name();
  if (league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    league_name_ = new ::std::string;
  }
  league_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateFantasyLeagueRequest.league_name)
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const char* value) {
  set_has_league_name();
  if (league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    league_name_ = new ::std::string;
  }
  league_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTACreateFantasyLeagueRequest.league_name)
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const char* value, size_t size) {
  set_has_league_name();
  if (league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    league_name_ = new ::std::string;
  }
  league_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTACreateFantasyLeagueRequest.league_name)
}
inline ::std::string* CMsgDOTACreateFantasyLeagueRequest::mutable_league_name() {
  set_has_league_name();
  if (league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    league_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateFantasyLeagueRequest.league_name)
  return league_name_;
}
inline ::std::string* CMsgDOTACreateFantasyLeagueRequest::release_league_name() {
  clear_has_league_name();
  if (league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = league_name_;
    league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_allocated_league_name(::std::string* league_name) {
  if (league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete league_name_;
  }
  if (league_name) {
    set_has_league_name();
    league_name_ = league_name;
  } else {
    clear_has_league_name();
    league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateFantasyLeagueRequest.league_name)
}

// optional uint64 league_logo = 2;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_league_logo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_has_league_logo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_has_league_logo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_league_logo() {
  league_logo_ = GOOGLE_ULONGLONG(0);
  clear_has_league_logo();
}
inline ::google::protobuf::uint64 CMsgDOTACreateFantasyLeagueRequest::league_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateFantasyLeagueRequest.league_logo)
  return league_logo_;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_logo(::google::protobuf::uint64 value) {
  set_has_league_logo();
  league_logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTACreateFantasyLeagueRequest.league_logo)
}

// optional .Fantasy_Selection_Mode selection_mode = 3 [default = FANTASY_SELECTION_INVALID];
inline bool CMsgDOTACreateFantasyLeagueRequest::has_selection_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_has_selection_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_has_selection_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_selection_mode() {
  selection_mode_ = 0;
  clear_has_selection_mode();
}
inline ::Fantasy_Selection_Mode CMsgDOTACreateFantasyLeagueRequest::selection_mode() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateFantasyLeagueRequest.selection_mode)
  return static_cast< ::Fantasy_Selection_Mode >(selection_mode_);
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_selection_mode(::Fantasy_Selection_Mode value) {
  assert(::Fantasy_Selection_Mode_IsValid(value));
  set_has_selection_mode();
  selection_mode_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTACreateFantasyLeagueRequest.selection_mode)
}

// optional uint32 team_count = 4;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_team_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_has_team_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_has_team_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_team_count() {
  team_count_ = 0u;
  clear_has_team_count();
}
inline ::google::protobuf::uint32 CMsgDOTACreateFantasyLeagueRequest::team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateFantasyLeagueRequest.team_count)
  return team_count_;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_team_count(::google::protobuf::uint32 value) {
  set_has_team_count();
  team_count_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTACreateFantasyLeagueRequest.team_count)
}

// -------------------------------------------------------------------

// CMsgDOTACreateFantasyLeagueResponse

// optional .CMsgDOTACreateFantasyLeagueResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTACreateFantasyLeagueResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTACreateFantasyLeagueResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTACreateFantasyLeagueResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateFantasyLeagueResponse.result)
  return static_cast< ::CMsgDOTACreateFantasyLeagueResponse_EResult >(result_);
}
inline void CMsgDOTACreateFantasyLeagueResponse::set_result(::CMsgDOTACreateFantasyLeagueResponse_EResult value) {
  assert(::CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTACreateFantasyLeagueResponse.result)
}

// -------------------------------------------------------------------

// CMsgFantasyLeagueScoring

// optional float level = 1;
inline bool CMsgFantasyLeagueScoring::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgFantasyLeagueScoring::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgFantasyLeagueScoring::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline float CMsgFantasyLeagueScoring::level() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.level)
  return level_;
}
inline void CMsgFantasyLeagueScoring::set_level(float value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.level)
}

// optional float kills = 2;
inline bool CMsgFantasyLeagueScoring::has_kills() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_kills() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgFantasyLeagueScoring::clear_has_kills() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgFantasyLeagueScoring::clear_kills() {
  kills_ = 0;
  clear_has_kills();
}
inline float CMsgFantasyLeagueScoring::kills() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.kills)
  return kills_;
}
inline void CMsgFantasyLeagueScoring::set_kills(float value) {
  set_has_kills();
  kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.kills)
}

// optional float deaths = 3;
inline bool CMsgFantasyLeagueScoring::has_deaths() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_deaths() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgFantasyLeagueScoring::clear_has_deaths() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgFantasyLeagueScoring::clear_deaths() {
  deaths_ = 0;
  clear_has_deaths();
}
inline float CMsgFantasyLeagueScoring::deaths() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.deaths)
  return deaths_;
}
inline void CMsgFantasyLeagueScoring::set_deaths(float value) {
  set_has_deaths();
  deaths_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.deaths)
}

// optional float assists = 4;
inline bool CMsgFantasyLeagueScoring::has_assists() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_assists() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgFantasyLeagueScoring::clear_has_assists() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgFantasyLeagueScoring::clear_assists() {
  assists_ = 0;
  clear_has_assists();
}
inline float CMsgFantasyLeagueScoring::assists() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.assists)
  return assists_;
}
inline void CMsgFantasyLeagueScoring::set_assists(float value) {
  set_has_assists();
  assists_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.assists)
}

// optional float last_hits = 5;
inline bool CMsgFantasyLeagueScoring::has_last_hits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_last_hits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgFantasyLeagueScoring::clear_has_last_hits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgFantasyLeagueScoring::clear_last_hits() {
  last_hits_ = 0;
  clear_has_last_hits();
}
inline float CMsgFantasyLeagueScoring::last_hits() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.last_hits)
  return last_hits_;
}
inline void CMsgFantasyLeagueScoring::set_last_hits(float value) {
  set_has_last_hits();
  last_hits_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.last_hits)
}

// optional float denies = 6;
inline bool CMsgFantasyLeagueScoring::has_denies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_denies() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgFantasyLeagueScoring::clear_has_denies() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgFantasyLeagueScoring::clear_denies() {
  denies_ = 0;
  clear_has_denies();
}
inline float CMsgFantasyLeagueScoring::denies() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.denies)
  return denies_;
}
inline void CMsgFantasyLeagueScoring::set_denies(float value) {
  set_has_denies();
  denies_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.denies)
}

// optional float gpm = 7;
inline bool CMsgFantasyLeagueScoring::has_gpm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_gpm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgFantasyLeagueScoring::clear_has_gpm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgFantasyLeagueScoring::clear_gpm() {
  gpm_ = 0;
  clear_has_gpm();
}
inline float CMsgFantasyLeagueScoring::gpm() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.gpm)
  return gpm_;
}
inline void CMsgFantasyLeagueScoring::set_gpm(float value) {
  set_has_gpm();
  gpm_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.gpm)
}

// optional float xppm = 8;
inline bool CMsgFantasyLeagueScoring::has_xppm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_xppm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgFantasyLeagueScoring::clear_has_xppm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgFantasyLeagueScoring::clear_xppm() {
  xppm_ = 0;
  clear_has_xppm();
}
inline float CMsgFantasyLeagueScoring::xppm() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.xppm)
  return xppm_;
}
inline void CMsgFantasyLeagueScoring::set_xppm(float value) {
  set_has_xppm();
  xppm_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.xppm)
}

// optional float stuns = 9;
inline bool CMsgFantasyLeagueScoring::has_stuns() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_stuns() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgFantasyLeagueScoring::clear_has_stuns() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgFantasyLeagueScoring::clear_stuns() {
  stuns_ = 0;
  clear_has_stuns();
}
inline float CMsgFantasyLeagueScoring::stuns() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.stuns)
  return stuns_;
}
inline void CMsgFantasyLeagueScoring::set_stuns(float value) {
  set_has_stuns();
  stuns_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.stuns)
}

// optional float healing = 10;
inline bool CMsgFantasyLeagueScoring::has_healing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_healing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgFantasyLeagueScoring::clear_has_healing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgFantasyLeagueScoring::clear_healing() {
  healing_ = 0;
  clear_has_healing();
}
inline float CMsgFantasyLeagueScoring::healing() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.healing)
  return healing_;
}
inline void CMsgFantasyLeagueScoring::set_healing(float value) {
  set_has_healing();
  healing_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.healing)
}

// optional float tower_kills = 11;
inline bool CMsgFantasyLeagueScoring::has_tower_kills() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_tower_kills() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgFantasyLeagueScoring::clear_has_tower_kills() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgFantasyLeagueScoring::clear_tower_kills() {
  tower_kills_ = 0;
  clear_has_tower_kills();
}
inline float CMsgFantasyLeagueScoring::tower_kills() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.tower_kills)
  return tower_kills_;
}
inline void CMsgFantasyLeagueScoring::set_tower_kills(float value) {
  set_has_tower_kills();
  tower_kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.tower_kills)
}

// optional float roshan_kills = 12;
inline bool CMsgFantasyLeagueScoring::has_roshan_kills() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_roshan_kills() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgFantasyLeagueScoring::clear_has_roshan_kills() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgFantasyLeagueScoring::clear_roshan_kills() {
  roshan_kills_ = 0;
  clear_has_roshan_kills();
}
inline float CMsgFantasyLeagueScoring::roshan_kills() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.roshan_kills)
  return roshan_kills_;
}
inline void CMsgFantasyLeagueScoring::set_roshan_kills(float value) {
  set_has_roshan_kills();
  roshan_kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.roshan_kills)
}

// optional float multiplier_premium = 13;
inline bool CMsgFantasyLeagueScoring::has_multiplier_premium() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_multiplier_premium() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgFantasyLeagueScoring::clear_has_multiplier_premium() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgFantasyLeagueScoring::clear_multiplier_premium() {
  multiplier_premium_ = 0;
  clear_has_multiplier_premium();
}
inline float CMsgFantasyLeagueScoring::multiplier_premium() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.multiplier_premium)
  return multiplier_premium_;
}
inline void CMsgFantasyLeagueScoring::set_multiplier_premium(float value) {
  set_has_multiplier_premium();
  multiplier_premium_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.multiplier_premium)
}

// optional float multiplier_professional = 14;
inline bool CMsgFantasyLeagueScoring::has_multiplier_professional() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgFantasyLeagueScoring::set_has_multiplier_professional() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgFantasyLeagueScoring::clear_has_multiplier_professional() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgFantasyLeagueScoring::clear_multiplier_professional() {
  multiplier_professional_ = 0;
  clear_has_multiplier_professional();
}
inline float CMsgFantasyLeagueScoring::multiplier_professional() const {
  // @@protoc_insertion_point(field_get:CMsgFantasyLeagueScoring.multiplier_professional)
  return multiplier_professional_;
}
inline void CMsgFantasyLeagueScoring::set_multiplier_professional(float value) {
  set_has_multiplier_professional();
  multiplier_professional_ = value;
  // @@protoc_insertion_point(field_set:CMsgFantasyLeagueScoring.multiplier_professional)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfo_OwnerInfo

// optional uint32 owner_account_id = 1;
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo_OwnerInfo::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.OwnerInfo.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.OwnerInfo.owner_account_id)
}

// optional bool left_league = 2;
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::has_left_league() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_has_left_league() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_has_left_league() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_left_league() {
  left_league_ = false;
  clear_has_left_league();
}
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::left_league() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.OwnerInfo.left_league)
  return left_league_;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_left_league(bool value) {
  set_has_left_league();
  left_league_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.OwnerInfo.left_league)
}

// repeated uint32 player_account_id = 3;
inline int CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id_size() const {
  return player_account_id_.size();
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_player_account_id() {
  player_account_id_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return player_account_id_.Get(index);
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_player_account_id(int index, ::google::protobuf::uint32 value) {
  player_account_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::add_player_account_id(::google::protobuf::uint32 value) {
  player_account_id_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return player_account_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueInfo_OwnerInfo::mutable_player_account_id() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return &player_account_id_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfo

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueInfo::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.fantasy_league_id)
}

// optional uint32 commissioner_account_id = 2;
inline bool CMsgDOTAFantasyLeagueInfo::has_commissioner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_commissioner_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_commissioner_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_commissioner_account_id() {
  commissioner_account_id_ = 0u;
  clear_has_commissioner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::commissioner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.commissioner_account_id)
  return commissioner_account_id_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_commissioner_account_id(::google::protobuf::uint32 value) {
  set_has_commissioner_account_id();
  commissioner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.commissioner_account_id)
}

// optional string fantasy_league_name = 3;
inline bool CMsgDOTAFantasyLeagueInfo::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_fantasy_league_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_fantasy_league_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_fantasy_league_name() {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_->clear();
  }
  clear_has_fantasy_league_name();
}
inline const ::std::string& CMsgDOTAFantasyLeagueInfo::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
  return *fantasy_league_name_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const ::std::string& value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const char* value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const char* value, size_t size) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::mutable_fantasy_league_name() {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
  return fantasy_league_name_;
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::release_fantasy_league_name() {
  clear_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_league_name_;
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fantasy_league_name_;
  }
  if (fantasy_league_name) {
    set_has_fantasy_league_name();
    fantasy_league_name_ = fantasy_league_name;
  } else {
    clear_has_fantasy_league_name();
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}

// optional .Fantasy_Selection_Mode selection_mode = 4 [default = FANTASY_SELECTION_INVALID];
inline bool CMsgDOTAFantasyLeagueInfo::has_selection_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_selection_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_selection_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_selection_mode() {
  selection_mode_ = 0;
  clear_has_selection_mode();
}
inline ::Fantasy_Selection_Mode CMsgDOTAFantasyLeagueInfo::selection_mode() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.selection_mode)
  return static_cast< ::Fantasy_Selection_Mode >(selection_mode_);
}
inline void CMsgDOTAFantasyLeagueInfo::set_selection_mode(::Fantasy_Selection_Mode value) {
  assert(::Fantasy_Selection_Mode_IsValid(value));
  set_has_selection_mode();
  selection_mode_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.selection_mode)
}

// optional uint32 team_count = 5;
inline bool CMsgDOTAFantasyLeagueInfo::has_team_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_team_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_team_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_team_count() {
  team_count_ = 0u;
  clear_has_team_count();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.team_count)
  return team_count_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_team_count(::google::protobuf::uint32 value) {
  set_has_team_count();
  team_count_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.team_count)
}

// optional uint64 logo = 6;
inline bool CMsgDOTAFantasyLeagueInfo::has_logo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_logo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_logo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_logo() {
  logo_ = GOOGLE_ULONGLONG(0);
  clear_has_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueInfo::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.logo)
  return logo_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_logo(::google::protobuf::uint64 value) {
  set_has_logo();
  logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.logo)
}

// optional .CMsgFantasyLeagueScoring scoring = 7;
inline bool CMsgDOTAFantasyLeagueInfo::has_scoring() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_scoring() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_scoring() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_scoring() {
  if (scoring_ != NULL) scoring_->::CMsgFantasyLeagueScoring::Clear();
  clear_has_scoring();
}
inline const ::CMsgFantasyLeagueScoring& CMsgDOTAFantasyLeagueInfo::scoring() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.scoring)
  return scoring_ != NULL ? *scoring_ : *default_instance_->scoring_;
}
inline ::CMsgFantasyLeagueScoring* CMsgDOTAFantasyLeagueInfo::mutable_scoring() {
  set_has_scoring();
  if (scoring_ == NULL) scoring_ = new ::CMsgFantasyLeagueScoring;
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueInfo.scoring)
  return scoring_;
}
inline ::CMsgFantasyLeagueScoring* CMsgDOTAFantasyLeagueInfo::release_scoring() {
  clear_has_scoring();
  ::CMsgFantasyLeagueScoring* temp = scoring_;
  scoring_ = NULL;
  return temp;
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_scoring(::CMsgFantasyLeagueScoring* scoring) {
  delete scoring_;
  scoring_ = scoring;
  if (scoring) {
    set_has_scoring();
  } else {
    clear_has_scoring();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueInfo.scoring)
}

// optional uint32 draft_time = 12;
inline bool CMsgDOTAFantasyLeagueInfo::has_draft_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_draft_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_draft_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_draft_time() {
  draft_time_ = 0u;
  clear_has_draft_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::draft_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.draft_time)
  return draft_time_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_draft_time(::google::protobuf::uint32 value) {
  set_has_draft_time();
  draft_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.draft_time)
}

// optional uint32 draft_pick_time = 13;
inline bool CMsgDOTAFantasyLeagueInfo::has_draft_pick_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_draft_pick_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_draft_pick_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_draft_pick_time() {
  draft_pick_time_ = 0u;
  clear_has_draft_pick_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::draft_pick_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.draft_pick_time)
  return draft_pick_time_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_draft_pick_time(::google::protobuf::uint32 value) {
  set_has_draft_pick_time();
  draft_pick_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.draft_pick_time)
}

// optional uint32 season_start = 15;
inline bool CMsgDOTAFantasyLeagueInfo::has_season_start() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_season_start() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_season_start() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season_start() {
  season_start_ = 0u;
  clear_has_season_start();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season_start() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.season_start)
  return season_start_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season_start(::google::protobuf::uint32 value) {
  set_has_season_start();
  season_start_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.season_start)
}

// optional uint32 season_length = 16;
inline bool CMsgDOTAFantasyLeagueInfo::has_season_length() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_season_length() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_season_length() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season_length() {
  season_length_ = 0u;
  clear_has_season_length();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season_length() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.season_length)
  return season_length_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season_length(::google::protobuf::uint32 value) {
  set_has_season_length();
  season_length_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.season_length)
}

// optional uint32 veto_votes = 17;
inline bool CMsgDOTAFantasyLeagueInfo::has_veto_votes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_veto_votes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_veto_votes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_veto_votes() {
  veto_votes_ = 0u;
  clear_has_veto_votes();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::veto_votes() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.veto_votes)
  return veto_votes_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_veto_votes(::google::protobuf::uint32 value) {
  set_has_veto_votes();
  veto_votes_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.veto_votes)
}

// optional uint32 acquisitions = 18;
inline bool CMsgDOTAFantasyLeagueInfo::has_acquisitions() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_acquisitions() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_acquisitions() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_acquisitions() {
  acquisitions_ = 0u;
  clear_has_acquisitions();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::acquisitions() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.acquisitions)
  return acquisitions_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_acquisitions(::google::protobuf::uint32 value) {
  set_has_acquisitions();
  acquisitions_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.acquisitions)
}

// optional uint32 slot_1 = 19;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_1() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_slot_1() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_slot_1() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_1() {
  slot_1_ = 0u;
  clear_has_slot_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.slot_1)
  return slot_1_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_1(::google::protobuf::uint32 value) {
  set_has_slot_1();
  slot_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.slot_1)
}

// optional uint32 slot_2 = 20;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_slot_2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_slot_2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_2() {
  slot_2_ = 0u;
  clear_has_slot_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.slot_2)
  return slot_2_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_2(::google::protobuf::uint32 value) {
  set_has_slot_2();
  slot_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.slot_2)
}

// optional uint32 slot_3 = 21;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_3() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_slot_3() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_slot_3() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_3() {
  slot_3_ = 0u;
  clear_has_slot_3();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_3() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.slot_3)
  return slot_3_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_3(::google::protobuf::uint32 value) {
  set_has_slot_3();
  slot_3_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.slot_3)
}

// optional uint32 slot_4 = 22;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_4() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_slot_4() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_slot_4() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_4() {
  slot_4_ = 0u;
  clear_has_slot_4();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_4() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.slot_4)
  return slot_4_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_4(::google::protobuf::uint32 value) {
  set_has_slot_4();
  slot_4_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.slot_4)
}

// optional uint32 slot_5 = 23;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_5() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_slot_5() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_slot_5() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_5() {
  slot_5_ = 0u;
  clear_has_slot_5();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_5() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.slot_5)
  return slot_5_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_5(::google::protobuf::uint32 value) {
  set_has_slot_5();
  slot_5_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.slot_5)
}

// optional uint32 bench_slots = 24;
inline bool CMsgDOTAFantasyLeagueInfo::has_bench_slots() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_bench_slots() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_bench_slots() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_bench_slots() {
  bench_slots_ = 0u;
  clear_has_bench_slots();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::bench_slots() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.bench_slots)
  return bench_slots_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_bench_slots(::google::protobuf::uint32 value) {
  set_has_bench_slots();
  bench_slots_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.bench_slots)
}

// repeated .CMsgDOTAFantasyLeagueInfo.OwnerInfo owner_info = 25;
inline int CMsgDOTAFantasyLeagueInfo::owner_info_size() const {
  return owner_info_.size();
}
inline void CMsgDOTAFantasyLeagueInfo::clear_owner_info() {
  owner_info_.Clear();
}
inline const ::CMsgDOTAFantasyLeagueInfo_OwnerInfo& CMsgDOTAFantasyLeagueInfo::owner_info(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Get(index);
}
inline ::CMsgDOTAFantasyLeagueInfo_OwnerInfo* CMsgDOTAFantasyLeagueInfo::mutable_owner_info(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Mutable(index);
}
inline ::CMsgDOTAFantasyLeagueInfo_OwnerInfo* CMsgDOTAFantasyLeagueInfo::add_owner_info() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueInfo_OwnerInfo >&
CMsgDOTAFantasyLeagueInfo::owner_info() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueInfo_OwnerInfo >*
CMsgDOTAFantasyLeagueInfo::mutable_owner_info() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueInfo.owner_info)
  return &owner_info_;
}

// repeated uint32 players = 26;
inline int CMsgDOTAFantasyLeagueInfo::players_size() const {
  return players_.size();
}
inline void CMsgDOTAFantasyLeagueInfo::clear_players() {
  players_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.players)
  return players_.Get(index);
}
inline void CMsgDOTAFantasyLeagueInfo::set_players(int index, ::google::protobuf::uint32 value) {
  players_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.players)
}
inline void CMsgDOTAFantasyLeagueInfo::add_players(::google::protobuf::uint32 value) {
  players_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueInfo.players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueInfo::players() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueInfo.players)
  return players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueInfo.players)
  return &players_;
}

// optional uint32 time_zone = 27;
inline bool CMsgDOTAFantasyLeagueInfo::has_time_zone() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_time_zone() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_time_zone() {
  time_zone_ = 0u;
  clear_has_time_zone();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::time_zone() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.time_zone)
  return time_zone_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_time_zone(::google::protobuf::uint32 value) {
  set_has_time_zone();
  time_zone_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.time_zone)
}

// optional uint32 season = 28;
inline bool CMsgDOTAFantasyLeagueInfo::has_season() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_season() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_season() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.season)
  return season_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.season)
}

// optional string password = 29;
inline bool CMsgDOTAFantasyLeagueInfo::has_password() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::set_has_password() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgDOTAFantasyLeagueInfo::password() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfo.password)
  return *password_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfo.password)
}
inline void CMsgDOTAFantasyLeagueInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueInfo.password)
}
inline void CMsgDOTAFantasyLeagueInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueInfo.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueInfo.password)
  return password_;
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueInfo.password)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInfoRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInfoRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInfoRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInfoRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInfoRequest.fantasy_league_id)
}

// optional .CMsgDOTAFantasyLeagueInfo edit_info = 2;
inline bool CMsgDOTAFantasyLeagueEditInfoRequest::has_edit_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_has_edit_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_has_edit_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_edit_info() {
  if (edit_info_ != NULL) edit_info_->::CMsgDOTAFantasyLeagueInfo::Clear();
  clear_has_edit_info();
}
inline const ::CMsgDOTAFantasyLeagueInfo& CMsgDOTAFantasyLeagueEditInfoRequest::edit_info() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
  return edit_info_ != NULL ? *edit_info_ : *default_instance_->edit_info_;
}
inline ::CMsgDOTAFantasyLeagueInfo* CMsgDOTAFantasyLeagueEditInfoRequest::mutable_edit_info() {
  set_has_edit_info();
  if (edit_info_ == NULL) edit_info_ = new ::CMsgDOTAFantasyLeagueInfo;
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
  return edit_info_;
}
inline ::CMsgDOTAFantasyLeagueInfo* CMsgDOTAFantasyLeagueEditInfoRequest::release_edit_info() {
  clear_has_edit_info();
  ::CMsgDOTAFantasyLeagueInfo* temp = edit_info_;
  edit_info_ = NULL;
  return temp;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_allocated_edit_info(::CMsgDOTAFantasyLeagueInfo* edit_info) {
  delete edit_info_;
  edit_info_ = edit_info;
  if (edit_info) {
    set_has_edit_info();
  } else {
    clear_has_edit_info();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInfoResponse

// optional .CMsgDOTAFantasyLeagueEditInfoResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueEditInfoResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInfoResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::set_result(::CMsgDOTAFantasyLeagueEditInfoResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInfoResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueFindRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueFindRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueFindRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueFindRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueFindRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyLeagueFindRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindRequest::password() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueFindRequest.password)
  return *password_;
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueFindRequest.password)
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueFindRequest.password)
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueFindRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueFindRequest.password)
  return password_;
}
inline ::std::string* CMsgDOTAFantasyLeagueFindRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueFindRequest.password)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueFindResponse

// optional .CMsgDOTAFantasyLeagueFindResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueFindResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueFindResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueFindResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_result(::CMsgDOTAFantasyLeagueFindResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueFindResponse.result)
}

// optional string fantasy_league_name = 2;
inline bool CMsgDOTAFantasyLeagueFindResponse::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_has_fantasy_league_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_has_fantasy_league_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_fantasy_league_name() {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_->clear();
  }
  clear_has_fantasy_league_name();
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
  return *fantasy_league_name_;
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const ::std::string& value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const char* value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const char* value, size_t size) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::mutable_fantasy_league_name() {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
  return fantasy_league_name_;
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::release_fantasy_league_name() {
  clear_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_league_name_;
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fantasy_league_name_;
  }
  if (fantasy_league_name) {
    set_has_fantasy_league_name();
    fantasy_league_name_ = fantasy_league_name;
  } else {
    clear_has_fantasy_league_name();
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}

// optional string commissioner_name = 3;
inline bool CMsgDOTAFantasyLeagueFindResponse::has_commissioner_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_has_commissioner_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_has_commissioner_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_commissioner_name() {
  if (commissioner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commissioner_name_->clear();
  }
  clear_has_commissioner_name();
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse::commissioner_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
  return *commissioner_name_;
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const ::std::string& value) {
  set_has_commissioner_name();
  if (commissioner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commissioner_name_ = new ::std::string;
  }
  commissioner_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const char* value) {
  set_has_commissioner_name();
  if (commissioner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commissioner_name_ = new ::std::string;
  }
  commissioner_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const char* value, size_t size) {
  set_has_commissioner_name();
  if (commissioner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commissioner_name_ = new ::std::string;
  }
  commissioner_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::mutable_commissioner_name() {
  set_has_commissioner_name();
  if (commissioner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commissioner_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
  return commissioner_name_;
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::release_commissioner_name() {
  clear_has_commissioner_name();
  if (commissioner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = commissioner_name_;
    commissioner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_allocated_commissioner_name(::std::string* commissioner_name) {
  if (commissioner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete commissioner_name_;
  }
  if (commissioner_name) {
    set_has_commissioner_name();
    commissioner_name_ = commissioner_name;
  } else {
    clear_has_commissioner_name();
    commissioner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfoRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueInfoRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfoRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfoRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfoRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfoResponse

// optional .CMsgDOTAFantasyLeagueInfoResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueInfoResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfoResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfoResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueInfoResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueInfoResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueInfoResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueInfoResponse::set_result(::CMsgDOTAFantasyLeagueInfoResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueInfoResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueMatchupsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse_Matchup

// optional uint32 owner_account_id_1 = 1;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_owner_account_id_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_has_owner_account_id_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_has_owner_account_id_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_owner_account_id_1() {
  owner_account_id_1_ = 0u;
  clear_has_owner_account_id_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::owner_account_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_1)
  return owner_account_id_1_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_owner_account_id_1(::google::protobuf::uint32 value) {
  set_has_owner_account_id_1();
  owner_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_1)
}

// optional uint32 owner_account_id_2 = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_has_owner_account_id_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_has_owner_account_id_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  clear_has_owner_account_id_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_owner_account_id_2(::google::protobuf::uint32 value) {
  set_has_owner_account_id_2();
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_2)
}

// optional float score_1 = 3;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_score_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_has_score_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_has_score_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_score_1() {
  score_1_ = 0;
  clear_has_score_1();
}
inline float CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::score_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_1)
  return score_1_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_score_1(float value) {
  set_has_score_1();
  score_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_1)
}

// optional float score_2 = 4;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_score_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_has_score_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_has_score_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_score_2() {
  score_2_ = 0;
  clear_has_score_2();
}
inline float CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::score_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_2)
  return score_2_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_score_2(float value) {
  set_has_score_2();
  score_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups

// repeated .CMsgDOTAFantasyLeagueMatchupsResponse.Matchup matchup = 1;
inline int CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup_size() const {
  return matchup_.size();
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_matchup() {
  matchup_.Clear();
}
inline const ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Get(index);
}
inline ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mutable_matchup(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Mutable(index);
}
inline ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::add_matchup() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >&
CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >*
CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mutable_matchup() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return &matchup_;
}

// optional uint32 start_time = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.start_time)
  return start_time_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.start_time)
}

// optional uint32 end_time = 3;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.end_time)
  return end_time_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.end_time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse

// optional .CMsgDOTAFantasyLeagueMatchupsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueMatchupsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_result(::CMsgDOTAFantasyLeagueMatchupsResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueMatchupsResponse.fantasy_league_id)
}

// repeated .CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups weekly_matchups = 3;
inline int CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups_size() const {
  return weekly_matchups_.size();
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_weekly_matchups() {
  weekly_matchups_.Clear();
}
inline const ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Get(index);
}
inline ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* CMsgDOTAFantasyLeagueMatchupsResponse::mutable_weekly_matchups(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Mutable(index);
}
inline ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* CMsgDOTAFantasyLeagueMatchupsResponse::add_weekly_matchups() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >&
CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >*
CMsgDOTAFantasyLeagueMatchupsResponse::mutable_weekly_matchups() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return &weekly_matchups_;
}

// -------------------------------------------------------------------

// CMsgDOTAEditFantasyTeamRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAEditFantasyTeamRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAEditFantasyTeamRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditFantasyTeamRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAEditFantasyTeamRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_has_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAEditFantasyTeamRequest::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditFantasyTeamRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAEditFantasyTeamRequest.team_index)
}

// optional string team_name = 3;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_has_team_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& CMsgDOTAEditFantasyTeamRequest::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditFantasyTeamRequest.team_name)
  return *team_name_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditFantasyTeamRequest.team_name)
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAEditFantasyTeamRequest.team_name)
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAEditFantasyTeamRequest.team_name)
}
inline ::std::string* CMsgDOTAEditFantasyTeamRequest::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditFantasyTeamRequest.team_name)
  return team_name_;
}
inline ::std::string* CMsgDOTAEditFantasyTeamRequest::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAEditFantasyTeamRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditFantasyTeamRequest.team_name)
}

// optional uint64 team_logo = 4;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_has_team_logo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_has_team_logo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_logo() {
  team_logo_ = GOOGLE_ULONGLONG(0);
  clear_has_team_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAEditFantasyTeamRequest::team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditFantasyTeamRequest.team_logo)
  return team_logo_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_logo(::google::protobuf::uint64 value) {
  set_has_team_logo();
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAEditFantasyTeamRequest.team_logo)
}

// -------------------------------------------------------------------

// CMsgDOTAEditFantasyTeamResponse

// optional .CMsgDOTAEditFantasyTeamResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAEditFantasyTeamResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAEditFantasyTeamResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAEditFantasyTeamResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAEditFantasyTeamResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditFantasyTeamResponse.result)
  return static_cast< ::CMsgDOTAEditFantasyTeamResponse_EResult >(result_);
}
inline void CMsgDOTAEditFantasyTeamResponse::set_result(::CMsgDOTAEditFantasyTeamResponse_EResult value) {
  assert(::CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAEditFantasyTeamResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID

// optional uint32 owner_account_id = 1;
inline bool CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.owner_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoResponse

// repeated .CMsgDOTAFantasyTeamInfo results = 1;
inline int CMsgDOTAFantasyTeamInfoResponse::results_size() const {
  return results_.size();
}
inline void CMsgDOTAFantasyTeamInfoResponse::clear_results() {
  results_.Clear();
}
inline const ::CMsgDOTAFantasyTeamInfo& CMsgDOTAFantasyTeamInfoResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Get(index);
}
inline ::CMsgDOTAFantasyTeamInfo* CMsgDOTAFantasyTeamInfoResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Mutable(index);
}
inline ::CMsgDOTAFantasyTeamInfo* CMsgDOTAFantasyTeamInfoResponse::add_results() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamInfo >&
CMsgDOTAFantasyTeamInfoResponse::results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamInfoResponse.results)
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamInfo >*
CMsgDOTAFantasyTeamInfoResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamInfoResponse.results)
  return &results_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfo

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamInfo::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamInfo::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamInfo::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamInfo::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamInfo::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_fantasy_team_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_fantasy_team_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  clear_has_fantasy_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamInfo::set_fantasy_team_index(::google::protobuf::uint32 value) {
  set_has_fantasy_team_index();
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.fantasy_team_index)
}

// optional string team_name = 4;
inline bool CMsgDOTAFantasyTeamInfo::has_team_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_team_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& CMsgDOTAFantasyTeamInfo::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.team_name)
  return *team_name_;
}
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.team_name)
}
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyTeamInfo.team_name)
}
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyTeamInfo.team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamInfo::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamInfo.team_name)
  return team_name_;
}
inline ::std::string* CMsgDOTAFantasyTeamInfo::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyTeamInfo::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyTeamInfo.team_name)
}

// optional uint64 team_logo = 5;
inline bool CMsgDOTAFantasyTeamInfo::has_team_logo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_team_logo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_team_logo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_team_logo() {
  team_logo_ = GOOGLE_ULONGLONG(0);
  clear_has_team_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamInfo::team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.team_logo)
  return team_logo_;
}
inline void CMsgDOTAFantasyTeamInfo::set_team_logo(::google::protobuf::uint64 value) {
  set_has_team_logo();
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.team_logo)
}

// optional uint32 wins = 6;
inline bool CMsgDOTAFantasyTeamInfo::has_wins() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_wins() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_wins() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_wins() {
  wins_ = 0u;
  clear_has_wins();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.wins)
  return wins_;
}
inline void CMsgDOTAFantasyTeamInfo::set_wins(::google::protobuf::uint32 value) {
  set_has_wins();
  wins_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.wins)
}

// optional uint32 losses = 7;
inline bool CMsgDOTAFantasyTeamInfo::has_losses() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::set_has_losses() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_has_losses() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyTeamInfo::clear_losses() {
  losses_ = 0u;
  clear_has_losses();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::losses() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.losses)
  return losses_;
}
inline void CMsgDOTAFantasyTeamInfo::set_losses(::google::protobuf::uint32 value) {
  set_has_losses();
  losses_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.losses)
}

// repeated uint32 current_roster = 8;
inline int CMsgDOTAFantasyTeamInfo::current_roster_size() const {
  return current_roster_.size();
}
inline void CMsgDOTAFantasyTeamInfo::clear_current_roster() {
  current_roster_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::current_roster(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamInfo.current_roster)
  return current_roster_.Get(index);
}
inline void CMsgDOTAFantasyTeamInfo::set_current_roster(int index, ::google::protobuf::uint32 value) {
  current_roster_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamInfo.current_roster)
}
inline void CMsgDOTAFantasyTeamInfo::add_current_roster(::google::protobuf::uint32 value) {
  current_roster_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamInfo.current_roster)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyTeamInfo::current_roster() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamInfo.current_roster)
  return current_roster_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyTeamInfo::mutable_current_roster() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamInfo.current_roster)
  return &current_roster_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_fantasy_team_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_fantasy_team_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  clear_has_fantasy_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_fantasy_team_index(::google::protobuf::uint32 value) {
  set_has_fantasy_team_index();
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.fantasy_team_index)
}

// optional uint64 filter_match_id = 4;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_filter_match_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_filter_match_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_match_id() {
  filter_match_id_ = GOOGLE_ULONGLONG(0);
  clear_has_filter_match_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamScoreRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  set_has_filter_match_id();
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.filter_match_id)
}

// optional uint32 filter_start_time = 5;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_filter_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_filter_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  clear_has_filter_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  set_has_filter_start_time();
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.filter_start_time)
}

// optional uint32 filter_end_time = 6;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_filter_end_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_filter_end_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  clear_has_filter_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  set_has_filter_end_time();
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.filter_end_time)
}

// optional bool include_bench = 7;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_include_bench() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_has_include_bench() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_has_include_bench() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_include_bench() {
  include_bench_ = false;
  clear_has_include_bench();
}
inline bool CMsgDOTAFantasyTeamScoreRequest::include_bench() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreRequest.include_bench)
  return include_bench_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_include_bench(bool value) {
  set_has_include_bench();
  include_bench_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreRequest.include_bench)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.account_id)
}

// optional float score = 2;
inline bool CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.score)
  return score_;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreResponse

// optional .CMsgDOTAFantasyTeamScoreResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamScoreResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamScoreResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_result(::CMsgDOTAFantasyTeamScoreResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreResponse.result)
}

// optional float fantasy_team_score = 2;
inline bool CMsgDOTAFantasyTeamScoreResponse::has_fantasy_team_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_has_fantasy_team_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_has_fantasy_team_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_fantasy_team_score() {
  fantasy_team_score_ = 0;
  clear_has_fantasy_team_score();
}
inline float CMsgDOTAFantasyTeamScoreResponse::fantasy_team_score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreResponse.fantasy_team_score)
  return fantasy_team_score_;
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_fantasy_team_score(float value) {
  set_has_fantasy_team_score();
  fantasy_team_score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamScoreResponse.fantasy_team_score)
}

// repeated .CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore fantasy_player_score = 3;
inline int CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score_size() const {
  return fantasy_player_score_.size();
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_fantasy_player_score() {
  fantasy_player_score_.Clear();
}
inline const ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Get(index);
}
inline ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* CMsgDOTAFantasyTeamScoreResponse::mutable_fantasy_player_score(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Mutable(index);
}
inline ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* CMsgDOTAFantasyTeamScoreResponse::add_fantasy_player_score() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >&
CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >*
CMsgDOTAFantasyTeamScoreResponse::mutable_fantasy_player_score() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return &fantasy_player_score_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.fantasy_league_id)
}

// optional uint32 count = 2;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.count)
  return count_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.count)
}

// optional uint32 filter_start_time = 3;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_filter_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_filter_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  clear_has_filter_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  set_has_filter_start_time();
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.filter_start_time)
}

// optional uint32 filter_end_time = 4;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_filter_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_filter_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  clear_has_filter_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  set_has_filter_end_time();
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.filter_end_time)
}

// optional uint64 filter_match_id = 5;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_filter_match_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_filter_match_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_match_id() {
  filter_match_id_ = GOOGLE_ULONGLONG(0);
  clear_has_filter_match_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamStandingsRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  set_has_filter_match_id();
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.filter_match_id)
}

// optional bool filter_last_match = 6;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_filter_last_match() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_filter_last_match() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  clear_has_filter_last_match();
}
inline bool CMsgDOTAFantasyTeamStandingsRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_last_match(bool value) {
  set_has_filter_last_match();
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.filter_last_match)
}

// optional bool filter_in_hall = 7;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_in_hall() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_has_filter_in_hall() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_has_filter_in_hall() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_in_hall() {
  filter_in_hall_ = false;
  clear_has_filter_in_hall();
}
inline bool CMsgDOTAFantasyTeamStandingsRequest::filter_in_hall() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsRequest.filter_in_hall)
  return filter_in_hall_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_in_hall(bool value) {
  set_has_filter_in_hall();
  filter_in_hall_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsRequest.filter_in_hall)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_fantasy_team_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_fantasy_team_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  clear_has_fantasy_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_index(::google::protobuf::uint32 value) {
  set_has_fantasy_team_index();
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_index)
}

// optional uint64 fantasy_team_logo = 4;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_fantasy_team_logo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_fantasy_team_logo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_logo() {
  fantasy_team_logo_ = GOOGLE_ULONGLONG(0);
  clear_has_fantasy_team_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_logo)
  return fantasy_team_logo_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_logo(::google::protobuf::uint64 value) {
  set_has_fantasy_team_logo();
  fantasy_team_logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_logo)
}

// optional string owner_name = 5;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_owner_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_owner_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_owner_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_owner_name() {
  if (owner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_->clear();
  }
  clear_has_owner_name();
}
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::owner_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
  return *owner_name_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const ::std::string& value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const char* value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const char* value, size_t size) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mutable_owner_name() {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
  return owner_name_;
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::release_owner_name() {
  clear_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_name_;
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_name_;
  }
  if (owner_name) {
    set_has_owner_name();
    owner_name_ = owner_name;
  } else {
    clear_has_owner_name();
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}

// optional string fantasy_team_name = 6;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_fantasy_team_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_fantasy_team_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_name() {
  if (fantasy_team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_team_name_->clear();
  }
  clear_has_fantasy_team_name();
}
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
  return *fantasy_team_name_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const ::std::string& value) {
  set_has_fantasy_team_name();
  if (fantasy_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_team_name_ = new ::std::string;
  }
  fantasy_team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const char* value) {
  set_has_fantasy_team_name();
  if (fantasy_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_team_name_ = new ::std::string;
  }
  fantasy_team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const char* value, size_t size) {
  set_has_fantasy_team_name();
  if (fantasy_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_team_name_ = new ::std::string;
  }
  fantasy_team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mutable_fantasy_team_name() {
  set_has_fantasy_team_name();
  if (fantasy_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
  return fantasy_team_name_;
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::release_fantasy_team_name() {
  clear_has_fantasy_team_name();
  if (fantasy_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_team_name_;
    fantasy_team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_allocated_fantasy_team_name(::std::string* fantasy_team_name) {
  if (fantasy_team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fantasy_team_name_;
  }
  if (fantasy_team_name) {
    set_has_fantasy_team_name();
    fantasy_team_name_ = fantasy_team_name;
  } else {
    clear_has_fantasy_team_name();
    fantasy_team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}

// optional float score = 7;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score)
  return score_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score)
}

// optional float score_against = 8;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_score_against() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_score_against() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_score_against() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_score_against() {
  score_against_ = 0;
  clear_has_score_against();
}
inline float CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::score_against() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score_against)
  return score_against_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_score_against(float value) {
  set_has_score_against();
  score_against_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score_against)
}

// optional uint32 wins = 9;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_wins() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_wins() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_wins() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_wins() {
  wins_ = 0u;
  clear_has_wins();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.wins)
  return wins_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_wins(::google::protobuf::uint32 value) {
  set_has_wins();
  wins_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.wins)
}

// optional uint32 losses = 10;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_losses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_losses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_losses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_losses() {
  losses_ = 0u;
  clear_has_losses();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::losses() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.losses)
  return losses_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_losses(::google::protobuf::uint32 value) {
  set_has_losses();
  losses_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.losses)
}

// optional int32 streak = 11;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_streak() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_has_streak() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_has_streak() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_streak() {
  streak_ = 0;
  clear_has_streak();
}
inline ::google::protobuf::int32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::streak() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.streak)
  return streak_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_streak(::google::protobuf::int32 value) {
  set_has_streak();
  streak_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.streak)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsResponse

// optional .CMsgDOTAFantasyTeamStandingsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamStandingsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamStandingsResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamStandingsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamStandingsResponse::set_result(::CMsgDOTAFantasyTeamStandingsResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamStandingsResponse.result)
}

// repeated .CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore team_scores = 3;
inline int CMsgDOTAFantasyTeamStandingsResponse::team_scores_size() const {
  return team_scores_.size();
}
inline void CMsgDOTAFantasyTeamStandingsResponse::clear_team_scores() {
  team_scores_.Clear();
}
inline const ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& CMsgDOTAFantasyTeamStandingsResponse::team_scores(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Get(index);
}
inline ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* CMsgDOTAFantasyTeamStandingsResponse::mutable_team_scores(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Mutable(index);
}
inline ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* CMsgDOTAFantasyTeamStandingsResponse::add_team_scores() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >&
CMsgDOTAFantasyTeamStandingsResponse::team_scores() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >*
CMsgDOTAFantasyTeamStandingsResponse::mutable_team_scores() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return &team_scores_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.fantasy_league_id)
}

// optional uint32 player_account_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_player_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_player_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  clear_has_player_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_player_account_id(::google::protobuf::uint32 value) {
  set_has_player_account_id();
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.player_account_id)
}

// optional uint32 filter_start_time = 3;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_filter_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_filter_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  clear_has_filter_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  set_has_filter_start_time();
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.filter_start_time)
}

// optional uint32 filter_end_time = 4;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_filter_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_filter_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  clear_has_filter_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  set_has_filter_end_time();
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.filter_end_time)
}

// optional uint64 filter_match_id = 5;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_filter_match_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_filter_match_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_match_id() {
  filter_match_id_ = GOOGLE_ULONGLONG(0);
  clear_has_filter_match_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  set_has_filter_match_id();
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.filter_match_id)
}

// optional bool filter_last_match = 6;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_has_filter_last_match() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_has_filter_last_match() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  clear_has_filter_last_match();
}
inline bool CMsgDOTAFantasyPlayerScoreRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_last_match(bool value) {
  set_has_filter_last_match();
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreRequest.filter_last_match)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreResponse

// optional .CMsgDOTAFantasyPlayerScoreResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreResponse.result)
  return static_cast< ::CMsgDOTAFantasyPlayerScoreResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_result(::CMsgDOTAFantasyPlayerScoreResponse_EResult value) {
  assert(::CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreResponse.fantasy_league_id)
}

// optional uint32 player_account_id = 3;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_has_player_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_has_player_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_player_account_id() {
  player_account_id_ = 0u;
  clear_has_player_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreResponse::player_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreResponse.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_account_id(::google::protobuf::uint32 value) {
  set_has_player_account_id();
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreResponse.player_account_id)
}

// optional string player_name = 4;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_player_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_has_player_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& CMsgDOTAFantasyPlayerScoreResponse::player_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreResponse.player_name)
  return *player_name_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreResponse::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerScoreResponse.player_name)
  return player_name_;
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreResponse::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerScoreResponse.player_name)
}

// optional float score = 5;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgDOTAFantasyPlayerScoreResponse::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreResponse.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreResponse.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.fantasy_league_id)
}

// optional uint32 count = 2;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.count)
  return count_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.count)
}

// optional uint32 role = 3;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::role() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.role)
  return role_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.role)
}

// optional uint32 filter_start_time = 4;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_filter_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_filter_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  clear_has_filter_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  set_has_filter_start_time();
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.filter_start_time)
}

// optional uint32 filter_end_time = 5;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_filter_end_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_filter_end_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  clear_has_filter_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  set_has_filter_end_time();
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.filter_end_time)
}

// optional uint64 filter_match_id = 6;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_filter_match_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_filter_match_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_match_id() {
  filter_match_id_ = GOOGLE_ULONGLONG(0);
  clear_has_filter_match_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerStandingsRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  set_has_filter_match_id();
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.filter_match_id)
}

// optional bool filter_last_match = 7;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_has_filter_last_match() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_has_filter_last_match() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  clear_has_filter_last_match();
}
inline bool CMsgDOTAFantasyPlayerStandingsRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_last_match(bool value) {
  set_has_filter_last_match();
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsRequest.filter_last_match)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore

// optional uint32 player_account_id = 1;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_has_player_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_has_player_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_player_account_id() {
  player_account_id_ = 0u;
  clear_has_player_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::player_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_account_id(::google::protobuf::uint32 value) {
  set_has_player_account_id();
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_account_id)
}

// optional string player_name = 2;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_player_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_has_player_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_has_player_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_player_name() {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_->clear();
  }
  clear_has_player_name();
}
inline const ::std::string& CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::player_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
  return *player_name_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const ::std::string& value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const char* value) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const char* value, size_t size) {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  player_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::mutable_player_name() {
  set_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    player_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
  return player_name_;
}
inline ::std::string* CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::release_player_name() {
  clear_has_player_name();
  if (player_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = player_name_;
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_allocated_player_name(::std::string* player_name) {
  if (player_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete player_name_;
  }
  if (player_name) {
    set_has_player_name();
    player_name_ = player_name;
  } else {
    clear_has_player_name();
    player_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}

// optional float score = 3;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsResponse

// optional .CMsgDOTAFantasyPlayerStandingsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.result)
  return static_cast< ::CMsgDOTAFantasyPlayerStandingsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_result(::CMsgDOTAFantasyPlayerStandingsResponse_EResult value) {
  assert(::CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.fantasy_league_id)
}

// optional uint32 role = 3;
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_has_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_has_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_role() {
  role_ = 0u;
  clear_has_role();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse::role() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.role)
  return role_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_role(::google::protobuf::uint32 value) {
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerStandingsResponse.role)
}

// repeated .CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore player_scores = 4;
inline int CMsgDOTAFantasyPlayerStandingsResponse::player_scores_size() const {
  return player_scores_.size();
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_player_scores() {
  player_scores_.Clear();
}
inline const ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& CMsgDOTAFantasyPlayerStandingsResponse::player_scores(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Get(index);
}
inline ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* CMsgDOTAFantasyPlayerStandingsResponse::mutable_player_scores(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Mutable(index);
}
inline ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* CMsgDOTAFantasyPlayerStandingsResponse::add_player_scores() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >&
CMsgDOTAFantasyPlayerStandingsResponse::player_scores() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >*
CMsgDOTAFantasyPlayerStandingsResponse::mutable_player_scores() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return &player_scores_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerInfoRequest

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerInfoResponse

// optional .CMsgGCPlayerInfo msg = 1;
inline bool CMsgDOTAFantasyPlayerInfoResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerInfoResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerInfoResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerInfoResponse::clear_msg() {
  if (msg_ != NULL) msg_->::CMsgGCPlayerInfo::Clear();
  clear_has_msg();
}
inline const ::CMsgGCPlayerInfo& CMsgDOTAFantasyPlayerInfoResponse::msg() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerInfoResponse.msg)
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::CMsgGCPlayerInfo* CMsgDOTAFantasyPlayerInfoResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::CMsgGCPlayerInfo;
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerInfoResponse.msg)
  return msg_;
}
inline ::CMsgGCPlayerInfo* CMsgDOTAFantasyPlayerInfoResponse::release_msg() {
  clear_has_msg();
  ::CMsgGCPlayerInfo* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void CMsgDOTAFantasyPlayerInfoResponse::set_allocated_msg(::CMsgGCPlayerInfo* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerInfoResponse.msg)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueCreateRequest

// optional uint32 season_id = 1;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_season_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_season_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_season_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_season_id() {
  season_id_ = 0u;
  clear_has_season_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueCreateRequest::season_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.season_id)
  return season_id_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_season_id(::google::protobuf::uint32 value) {
  set_has_season_id();
  season_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.season_id)
}

// optional string fantasy_league_name = 2;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_fantasy_league_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_fantasy_league_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_fantasy_league_name() {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_->clear();
  }
  clear_has_fantasy_league_name();
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
  return *fantasy_league_name_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const ::std::string& value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const char* value) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const char* value, size_t size) {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  fantasy_league_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_fantasy_league_name() {
  set_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fantasy_league_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
  return fantasy_league_name_;
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_fantasy_league_name() {
  clear_has_fantasy_league_name();
  if (fantasy_league_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_league_name_;
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fantasy_league_name_;
  }
  if (fantasy_league_name) {
    set_has_fantasy_league_name();
    fantasy_league_name_ = fantasy_league_name;
  } else {
    clear_has_fantasy_league_name();
    fantasy_league_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}

// optional string password = 3;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::password() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.password)
  return *password_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.password)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueCreateRequest.password)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueCreateRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueCreateRequest.password)
  return password_;
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueCreateRequest.password)
}

// optional string team_name = 4;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_team_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.team_name)
  return *team_name_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueCreateRequest.team_name)
  return team_name_;
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueCreateRequest.team_name)
}

// optional uint64 logo = 5;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_logo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_logo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_logo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_logo() {
  logo_ = GOOGLE_ULONGLONG(0);
  clear_has_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueCreateRequest::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.logo)
  return logo_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_logo(::google::protobuf::uint64 value) {
  set_has_logo();
  logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.logo)
}

// optional uint64 ticket_item_id = 6;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_ticket_item_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_has_ticket_item_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_has_ticket_item_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_ticket_item_id() {
  ticket_item_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ticket_item_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueCreateRequest::ticket_item_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateRequest.ticket_item_id)
  return ticket_item_id_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_ticket_item_id(::google::protobuf::uint64 value) {
  set_has_ticket_item_id();
  ticket_item_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateRequest.ticket_item_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueCreateResponse

// optional .CMsgDOTAFantasyLeagueCreateResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueCreateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueCreateResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_result(::CMsgDOTAFantasyLeagueCreateResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyLeagueCreateResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueCreateResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueCreateResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueCreateResponse.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamCreateRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamCreateRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgDOTAFantasyTeamCreateRequest::password() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateRequest.password)
  return *password_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateRequest.password)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyTeamCreateRequest.password)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyTeamCreateRequest.password)
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamCreateRequest.password)
  return password_;
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyTeamCreateRequest.password)
}

// optional string team_name = 3;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_has_team_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& CMsgDOTAFantasyTeamCreateRequest::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateRequest.team_name)
  return *team_name_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateRequest.team_name)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyTeamCreateRequest.team_name)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyTeamCreateRequest.team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamCreateRequest.team_name)
  return team_name_;
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyTeamCreateRequest.team_name)
}

// optional uint64 logo = 4;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_has_logo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_has_logo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_logo() {
  logo_ = GOOGLE_ULONGLONG(0);
  clear_has_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamCreateRequest::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateRequest.logo)
  return logo_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_logo(::google::protobuf::uint64 value) {
  set_has_logo();
  logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateRequest.logo)
}

// optional uint64 ticket_item_id = 5;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_ticket_item_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_has_ticket_item_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_has_ticket_item_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_ticket_item_id() {
  ticket_item_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ticket_item_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamCreateRequest::ticket_item_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateRequest.ticket_item_id)
  return ticket_item_id_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_ticket_item_id(::google::protobuf::uint64 value) {
  set_has_ticket_item_id();
  ticket_item_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateRequest.ticket_item_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamCreateResponse

// optional .CMsgDOTAFantasyTeamCreateResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamCreateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamCreateResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_result(::CMsgDOTAFantasyTeamCreateResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateResponse.result)
}

// optional uint32 fantasy_team_index = 2;
inline bool CMsgDOTAFantasyTeamCreateResponse::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_has_fantasy_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_has_fantasy_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  clear_has_fantasy_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamCreateResponse::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamCreateResponse.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_fantasy_team_index(::google::protobuf::uint32 value) {
  set_has_fantasy_team_index();
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamCreateResponse.fantasy_team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.account_id)
}

// optional bool invited = 2;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::has_invited() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_has_invited() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_has_invited() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_invited() {
  invited_ = false;
  clear_has_invited();
}
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::invited() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.invited)
  return invited_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_invited(bool value) {
  set_has_invited();
  invited_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.invited)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInvitesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInvitesRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgDOTAFantasyLeagueEditInvitesRequest::password() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
  return *password_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
  return password_;
}
inline ::std::string* CMsgDOTAFantasyLeagueEditInvitesRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}

// repeated .CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange invite_change = 3;
inline int CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change_size() const {
  return invite_change_.size();
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_invite_change() {
  invite_change_.Clear();
}
inline const ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Get(index);
}
inline ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_invite_change(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Mutable(index);
}
inline ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* CMsgDOTAFantasyLeagueEditInvitesRequest::add_invite_change() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >&
CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >*
CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_invite_change() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return &invite_change_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesResponse

// optional .CMsgDOTAFantasyLeagueEditInvitesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueEditInvitesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueEditInvitesResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::set_result(::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueEditInvitesResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftStatusRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftStatusRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatusRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatusRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatusRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftStatus

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.fantasy_league_id)
}

// repeated uint32 draft_order = 2;
inline int CMsgDOTAFantasyLeagueDraftStatus::draft_order_size() const {
  return draft_order_.size();
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_draft_order() {
  draft_order_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::draft_order(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return draft_order_.Get(index);
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_draft_order(int index, ::google::protobuf::uint32 value) {
  draft_order_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.draft_order)
}
inline void CMsgDOTAFantasyLeagueDraftStatus::add_draft_order(::google::protobuf::uint32 value) {
  draft_order_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueDraftStatus.draft_order)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueDraftStatus::draft_order() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return draft_order_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueDraftStatus::mutable_draft_order() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return &draft_order_;
}

// optional uint32 current_pick = 3;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_current_pick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_has_current_pick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_has_current_pick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_current_pick() {
  current_pick_ = 0u;
  clear_has_current_pick();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::current_pick() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.current_pick)
  return current_pick_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_current_pick(::google::protobuf::uint32 value) {
  set_has_current_pick();
  current_pick_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.current_pick)
}

// optional uint32 time_remaining = 4;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_time_remaining() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_has_time_remaining() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_has_time_remaining() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_time_remaining() {
  time_remaining_ = 0u;
  clear_has_time_remaining();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::time_remaining() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.time_remaining)
  return time_remaining_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_time_remaining(::google::protobuf::uint32 value) {
  set_has_time_remaining();
  time_remaining_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.time_remaining)
}

// optional bool pending_resume = 5;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_pending_resume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_has_pending_resume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_has_pending_resume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_pending_resume() {
  pending_resume_ = false;
  clear_has_pending_resume();
}
inline bool CMsgDOTAFantasyLeagueDraftStatus::pending_resume() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.pending_resume)
  return pending_resume_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_pending_resume(bool value) {
  set_has_pending_resume();
  pending_resume_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.pending_resume)
}

// optional bool completed = 6;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_completed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_has_completed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_has_completed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_completed() {
  completed_ = false;
  clear_has_completed();
}
inline bool CMsgDOTAFantasyLeagueDraftStatus::completed() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.completed)
  return completed_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_completed(bool value) {
  set_has_completed();
  completed_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.completed)
}

// repeated uint32 available_players = 7;
inline int CMsgDOTAFantasyLeagueDraftStatus::available_players_size() const {
  return available_players_.size();
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_available_players() {
  available_players_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::available_players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return available_players_.Get(index);
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_available_players(int index, ::google::protobuf::uint32 value) {
  available_players_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftStatus.available_players)
}
inline void CMsgDOTAFantasyLeagueDraftStatus::add_available_players(::google::protobuf::uint32 value) {
  available_players_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyLeagueDraftStatus.available_players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueDraftStatus::available_players() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return available_players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueDraftStatus::mutable_available_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return &available_players_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftPlayerRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftPlayerRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftPlayerRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_has_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftPlayerRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftPlayerRequest.team_index)
}

// optional uint32 player_account_id = 3;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_has_player_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_has_player_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  clear_has_player_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftPlayerRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_player_account_id(::google::protobuf::uint32 value) {
  set_has_player_account_id();
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftPlayerRequest.player_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftPlayerResponse

// optional .CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueDraftPlayerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeagueDraftPlayerResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::set_result(::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeagueDraftPlayerResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterSwapRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_has_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapRequest.team_index)
}

// optional uint32 timestamp = 3;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapRequest.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapRequest.timestamp)
}

// optional uint32 slot_1 = 4;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_slot_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_has_slot_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_has_slot_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_slot_1() {
  slot_1_ = 0u;
  clear_has_slot_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::slot_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapRequest.slot_1)
  return slot_1_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_slot_1(::google::protobuf::uint32 value) {
  set_has_slot_1();
  slot_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapRequest.slot_1)
}

// optional uint32 slot_2 = 5;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_slot_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_has_slot_2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_has_slot_2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_slot_2() {
  slot_2_ = 0u;
  clear_has_slot_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::slot_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapRequest.slot_2)
  return slot_2_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_slot_2(::google::protobuf::uint32 value) {
  set_has_slot_2();
  slot_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapRequest.slot_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterSwapResponse

// optional .CMsgDOTAFantasyTeamRosterSwapResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterSwapResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterSwapResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::set_result(::CMsgDOTAFantasyTeamRosterSwapResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterSwapResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterAddDropRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterAddDropRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterAddDropRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_has_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterAddDropRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterAddDropRequest.team_index)
}

// optional uint32 add_account_id = 5;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_add_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_has_add_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_has_add_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_add_account_id() {
  add_account_id_ = 0u;
  clear_has_add_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::add_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterAddDropRequest.add_account_id)
  return add_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_add_account_id(::google::protobuf::uint32 value) {
  set_has_add_account_id();
  add_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterAddDropRequest.add_account_id)
}

// optional uint32 drop_account_id = 6;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_drop_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_has_drop_account_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_has_drop_account_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_drop_account_id() {
  drop_account_id_ = 0u;
  clear_has_drop_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::drop_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterAddDropRequest.drop_account_id)
  return drop_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_drop_account_id(::google::protobuf::uint32 value) {
  set_has_drop_account_id();
  drop_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterAddDropRequest.drop_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterAddDropResponse

// optional .CMsgDOTAFantasyTeamRosterAddDropResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterAddDropResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterAddDropResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::set_result(::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterAddDropResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamTradesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamTradesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesResponse_Trade

// optional uint32 timestamp = 1;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.timestamp)
}

// optional uint32 owner_account_id_1 = 2;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_owner_account_id_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_owner_account_id_1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_owner_account_id_1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_owner_account_id_1() {
  owner_account_id_1_ = 0u;
  clear_has_owner_account_id_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::owner_account_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_1)
  return owner_account_id_1_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_owner_account_id_1(::google::protobuf::uint32 value) {
  set_has_owner_account_id_1();
  owner_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_1)
}

// optional uint32 owner_account_id_2 = 3;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_owner_account_id_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_owner_account_id_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  clear_has_owner_account_id_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_owner_account_id_2(::google::protobuf::uint32 value) {
  set_has_owner_account_id_2();
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_2)
}

// optional uint32 player_account_id_1 = 4;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_player_account_id_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_player_account_id_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_player_account_id_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_player_account_id_1() {
  player_account_id_1_ = 0u;
  clear_has_player_account_id_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::player_account_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_1)
  return player_account_id_1_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_player_account_id_1(::google::protobuf::uint32 value) {
  set_has_player_account_id_1();
  player_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_1)
}

// optional uint32 player_account_id_2 = 5;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_player_account_id_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_player_account_id_2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_player_account_id_2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_player_account_id_2() {
  player_account_id_2_ = 0u;
  clear_has_player_account_id_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::player_account_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_2)
  return player_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_player_account_id_2(::google::protobuf::uint32 value) {
  set_has_player_account_id_2();
  player_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_2)
}

// optional uint32 status = 6;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::status() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.Trade.status)
  return status_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.Trade.status)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesResponse

// optional .CMsgDOTAFantasyTeamTradesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamTradesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradesResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamTradesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamTradesResponse::set_result(::CMsgDOTAFantasyTeamTradesResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradesResponse.result)
}

// repeated .CMsgDOTAFantasyTeamTradesResponse.Trade trades = 2;
inline int CMsgDOTAFantasyTeamTradesResponse::trades_size() const {
  return trades_.size();
}
inline void CMsgDOTAFantasyTeamTradesResponse::clear_trades() {
  trades_.Clear();
}
inline const ::CMsgDOTAFantasyTeamTradesResponse_Trade& CMsgDOTAFantasyTeamTradesResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Get(index);
}
inline ::CMsgDOTAFantasyTeamTradesResponse_Trade* CMsgDOTAFantasyTeamTradesResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Mutable(index);
}
inline ::CMsgDOTAFantasyTeamTradesResponse_Trade* CMsgDOTAFantasyTeamTradesResponse::add_trades() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamTradesResponse_Trade >&
CMsgDOTAFantasyTeamTradesResponse::trades() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyTeamTradesResponse_Trade >*
CMsgDOTAFantasyTeamTradesResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamTradesResponse.trades)
  return &trades_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradeCancelRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradeCancelRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradeCancelRequest.fantasy_league_id)
}

// optional uint32 team_index_1 = 3;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_team_index_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_has_team_index_1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_has_team_index_1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_team_index_1() {
  team_index_1_ = 0u;
  clear_has_team_index_1();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::team_index_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradeCancelRequest.team_index_1)
  return team_index_1_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_team_index_1(::google::protobuf::uint32 value) {
  set_has_team_index_1();
  team_index_1_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradeCancelRequest.team_index_1)
}

// optional uint32 owner_account_id_2 = 4;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_has_owner_account_id_2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_has_owner_account_id_2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  clear_has_owner_account_id_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradeCancelRequest.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_owner_account_id_2(::google::protobuf::uint32 value) {
  set_has_owner_account_id_2();
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradeCancelRequest.owner_account_id_2)
}

// optional uint32 team_index_2 = 5;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_team_index_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_has_team_index_2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_has_team_index_2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_team_index_2() {
  team_index_2_ = 0u;
  clear_has_team_index_2();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::team_index_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradeCancelRequest.team_index_2)
  return team_index_2_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_team_index_2(::google::protobuf::uint32 value) {
  set_has_team_index_2();
  team_index_2_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradeCancelRequest.team_index_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradeCancelResponse

// optional .CMsgDOTAFantasyTeamTradeCancelResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamTradeCancelResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamTradeCancelResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::set_result(::CMsgDOTAFantasyTeamTradeCancelResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamTradeCancelResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_has_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterRequest.team_index)
}

// optional uint32 owner_account_id = 3;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterRequest.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterRequest.owner_account_id)
}

// optional uint32 timestamp = 4;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterRequest.timestamp)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterResponse

// optional .CMsgDOTAFantasyTeamRosterResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterResponse.result)
  return static_cast< ::CMsgDOTAFantasyTeamRosterResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_result(::CMsgDOTAFantasyTeamRosterResponse_EResult value) {
  assert(::CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterResponse.result)
}

// repeated uint32 player_account_ids = 2;
inline int CMsgDOTAFantasyTeamRosterResponse::player_account_ids_size() const {
  return player_account_ids_.size();
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_player_account_ids() {
  player_account_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterResponse::player_account_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return player_account_ids_.Get(index);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_player_account_ids(int index, ::google::protobuf::uint32 value) {
  player_account_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
}
inline void CMsgDOTAFantasyTeamRosterResponse::add_player_account_ids(::google::protobuf::uint32 value) {
  player_account_ids_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyTeamRosterResponse::player_account_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return player_account_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyTeamRosterResponse::mutable_player_account_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return &player_account_ids_;
}

// repeated bool player_locked = 3;
inline int CMsgDOTAFantasyTeamRosterResponse::player_locked_size() const {
  return player_locked_.size();
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_player_locked() {
  player_locked_.Clear();
}
inline bool CMsgDOTAFantasyTeamRosterResponse::player_locked(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return player_locked_.Get(index);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_player_locked(int index, bool value) {
  player_locked_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyTeamRosterResponse.player_locked)
}
inline void CMsgDOTAFantasyTeamRosterResponse::add_player_locked(bool value) {
  player_locked_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyTeamRosterResponse.player_locked)
}
inline const ::google::protobuf::RepeatedField< bool >&
CMsgDOTAFantasyTeamRosterResponse::player_locked() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return player_locked_;
}
inline ::google::protobuf::RepeatedField< bool >*
CMsgDOTAFantasyTeamRosterResponse::mutable_player_locked() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return &player_locked_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator

// optional uint32 matches = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_matches() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_matches() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_matches() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_matches() {
  matches_ = 0u;
  clear_has_matches();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::matches() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.matches)
  return matches_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_matches(::google::protobuf::uint32 value) {
  set_has_matches();
  matches_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.matches)
}

// optional float levels = 2;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_levels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_levels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_levels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_levels() {
  levels_ = 0;
  clear_has_levels();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::levels() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.levels)
  return levels_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_levels(float value) {
  set_has_levels();
  levels_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.levels)
}

// optional float kills = 3;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_kills() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_kills() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_kills() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_kills() {
  kills_ = 0;
  clear_has_kills();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.kills)
  return kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_kills(float value) {
  set_has_kills();
  kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.kills)
}

// optional float deaths = 4;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_deaths() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_deaths() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_deaths() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_deaths() {
  deaths_ = 0;
  clear_has_deaths();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::deaths() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.deaths)
  return deaths_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_deaths(float value) {
  set_has_deaths();
  deaths_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.deaths)
}

// optional float assists = 5;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_assists() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_assists() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_assists() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_assists() {
  assists_ = 0;
  clear_has_assists();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::assists() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.assists)
  return assists_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_assists(float value) {
  set_has_assists();
  assists_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.assists)
}

// optional float last_hits = 6;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_last_hits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_last_hits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_last_hits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_last_hits() {
  last_hits_ = 0;
  clear_has_last_hits();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::last_hits() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.last_hits)
  return last_hits_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_last_hits(float value) {
  set_has_last_hits();
  last_hits_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.last_hits)
}

// optional float denies = 7;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_denies() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_denies() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_denies() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_denies() {
  denies_ = 0;
  clear_has_denies();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::denies() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.denies)
  return denies_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_denies(float value) {
  set_has_denies();
  denies_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.denies)
}

// optional float gpm = 8;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_gpm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_gpm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_gpm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_gpm() {
  gpm_ = 0;
  clear_has_gpm();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::gpm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.gpm)
  return gpm_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_gpm(float value) {
  set_has_gpm();
  gpm_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.gpm)
}

// optional float xppm = 9;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_xppm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_xppm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_xppm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_xppm() {
  xppm_ = 0;
  clear_has_xppm();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::xppm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.xppm)
  return xppm_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_xppm(float value) {
  set_has_xppm();
  xppm_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.xppm)
}

// optional float stuns = 10;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_stuns() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_stuns() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_stuns() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_stuns() {
  stuns_ = 0;
  clear_has_stuns();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::stuns() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.stuns)
  return stuns_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_stuns(float value) {
  set_has_stuns();
  stuns_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.stuns)
}

// optional float healing = 11;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_healing() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_healing() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_healing() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_healing() {
  healing_ = 0;
  clear_has_healing();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::healing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.healing)
  return healing_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_healing(float value) {
  set_has_healing();
  healing_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.healing)
}

// optional float tower_kills = 12;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_tower_kills() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_tower_kills() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_tower_kills() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_tower_kills() {
  tower_kills_ = 0;
  clear_has_tower_kills();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::tower_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.tower_kills)
  return tower_kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_tower_kills(float value) {
  set_has_tower_kills();
  tower_kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.tower_kills)
}

// optional float roshan_kills = 13;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_roshan_kills() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_roshan_kills() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_roshan_kills() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_roshan_kills() {
  roshan_kills_ = 0;
  clear_has_roshan_kills();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::roshan_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.roshan_kills)
  return roshan_kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_roshan_kills(float value) {
  set_has_roshan_kills();
  roshan_kills_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.roshan_kills)
}

// optional float score = 14;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_score() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_has_score() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_has_score() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.account_id)
}

// optional uint32 weeks = 2;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_weeks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_has_weeks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_has_weeks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_weeks() {
  weeks_ = 0u;
  clear_has_weeks();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::weeks() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.weeks)
  return weeks_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_weeks(::google::protobuf::uint32 value) {
  set_has_weeks();
  weeks_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.weeks)
}

// optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_premium = 4;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_stats_premium() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_has_stats_premium() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_has_stats_premium() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_stats_premium() {
  if (stats_premium_ != NULL) stats_premium_->::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::Clear();
  clear_has_stats_premium();
}
inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::stats_premium() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
  return stats_premium_ != NULL ? *stats_premium_ : *default_instance_->stats_premium_;
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mutable_stats_premium() {
  set_has_stats_premium();
  if (stats_premium_ == NULL) stats_premium_ = new ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator;
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
  return stats_premium_;
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::release_stats_premium() {
  clear_has_stats_premium();
  ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* temp = stats_premium_;
  stats_premium_ = NULL;
  return temp;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_allocated_stats_premium(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium) {
  delete stats_premium_;
  stats_premium_ = stats_premium;
  if (stats_premium) {
    set_has_stats_premium();
  } else {
    clear_has_stats_premium();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
}

// optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_professional = 5;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_stats_professional() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_has_stats_professional() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_has_stats_professional() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_stats_professional() {
  if (stats_professional_ != NULL) stats_professional_->::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::Clear();
  clear_has_stats_professional();
}
inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::stats_professional() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
  return stats_professional_ != NULL ? *stats_professional_ : *default_instance_->stats_professional_;
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mutable_stats_professional() {
  set_has_stats_professional();
  if (stats_professional_ == NULL) stats_professional_ = new ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator;
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
  return stats_professional_;
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::release_stats_professional() {
  clear_has_stats_professional();
  ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* temp = stats_professional_;
  stats_professional_ = NULL;
  return temp;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_allocated_stats_professional(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional) {
  delete stats_professional_;
  stats_professional_ = stats_professional;
  if (stats_professional) {
    set_has_stats_professional();
  } else {
    clear_has_stats_professional();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse

// optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.result)
  return static_cast< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::set_result(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value) {
  assert(::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerHisoricalStatsResponse.result)
}

// repeated .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats stats = 2;
inline int CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats_size() const {
  return stats_.size();
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::clear_stats() {
  stats_.Clear();
}
inline const ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Get(index);
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* CMsgDOTAFantasyPlayerHisoricalStatsResponse::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Mutable(index);
}
inline ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* CMsgDOTAFantasyPlayerHisoricalStatsResponse::add_stats() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >&
CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >*
CMsgDOTAFantasyPlayerHisoricalStatsResponse::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return &stats_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessageAdd

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyMessageAdd::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessageAdd::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyMessageAdd::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyMessageAdd::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessageAdd::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessageAdd.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyMessageAdd::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessageAdd.fantasy_league_id)
}

// optional string message = 2;
inline bool CMsgDOTAFantasyMessageAdd::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessageAdd::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyMessageAdd::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyMessageAdd::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgDOTAFantasyMessageAdd::message() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessageAdd.message)
  return *message_;
}
inline void CMsgDOTAFantasyMessageAdd::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessageAdd.message)
}
inline void CMsgDOTAFantasyMessageAdd::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyMessageAdd.message)
}
inline void CMsgDOTAFantasyMessageAdd::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyMessageAdd.message)
}
inline ::std::string* CMsgDOTAFantasyMessageAdd::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyMessageAdd.message)
  return message_;
}
inline ::std::string* CMsgDOTAFantasyMessageAdd::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyMessageAdd::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyMessageAdd.message)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyMessagesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesRequest.fantasy_league_id)
}

// optional uint32 start_message = 2;
inline bool CMsgDOTAFantasyMessagesRequest::has_start_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::set_has_start_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_has_start_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_start_message() {
  start_message_ = 0u;
  clear_has_start_message();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::start_message() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesRequest.start_message)
  return start_message_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_start_message(::google::protobuf::uint32 value) {
  set_has_start_message();
  start_message_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesRequest.start_message)
}

// optional uint32 end_message = 3;
inline bool CMsgDOTAFantasyMessagesRequest::has_end_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::set_has_end_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_has_end_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_end_message() {
  end_message_ = 0u;
  clear_has_end_message();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::end_message() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesRequest.end_message)
  return end_message_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_end_message(::google::protobuf::uint32 value) {
  set_has_end_message();
  end_message_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesRequest.end_message)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesResponse_Message

// optional uint32 message_id = 1;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_message_id() {
  message_id_ = 0u;
  clear_has_message_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::message_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.Message.message_id)
  return message_id_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message_id(::google::protobuf::uint32 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.Message.message_id)
}

// optional string message = 2;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CMsgDOTAFantasyMessagesResponse_Message::message() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.Message.message)
  return *message_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.Message.message)
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyMessagesResponse.Message.message)
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyMessagesResponse.Message.message)
}
inline ::std::string* CMsgDOTAFantasyMessagesResponse_Message::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyMessagesResponse.Message.message)
  return message_;
}
inline ::std::string* CMsgDOTAFantasyMessagesResponse_Message::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyMessagesResponse.Message.message)
}

// optional uint32 author_account_id = 3;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_author_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_has_author_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_has_author_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_author_account_id() {
  author_account_id_ = 0u;
  clear_has_author_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::author_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.Message.author_account_id)
  return author_account_id_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_author_account_id(::google::protobuf::uint32 value) {
  set_has_author_account_id();
  author_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.Message.author_account_id)
}

// optional uint32 time = 4;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.Message.time)
  return time_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.Message.time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesResponse

// optional .CMsgDOTAFantasyMessagesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyMessagesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.result)
  return static_cast< ::CMsgDOTAFantasyMessagesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyMessagesResponse::set_result(::CMsgDOTAFantasyMessagesResponse_EResult value) {
  assert(::CMsgDOTAFantasyMessagesResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.result)
}

// repeated .CMsgDOTAFantasyMessagesResponse.Message messages = 2;
inline int CMsgDOTAFantasyMessagesResponse::messages_size() const {
  return messages_.size();
}
inline void CMsgDOTAFantasyMessagesResponse::clear_messages() {
  messages_.Clear();
}
inline const ::CMsgDOTAFantasyMessagesResponse_Message& CMsgDOTAFantasyMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Get(index);
}
inline ::CMsgDOTAFantasyMessagesResponse_Message* CMsgDOTAFantasyMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Mutable(index);
}
inline ::CMsgDOTAFantasyMessagesResponse_Message* CMsgDOTAFantasyMessagesResponse::add_messages() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyMessagesResponse_Message >&
CMsgDOTAFantasyMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyMessagesResponse.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyMessagesResponse_Message >*
CMsgDOTAFantasyMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyMessagesResponse.messages)
  return &messages_;
}

// optional uint32 num_total_messages = 3;
inline bool CMsgDOTAFantasyMessagesResponse::has_num_total_messages() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse::set_has_num_total_messages() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_has_num_total_messages() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_num_total_messages() {
  num_total_messages_ = 0u;
  clear_has_num_total_messages();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse::num_total_messages() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyMessagesResponse.num_total_messages)
  return num_total_messages_;
}
inline void CMsgDOTAFantasyMessagesResponse::set_num_total_messages(::google::protobuf::uint32 value) {
  set_has_num_total_messages();
  num_total_messages_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyMessagesResponse.num_total_messages)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyRemoveOwner

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyRemoveOwner::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyRemoveOwner.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyRemoveOwner.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyRemoveOwner::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::set_has_owner_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_has_owner_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_owner_account_id() {
  owner_account_id_ = 0u;
  clear_has_owner_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::owner_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyRemoveOwner.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_owner_account_id(::google::protobuf::uint32 value) {
  set_has_owner_account_id();
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyRemoveOwner.owner_account_id)
}

// optional uint32 team_index = 3;
inline bool CMsgDOTAFantasyRemoveOwner::has_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::set_has_team_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_has_team_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_team_index() {
  team_index_ = 0u;
  clear_has_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyRemoveOwner.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_team_index(::google::protobuf::uint32 value) {
  set_has_team_index();
  team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyRemoveOwner.team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyRemoveOwnerResponse

// optional .CMsgDOTAFantasyRemoveOwnerResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyRemoveOwnerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyRemoveOwnerResponse.result)
  return static_cast< ::CMsgDOTAFantasyRemoveOwnerResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::set_result(::CMsgDOTAFantasyRemoveOwnerResponse_EResult value) {
  assert(::CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyRemoveOwnerResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyScheduledMatchesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyScheduledMatchesRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays

// optional uint32 timestamp = 1;
inline bool CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.timestamp)
}

// repeated uint32 team_ids = 2;
inline int CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids_size() const {
  return team_ids_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_team_ids() {
  team_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return team_ids_.Get(index);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_team_ids(int index, ::google::protobuf::uint32 value) {
  team_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::add_team_ids(::google::protobuf::uint32 value) {
  team_ids_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return team_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mutable_team_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return &team_ids_;
}

// repeated uint32 league_ids = 3;
inline int CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids_size() const {
  return league_ids_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_league_ids() {
  league_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return league_ids_.Get(index);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_league_ids(int index, ::google::protobuf::uint32 value) {
  league_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::add_league_ids(::google::protobuf::uint32 value) {
  league_ids_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return league_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mutable_league_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return &league_ids_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesResponse

// optional .CMsgDOTAFantasyScheduledMatchesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyScheduledMatchesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesResponse.result)
  return static_cast< ::CMsgDOTAFantasyScheduledMatchesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::set_result(::CMsgDOTAFantasyScheduledMatchesResponse_EResult value) {
  assert(::CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyScheduledMatchesResponse.result)
}

// repeated .CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays scheduled_match_days = 2;
inline int CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days_size() const {
  return scheduled_match_days_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::clear_scheduled_match_days() {
  scheduled_match_days_.Clear();
}
inline const ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Get(index);
}
inline ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* CMsgDOTAFantasyScheduledMatchesResponse::mutable_scheduled_match_days(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Mutable(index);
}
inline ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* CMsgDOTAFantasyScheduledMatchesResponse::add_scheduled_match_days() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >&
CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >*
CMsgDOTAFantasyScheduledMatchesResponse::mutable_scheduled_match_days() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return &scheduled_match_days_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeaveLeagueRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeaveLeagueRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeaveLeagueRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeaveLeagueRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeaveLeagueRequest.fantasy_league_id)
}

// optional uint32 fantasy_team_index = 2;
inline bool CMsgDOTAFantasyLeaveLeagueRequest::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_has_fantasy_team_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_has_fantasy_team_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  clear_has_fantasy_team_index();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeaveLeagueRequest::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeaveLeagueRequest.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_fantasy_team_index(::google::protobuf::uint32 value) {
  set_has_fantasy_team_index();
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeaveLeagueRequest.fantasy_team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeaveLeagueResponse

// optional .CMsgDOTAFantasyLeaveLeagueResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeaveLeagueResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyLeaveLeagueResponse.result)
  return static_cast< ::CMsgDOTAFantasyLeaveLeagueResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::set_result(::CMsgDOTAFantasyLeaveLeagueResponse_EResult value) {
  assert(::CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyLeaveLeagueResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_has_fantasy_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_has_fantasy_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  clear_has_fantasy_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  set_has_fantasy_league_id();
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsRequest.fantasy_league_id)
}

// optional uint32 player_account_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_has_player_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_has_player_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  clear_has_player_account_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_player_account_id(::google::protobuf::uint32 value) {
  set_has_player_account_id();
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsRequest.player_account_id)
}

// optional uint32 start_time = 3;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsRequest.start_time)
  return start_time_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsRequest.start_time)
}

// optional uint32 end_time = 4;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsRequest.end_time)
  return end_time_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsRequest.end_time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData

// optional uint64 match_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_match_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_match_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_match_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_match_id() {
  match_id_ = GOOGLE_ULONGLONG(0);
  clear_has_match_id();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.match_id)
  return match_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_match_id(::google::protobuf::uint64 value) {
  set_has_match_id();
  match_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.match_id)
}

// optional uint32 series_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_series_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_series_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_id() {
  series_id_ = 0u;
  clear_has_series_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_id)
  return series_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_id(::google::protobuf::uint32 value) {
  set_has_series_id();
  series_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_id)
}

// optional uint32 series_num = 3;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_series_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_series_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_num() {
  series_num_ = 0u;
  clear_has_series_num();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_num() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_num)
  return series_num_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_num(::google::protobuf::uint32 value) {
  set_has_series_num();
  series_num_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_num)
}

// optional uint32 series_type = 4;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_series_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_series_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_type() {
  series_type_ = 0u;
  clear_has_series_type();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_type)
  return series_type_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_type(::google::protobuf::uint32 value) {
  set_has_series_type();
  series_type_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_type)
}

// optional uint32 league_tier = 5;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_league_tier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_league_tier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_league_tier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_league_tier() {
  league_tier_ = 0u;
  clear_has_league_tier();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::league_tier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_tier)
  return league_tier_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_league_tier(::google::protobuf::uint32 value) {
  set_has_league_tier();
  league_tier_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_tier)
}

// optional uint32 league_id = 6;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_league_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_league_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_league_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_league_id() {
  league_id_ = 0u;
  clear_has_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_id)
  return league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_league_id(::google::protobuf::uint32 value) {
  set_has_league_id();
  league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_id)
}

// optional uint32 opposing_team_id = 7;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_opposing_team_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_opposing_team_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_id() {
  opposing_team_id_ = 0u;
  clear_has_opposing_team_id();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_id)
  return opposing_team_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_id(::google::protobuf::uint32 value) {
  set_has_opposing_team_id();
  opposing_team_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_id)
}

// optional uint64 opposing_team_logo = 8;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_logo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_opposing_team_logo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_opposing_team_logo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_logo() {
  opposing_team_logo_ = GOOGLE_ULONGLONG(0);
  clear_has_opposing_team_logo();
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_logo)
  return opposing_team_logo_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_logo(::google::protobuf::uint64 value) {
  set_has_opposing_team_logo();
  opposing_team_logo_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_logo)
}

// optional string opposing_team_name = 9;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_opposing_team_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_opposing_team_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_name() {
  if (opposing_team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opposing_team_name_->clear();
  }
  clear_has_opposing_team_name();
}
inline const ::std::string& CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
  return *opposing_team_name_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const ::std::string& value) {
  set_has_opposing_team_name();
  if (opposing_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opposing_team_name_ = new ::std::string;
  }
  opposing_team_name_->assign(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const char* value) {
  set_has_opposing_team_name();
  if (opposing_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opposing_team_name_ = new ::std::string;
  }
  opposing_team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const char* value, size_t size) {
  set_has_opposing_team_name();
  if (opposing_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opposing_team_name_ = new ::std::string;
  }
  opposing_team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mutable_opposing_team_name() {
  set_has_opposing_team_name();
  if (opposing_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opposing_team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
  return opposing_team_name_;
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::release_opposing_team_name() {
  clear_has_opposing_team_name();
  if (opposing_team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = opposing_team_name_;
    opposing_team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_allocated_opposing_team_name(::std::string* opposing_team_name) {
  if (opposing_team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opposing_team_name_;
  }
  if (opposing_team_name) {
    set_has_opposing_team_name();
    opposing_team_name_ = opposing_team_name;
  } else {
    clear_has_opposing_team_name();
    opposing_team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}

// optional uint32 owned_by = 11;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_owned_by() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_owned_by() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_owned_by() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_owned_by() {
  owned_by_ = 0u;
  clear_has_owned_by();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::owned_by() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.owned_by)
  return owned_by_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_owned_by(::google::protobuf::uint32 value) {
  set_has_owned_by();
  owned_by_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.owned_by)
}

// optional bool benched = 12;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_benched() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_has_benched() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_has_benched() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_benched() {
  benched_ = false;
  clear_has_benched();
}
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::benched() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.benched)
  return benched_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_benched(bool value) {
  set_has_benched();
  benched_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.benched)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsResponse

// optional .CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.result)
  return static_cast< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::set_result(::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value) {
  assert(::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAFantasyPlayerScoreDetailsResponse.result)
}

// repeated .CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData data = 2;
inline int CMsgDOTAFantasyPlayerScoreDetailsResponse::data_size() const {
  return data_.size();
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::clear_data() {
  data_.Clear();
}
inline const ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& CMsgDOTAFantasyPlayerScoreDetailsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Get(index);
}
inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* CMsgDOTAFantasyPlayerScoreDetailsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Mutable(index);
}
inline ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* CMsgDOTAFantasyPlayerScoreDetailsResponse::add_data() {
  // @@protoc_insertion_point(field_add:CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >&
CMsgDOTAFantasyPlayerScoreDetailsResponse::data() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >*
CMsgDOTAFantasyPlayerScoreDetailsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return &data_;
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVoteTeamGuess

// optional uint32 league_id = 1;
inline bool CMsgDOTAPassportVoteTeamGuess::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_has_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_has_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_league_id() {
  league_id_ = 0u;
  clear_has_league_id();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVoteTeamGuess.league_id)
  return league_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_league_id(::google::protobuf::uint32 value) {
  set_has_league_id();
  league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportVoteTeamGuess.league_id)
}

// optional uint32 winner_id = 2;
inline bool CMsgDOTAPassportVoteTeamGuess::has_winner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_has_winner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_has_winner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_winner_id() {
  winner_id_ = 0u;
  clear_has_winner_id();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::winner_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVoteTeamGuess.winner_id)
  return winner_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_winner_id(::google::protobuf::uint32 value) {
  set_has_winner_id();
  winner_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportVoteTeamGuess.winner_id)
}

// optional uint32 runnerup_id = 3;
inline bool CMsgDOTAPassportVoteTeamGuess::has_runnerup_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_has_runnerup_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_has_runnerup_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_runnerup_id() {
  runnerup_id_ = 0u;
  clear_has_runnerup_id();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::runnerup_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVoteTeamGuess.runnerup_id)
  return runnerup_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_runnerup_id(::google::protobuf::uint32 value) {
  set_has_runnerup_id();
  runnerup_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportVoteTeamGuess.runnerup_id)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVoteGenericSelection

// optional .DOTA_2013PassportSelectionIndices selection_index = 1 [default = PP13_SEL_ALLSTAR_PLAYER_0];
inline bool CMsgDOTAPassportVoteGenericSelection::has_selection_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportVoteGenericSelection::set_has_selection_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_has_selection_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_selection_index() {
  selection_index_ = 0;
  clear_has_selection_index();
}
inline ::DOTA_2013PassportSelectionIndices CMsgDOTAPassportVoteGenericSelection::selection_index() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVoteGenericSelection.selection_index)
  return static_cast< ::DOTA_2013PassportSelectionIndices >(selection_index_);
}
inline void CMsgDOTAPassportVoteGenericSelection::set_selection_index(::DOTA_2013PassportSelectionIndices value) {
  assert(::DOTA_2013PassportSelectionIndices_IsValid(value));
  set_has_selection_index();
  selection_index_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportVoteGenericSelection.selection_index)
}

// optional uint32 selection = 2;
inline bool CMsgDOTAPassportVoteGenericSelection::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportVoteGenericSelection::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_selection() {
  selection_ = 0u;
  clear_has_selection();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteGenericSelection::selection() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVoteGenericSelection.selection)
  return selection_;
}
inline void CMsgDOTAPassportVoteGenericSelection::set_selection(::google::protobuf::uint32 value) {
  set_has_selection();
  selection_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportVoteGenericSelection.selection)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportStampedPlayer

// optional uint64 steam_id = 1;
inline bool CMsgDOTAPassportStampedPlayer::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportStampedPlayer::set_has_steam_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAPassportStampedPlayer::clear_has_steam_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAPassportStampedPlayer::clear_steam_id() {
  steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_steam_id();
}
inline ::google::protobuf::uint64 CMsgDOTAPassportStampedPlayer::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportStampedPlayer.steam_id)
  return steam_id_;
}
inline void CMsgDOTAPassportStampedPlayer::set_steam_id(::google::protobuf::uint64 value) {
  set_has_steam_id();
  steam_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportStampedPlayer.steam_id)
}

// optional uint32 stamp_level = 2;
inline bool CMsgDOTAPassportStampedPlayer::has_stamp_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportStampedPlayer::set_has_stamp_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgDOTAPassportStampedPlayer::clear_has_stamp_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgDOTAPassportStampedPlayer::clear_stamp_level() {
  stamp_level_ = 0u;
  clear_has_stamp_level();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportStampedPlayer::stamp_level() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportStampedPlayer.stamp_level)
  return stamp_level_;
}
inline void CMsgDOTAPassportStampedPlayer::set_stamp_level(::google::protobuf::uint32 value) {
  set_has_stamp_level();
  stamp_level_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportStampedPlayer.stamp_level)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportPlayerCardChallenge

// optional uint32 challenge_id = 1;
inline bool CMsgDOTAPassportPlayerCardChallenge::has_challenge_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportPlayerCardChallenge::set_has_challenge_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgDOTAPassportPlayerCardChallenge::clear_has_challenge_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgDOTAPassportPlayerCardChallenge::clear_challenge_id() {
  challenge_id_ = 0u;
  clear_has_challenge_id();
}
inline ::google::protobuf::uint32 CMsgDOTAPassportPlayerCardChallenge::challenge_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportPlayerCardChallenge.challenge_id)
  return challenge_id_;
}
inline void CMsgDOTAPassportPlayerCardChallenge::set_challenge_id(::google::protobuf::uint32 value) {
  set_has_challenge_id();
  challenge_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgDOTAPassportPlayerCardChallenge.challenge_id)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVote

// repeated .CMsgDOTAPassportVoteTeamGuess team_votes = 1;
inline int CMsgDOTAPassportVote::team_votes_size() const {
  return team_votes_.size();
}
inline void CMsgDOTAPassportVote::clear_team_votes() {
  team_votes_.Clear();
}
inline const ::CMsgDOTAPassportVoteTeamGuess& CMsgDOTAPassportVote::team_votes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVote.team_votes)
  return team_votes_.Get(index);
}
inline ::CMsgDOTAPassportVoteTeamGuess* CMsgDOTAPassportVote::mutable_team_votes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAPassportVote.team_votes)
  return team_votes_.Mutable(index);
}
inline ::CMsgDOTAPassportVoteTeamGuess* CMsgDOTAPassportVote::add_team_votes() {
  // @@protoc_insertion_point(field_add:CMsgDOTAPassportVote.team_votes)
  return team_votes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteTeamGuess >&
CMsgDOTAPassportVote::team_votes() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAPassportVote.team_votes)
  return team_votes_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteTeamGuess >*
CMsgDOTAPassportVote::mutable_team_votes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAPassportVote.team_votes)
  return &team_votes_;
}

// repeated .CMsgDOTAPassportVoteGenericSelection generic_selections = 2;
inline int CMsgDOTAPassportVote::generic_selections_size() const {
  return generic_selections_.size();
}
inline void CMsgDOTAPassportVote::clear_generic_selections() {
  generic_selections_.Clear();
}
inline const ::CMsgDOTAPassportVoteGenericSelection& CMsgDOTAPassportVote::generic_selections(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Get(index);
}
inline ::CMsgDOTAPassportVoteGenericSelection* CMsgDOTAPassportVote::mutable_generic_selections(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Mutable(index);
}
inline ::CMsgDOTAPassportVoteGenericSelection* CMsgDOTAPassportVote::add_generic_selections() {
  // @@protoc_insertion_point(field_add:CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteGenericSelection >&
CMsgDOTAPassportVote::generic_selections() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAPassportVote.generic_selections)
  return generic_selections_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportVoteGenericSelection >*
CMsgDOTAPassportVote::mutable_generic_selections() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAPassportVote.generic_selections)
  return &generic_selections_;
}

// repeated .CMsgDOTAPassportStampedPlayer stamped_players = 3;
inline int CMsgDOTAPassportVote::stamped_players_size() const {
  return stamped_players_.size();
}
inline void CMsgDOTAPassportVote::clear_stamped_players() {
  stamped_players_.Clear();
}
inline const ::CMsgDOTAPassportStampedPlayer& CMsgDOTAPassportVote::stamped_players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Get(index);
}
inline ::CMsgDOTAPassportStampedPlayer* CMsgDOTAPassportVote::mutable_stamped_players(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Mutable(index);
}
inline ::CMsgDOTAPassportStampedPlayer* CMsgDOTAPassportVote::add_stamped_players() {
  // @@protoc_insertion_point(field_add:CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportStampedPlayer >&
CMsgDOTAPassportVote::stamped_players() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAPassportVote.stamped_players)
  return stamped_players_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportStampedPlayer >*
CMsgDOTAPassportVote::mutable_stamped_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAPassportVote.stamped_players)
  return &stamped_players_;
}

// repeated .CMsgDOTAPassportPlayerCardChallenge player_card_challenges = 4;
inline int CMsgDOTAPassportVote::player_card_challenges_size() const {
  return player_card_challenges_.size();
}
inline void CMsgDOTAPassportVote::clear_player_card_challenges() {
  player_card_challenges_.Clear();
}
inline const ::CMsgDOTAPassportPlayerCardChallenge& CMsgDOTAPassportVote::player_card_challenges(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Get(index);
}
inline ::CMsgDOTAPassportPlayerCardChallenge* CMsgDOTAPassportVote::mutable_player_card_challenges(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Mutable(index);
}
inline ::CMsgDOTAPassportPlayerCardChallenge* CMsgDOTAPassportVote::add_player_card_challenges() {
  // @@protoc_insertion_point(field_add:CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportPlayerCardChallenge >&
CMsgDOTAPassportVote::player_card_challenges() const {
  // @@protoc_insertion_point(field_list:CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_;
}
inline ::google::protobuf::RepeatedPtrField< ::CMsgDOTAPassportPlayerCardChallenge >*
CMsgDOTAPassportVote::mutable_player_card_challenges() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTAPassportVote.player_card_challenges)
  return &player_card_challenges_;
}

// -------------------------------------------------------------------

// CMsgClientToGCGetPlayerCardRosterRequest

// optional uint32 league_id = 1;
inline bool CMsgClientToGCGetPlayerCardRosterRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_has_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_has_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_league_id() {
  league_id_ = 0u;
  clear_has_league_id();
}
inline ::google::protobuf::uint32 CMsgClientToGCGetPlayerCardRosterRequest::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterRequest.league_id)
  return league_id_;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_league_id(::google::protobuf::uint32 value) {
  set_has_league_id();
  league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterRequest.league_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgClientToGCGetPlayerCardRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgClientToGCGetPlayerCardRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterRequest.timestamp)
}

// -------------------------------------------------------------------

// CMsgClientToGCGetPlayerCardRosterResponse

// optional .CMsgClientToGCGetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterResponse.result)
  return static_cast< ::CMsgClientToGCGetPlayerCardRosterResponse_Result >(result_);
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_result(::CMsgClientToGCGetPlayerCardRosterResponse_Result value) {
  assert(::CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterResponse.result)
}

// repeated uint64 player_card_item_id = 2;
inline int CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id_size() const {
  return player_card_item_id_.size();
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_player_card_item_id() {
  player_card_item_id_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id(int index) const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return player_card_item_id_.Get(index);
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_player_card_item_id(int index, ::google::protobuf::uint64 value) {
  player_card_item_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::add_player_card_item_id(::google::protobuf::uint64 value) {
  player_card_item_id_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id() const {
  // @@protoc_insertion_point(field_list:CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return player_card_item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientToGCGetPlayerCardRosterResponse::mutable_player_card_item_id() {
  // @@protoc_insertion_point(field_mutable_list:CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return &player_card_item_id_;
}

// optional float score = 3;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float CMsgClientToGCGetPlayerCardRosterResponse::score() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterResponse.score)
  return score_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterResponse.score)
}

// optional bool finalized = 4;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_finalized() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_has_finalized() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_has_finalized() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_finalized() {
  finalized_ = false;
  clear_has_finalized();
}
inline bool CMsgClientToGCGetPlayerCardRosterResponse::finalized() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterResponse.finalized)
  return finalized_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_finalized(bool value) {
  set_has_finalized();
  finalized_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterResponse.finalized)
}

// optional float percentile = 5;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_percentile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_has_percentile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_has_percentile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_percentile() {
  percentile_ = 0;
  clear_has_percentile();
}
inline float CMsgClientToGCGetPlayerCardRosterResponse::percentile() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCGetPlayerCardRosterResponse.percentile)
  return percentile_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_percentile(float value) {
  set_has_percentile();
  percentile_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCGetPlayerCardRosterResponse.percentile)
}

// -------------------------------------------------------------------

// CMsgClientToGCSetPlayerCardRosterRequest

// optional uint32 league_id = 1;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_has_league_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_has_league_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_league_id() {
  league_id_ = 0u;
  clear_has_league_id();
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCSetPlayerCardRosterRequest.league_id)
  return league_id_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_league_id(::google::protobuf::uint32 value) {
  set_has_league_id();
  league_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCSetPlayerCardRosterRequest.league_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCSetPlayerCardRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCSetPlayerCardRosterRequest.timestamp)
}

// optional uint32 slot = 3;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_has_slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_has_slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_slot() {
  slot_ = 0u;
  clear_has_slot();
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::slot() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCSetPlayerCardRosterRequest.slot)
  return slot_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_slot(::google::protobuf::uint32 value) {
  set_has_slot();
  slot_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCSetPlayerCardRosterRequest.slot)
}

// optional uint64 player_card_item_id = 4;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_player_card_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_has_player_card_item_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_has_player_card_item_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_player_card_item_id() {
  player_card_item_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_card_item_id();
}
inline ::google::protobuf::uint64 CMsgClientToGCSetPlayerCardRosterRequest::player_card_item_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCSetPlayerCardRosterRequest.player_card_item_id)
  return player_card_item_id_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_player_card_item_id(::google::protobuf::uint64 value) {
  set_has_player_card_item_id();
  player_card_item_id_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCSetPlayerCardRosterRequest.player_card_item_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCSetPlayerCardRosterResponse

// optional .CMsgClientToGCSetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgClientToGCSetPlayerCardRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCSetPlayerCardRosterResponse.result)
  return static_cast< ::CMsgClientToGCSetPlayerCardRosterResponse_Result >(result_);
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::set_result(::CMsgClientToGCSetPlayerCardRosterResponse_Result value) {
  assert(::CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CMsgClientToGCSetPlayerCardRosterResponse.result)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CMsgDOTACreateFantasyLeagueResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTACreateFantasyLeagueResponse_EResult>() {
  return ::CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueFindResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueFindResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueInfoResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueInfoResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAEditFantasyTeamResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAEditFantasyTeamResponse_EResult>() {
  return ::CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamScoreResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamScoreResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamStandingsResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamStandingsResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyPlayerScoreResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyPlayerScoreResponse_EResult>() {
  return ::CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyPlayerStandingsResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyPlayerStandingsResponse_EResult>() {
  return ::CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueCreateResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueCreateResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamCreateResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamCreateResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>() {
  return ::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamTradesResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamTradesResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyTeamRosterResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyTeamRosterResponse_EResult>() {
  return ::CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>() {
  return ::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyMessagesResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyMessagesResponse_EResult>() {
  return ::CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyRemoveOwnerResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyRemoveOwnerResponse_EResult>() {
  return ::CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyScheduledMatchesResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyScheduledMatchesResponse_EResult>() {
  return ::CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyLeaveLeagueResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyLeaveLeagueResponse_EResult>() {
  return ::CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>() {
  return ::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCGetPlayerCardRosterResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCGetPlayerCardRosterResponse_Result>() {
  return ::CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCSetPlayerCardRosterResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCSetPlayerCardRosterResponse_Result>() {
  return ::CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::DOTA_2013PassportSelectionIndices> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_2013PassportSelectionIndices>() {
  return ::DOTA_2013PassportSelectionIndices_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dota_5fgcmessages_5fclient_5ffantasy_2eproto__INCLUDED
