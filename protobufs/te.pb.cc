// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "te.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* CMsgTEArmorRicochet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEArmorRicochet_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBaseBeam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBaseBeam_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBeamEntPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBeamEntPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBeamEnts_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBeamEnts_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBeamPoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBeamPoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBeamRing_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBeamRing_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBreakModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBreakModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBSPDecal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBSPDecal_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBubbles_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBubbles_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBubbleTrail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBubbleTrail_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEDecal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEDecal_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgEffectData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgEffectData_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEEffectDispatch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEEffectDispatch_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEEnergySplash_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEEnergySplash_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEFizz_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEFizz_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEShatterSurface_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEShatterSurface_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEGlowSprite_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEGlowSprite_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEImpact_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEImpact_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEMuzzleFlash_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEMuzzleFlash_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEBloodStream_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEBloodStream_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEExplosion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEExplosion_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEDust_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEDust_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTELargeFunnel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTELargeFunnel_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTESparks_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTESparks_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEPhysicsProp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEPhysicsProp_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEPlayerDecal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEPlayerDecal_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEProjectedDecal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEProjectedDecal_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTESmoke_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTESmoke_reflection_ = NULL;
const ::google::protobuf::Descriptor* CMsgTEWorldDecal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CMsgTEWorldDecal_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ETEProtobufIds_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_te_2eproto() {
  protobuf_AddDesc_te_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "te.proto");
  GOOGLE_CHECK(file != NULL);
  CMsgTEArmorRicochet_descriptor_ = file->message_type(0);
  static const int CMsgTEArmorRicochet_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEArmorRicochet, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEArmorRicochet, dir_),
  };
  CMsgTEArmorRicochet_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEArmorRicochet_descriptor_,
      CMsgTEArmorRicochet::default_instance_,
      CMsgTEArmorRicochet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEArmorRicochet, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEArmorRicochet),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEArmorRicochet, _internal_metadata_),
      -1);
  CMsgTEBaseBeam_descriptor_ = file->message_type(1);
  static const int CMsgTEBaseBeam_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, modelindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, haloindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, startframe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, framerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, life_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, endwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, fadelength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, amplitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, flags_),
  };
  CMsgTEBaseBeam_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBaseBeam_descriptor_,
      CMsgTEBaseBeam::default_instance_,
      CMsgTEBaseBeam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBaseBeam),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBaseBeam, _internal_metadata_),
      -1);
  CMsgTEBeamEntPoint_descriptor_ = file->message_type(2);
  static const int CMsgTEBeamEntPoint_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, startentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, endentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, end_),
  };
  CMsgTEBeamEntPoint_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBeamEntPoint_descriptor_,
      CMsgTEBeamEntPoint::default_instance_,
      CMsgTEBeamEntPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBeamEntPoint),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEntPoint, _internal_metadata_),
      -1);
  CMsgTEBeamEnts_descriptor_ = file->message_type(3);
  static const int CMsgTEBeamEnts_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEnts, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEnts, startentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEnts, endentity_),
  };
  CMsgTEBeamEnts_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBeamEnts_descriptor_,
      CMsgTEBeamEnts::default_instance_,
      CMsgTEBeamEnts_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEnts, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBeamEnts),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamEnts, _internal_metadata_),
      -1);
  CMsgTEBeamPoints_descriptor_ = file->message_type(4);
  static const int CMsgTEBeamPoints_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamPoints, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamPoints, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamPoints, end_),
  };
  CMsgTEBeamPoints_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBeamPoints_descriptor_,
      CMsgTEBeamPoints::default_instance_,
      CMsgTEBeamPoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamPoints, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBeamPoints),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamPoints, _internal_metadata_),
      -1);
  CMsgTEBeamRing_descriptor_ = file->message_type(5);
  static const int CMsgTEBeamRing_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamRing, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamRing, startentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamRing, endentity_),
  };
  CMsgTEBeamRing_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBeamRing_descriptor_,
      CMsgTEBeamRing::default_instance_,
      CMsgTEBeamRing_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamRing, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBeamRing),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBeamRing, _internal_metadata_),
      -1);
  CMsgTEBreakModel_descriptor_ = file->message_type(6);
  static const int CMsgTEBreakModel_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, randomization_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, modelindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, flags_),
  };
  CMsgTEBreakModel_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBreakModel_descriptor_,
      CMsgTEBreakModel::default_instance_,
      CMsgTEBreakModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBreakModel),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBreakModel, _internal_metadata_),
      -1);
  CMsgTEBSPDecal_descriptor_ = file->message_type(7);
  static const int CMsgTEBSPDecal_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, saxis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, index_),
  };
  CMsgTEBSPDecal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBSPDecal_descriptor_,
      CMsgTEBSPDecal::default_instance_,
      CMsgTEBSPDecal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBSPDecal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBSPDecal, _internal_metadata_),
      -1);
  CMsgTEBubbles_descriptor_ = file->message_type(8);
  static const int CMsgTEBubbles_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, mins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, maxs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, speed_),
  };
  CMsgTEBubbles_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBubbles_descriptor_,
      CMsgTEBubbles::default_instance_,
      CMsgTEBubbles_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBubbles),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbles, _internal_metadata_),
      -1);
  CMsgTEBubbleTrail_descriptor_ = file->message_type(9);
  static const int CMsgTEBubbleTrail_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, mins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, maxs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, waterz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, speed_),
  };
  CMsgTEBubbleTrail_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBubbleTrail_descriptor_,
      CMsgTEBubbleTrail::default_instance_,
      CMsgTEBubbleTrail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBubbleTrail),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBubbleTrail, _internal_metadata_),
      -1);
  CMsgTEDecal_descriptor_ = file->message_type(10);
  static const int CMsgTEDecal_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, hitbox_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, index_),
  };
  CMsgTEDecal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEDecal_descriptor_,
      CMsgTEDecal::default_instance_,
      CMsgTEDecal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEDecal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDecal, _internal_metadata_),
      -1);
  CMsgEffectData_descriptor_ = file->message_type(11);
  static const int CMsgEffectData_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, otherentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, magnitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, surfaceprop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, effectindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, damagetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, material_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, hitbox_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, attachmentindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, effectname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, attachmentname_),
  };
  CMsgEffectData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgEffectData_descriptor_,
      CMsgEffectData::default_instance_,
      CMsgEffectData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgEffectData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgEffectData, _internal_metadata_),
      -1);
  CMsgTEEffectDispatch_descriptor_ = file->message_type(12);
  static const int CMsgTEEffectDispatch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEffectDispatch, effectdata_),
  };
  CMsgTEEffectDispatch_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEEffectDispatch_descriptor_,
      CMsgTEEffectDispatch::default_instance_,
      CMsgTEEffectDispatch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEffectDispatch, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEEffectDispatch),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEffectDispatch, _internal_metadata_),
      -1);
  CMsgTEEnergySplash_descriptor_ = file->message_type(13);
  static const int CMsgTEEnergySplash_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEnergySplash, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEnergySplash, dir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEnergySplash, explosive_),
  };
  CMsgTEEnergySplash_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEEnergySplash_descriptor_,
      CMsgTEEnergySplash::default_instance_,
      CMsgTEEnergySplash_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEnergySplash, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEEnergySplash),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEEnergySplash, _internal_metadata_),
      -1);
  CMsgTEFizz_descriptor_ = file->message_type(14);
  static const int CMsgTEFizz_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEFizz, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEFizz, density_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEFizz, current_),
  };
  CMsgTEFizz_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEFizz_descriptor_,
      CMsgTEFizz::default_instance_,
      CMsgTEFizz_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEFizz, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEFizz),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEFizz, _internal_metadata_),
      -1);
  CMsgTEShatterSurface_descriptor_ = file->message_type(15);
  static const int CMsgTEShatterSurface_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, force_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, forcepos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, shardsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, surfacetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, frontcolor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, backcolor_),
  };
  CMsgTEShatterSurface_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEShatterSurface_descriptor_,
      CMsgTEShatterSurface::default_instance_,
      CMsgTEShatterSurface_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEShatterSurface),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEShatterSurface, _internal_metadata_),
      -1);
  CMsgTEGlowSprite_descriptor_ = file->message_type(16);
  static const int CMsgTEGlowSprite_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, life_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, brightness_),
  };
  CMsgTEGlowSprite_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEGlowSprite_descriptor_,
      CMsgTEGlowSprite::default_instance_,
      CMsgTEGlowSprite_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEGlowSprite),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEGlowSprite, _internal_metadata_),
      -1);
  CMsgTEImpact_descriptor_ = file->message_type(17);
  static const int CMsgTEImpact_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEImpact, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEImpact, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEImpact, type_),
  };
  CMsgTEImpact_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEImpact_descriptor_,
      CMsgTEImpact::default_instance_,
      CMsgTEImpact_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEImpact, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEImpact),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEImpact, _internal_metadata_),
      -1);
  CMsgTEMuzzleFlash_descriptor_ = file->message_type(18);
  static const int CMsgTEMuzzleFlash_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, type_),
  };
  CMsgTEMuzzleFlash_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEMuzzleFlash_descriptor_,
      CMsgTEMuzzleFlash::default_instance_,
      CMsgTEMuzzleFlash_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEMuzzleFlash),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEMuzzleFlash, _internal_metadata_),
      -1);
  CMsgTEBloodStream_descriptor_ = file->message_type(19);
  static const int CMsgTEBloodStream_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, amount_),
  };
  CMsgTEBloodStream_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEBloodStream_descriptor_,
      CMsgTEBloodStream::default_instance_,
      CMsgTEBloodStream_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEBloodStream),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEBloodStream, _internal_metadata_),
      -1);
  CMsgTEExplosion_descriptor_ = file->message_type(20);
  static const int CMsgTEExplosion_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, framerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, materialtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, magnitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, affect_ragdolls_),
  };
  CMsgTEExplosion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEExplosion_descriptor_,
      CMsgTEExplosion::default_instance_,
      CMsgTEExplosion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEExplosion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEExplosion, _internal_metadata_),
      -1);
  CMsgTEDust_descriptor_ = file->message_type(21);
  static const int CMsgTEDust_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, direction_),
  };
  CMsgTEDust_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEDust_descriptor_,
      CMsgTEDust::default_instance_,
      CMsgTEDust_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEDust),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEDust, _internal_metadata_),
      -1);
  CMsgTELargeFunnel_descriptor_ = file->message_type(22);
  static const int CMsgTELargeFunnel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTELargeFunnel, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTELargeFunnel, reversed_),
  };
  CMsgTELargeFunnel_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTELargeFunnel_descriptor_,
      CMsgTELargeFunnel::default_instance_,
      CMsgTELargeFunnel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTELargeFunnel, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTELargeFunnel),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTELargeFunnel, _internal_metadata_),
      -1);
  CMsgTESparks_descriptor_ = file->message_type(23);
  static const int CMsgTESparks_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, magnitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, direction_),
  };
  CMsgTESparks_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTESparks_descriptor_,
      CMsgTESparks::default_instance_,
      CMsgTESparks_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTESparks),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESparks, _internal_metadata_),
      -1);
  CMsgTEPhysicsProp_descriptor_ = file->message_type(24);
  static const int CMsgTEPhysicsProp_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, skin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, effects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, modelindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, breakmodelsnottomake_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, scale_),
  };
  CMsgTEPhysicsProp_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEPhysicsProp_descriptor_,
      CMsgTEPhysicsProp::default_instance_,
      CMsgTEPhysicsProp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEPhysicsProp),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPhysicsProp, _internal_metadata_),
      -1);
  CMsgTEPlayerDecal_descriptor_ = file->message_type(25);
  static const int CMsgTEPlayerDecal_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPlayerDecal, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPlayerDecal, player_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPlayerDecal, entity_),
  };
  CMsgTEPlayerDecal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEPlayerDecal_descriptor_,
      CMsgTEPlayerDecal::default_instance_,
      CMsgTEPlayerDecal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPlayerDecal, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEPlayerDecal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEPlayerDecal, _internal_metadata_),
      -1);
  CMsgTEProjectedDecal_descriptor_ = file->message_type(26);
  static const int CMsgTEProjectedDecal_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, angles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, distance_),
  };
  CMsgTEProjectedDecal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEProjectedDecal_descriptor_,
      CMsgTEProjectedDecal::default_instance_,
      CMsgTEProjectedDecal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEProjectedDecal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEProjectedDecal, _internal_metadata_),
      -1);
  CMsgTESmoke_descriptor_ = file->message_type(27);
  static const int CMsgTESmoke_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESmoke, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESmoke, scale_),
  };
  CMsgTESmoke_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTESmoke_descriptor_,
      CMsgTESmoke::default_instance_,
      CMsgTESmoke_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESmoke, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTESmoke),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTESmoke, _internal_metadata_),
      -1);
  CMsgTEWorldDecal_descriptor_ = file->message_type(28);
  static const int CMsgTEWorldDecal_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEWorldDecal, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEWorldDecal, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEWorldDecal, index_),
  };
  CMsgTEWorldDecal_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CMsgTEWorldDecal_descriptor_,
      CMsgTEWorldDecal::default_instance_,
      CMsgTEWorldDecal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEWorldDecal, _has_bits_[0]),
      -1,
      -1,
      sizeof(CMsgTEWorldDecal),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CMsgTEWorldDecal, _internal_metadata_),
      -1);
  ETEProtobufIds_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_te_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEArmorRicochet_descriptor_, &CMsgTEArmorRicochet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBaseBeam_descriptor_, &CMsgTEBaseBeam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBeamEntPoint_descriptor_, &CMsgTEBeamEntPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBeamEnts_descriptor_, &CMsgTEBeamEnts::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBeamPoints_descriptor_, &CMsgTEBeamPoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBeamRing_descriptor_, &CMsgTEBeamRing::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBreakModel_descriptor_, &CMsgTEBreakModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBSPDecal_descriptor_, &CMsgTEBSPDecal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBubbles_descriptor_, &CMsgTEBubbles::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBubbleTrail_descriptor_, &CMsgTEBubbleTrail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEDecal_descriptor_, &CMsgTEDecal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgEffectData_descriptor_, &CMsgEffectData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEEffectDispatch_descriptor_, &CMsgTEEffectDispatch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEEnergySplash_descriptor_, &CMsgTEEnergySplash::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEFizz_descriptor_, &CMsgTEFizz::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEShatterSurface_descriptor_, &CMsgTEShatterSurface::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEGlowSprite_descriptor_, &CMsgTEGlowSprite::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEImpact_descriptor_, &CMsgTEImpact::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEMuzzleFlash_descriptor_, &CMsgTEMuzzleFlash::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEBloodStream_descriptor_, &CMsgTEBloodStream::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEExplosion_descriptor_, &CMsgTEExplosion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEDust_descriptor_, &CMsgTEDust::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTELargeFunnel_descriptor_, &CMsgTELargeFunnel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTESparks_descriptor_, &CMsgTESparks::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEPhysicsProp_descriptor_, &CMsgTEPhysicsProp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEPlayerDecal_descriptor_, &CMsgTEPlayerDecal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEProjectedDecal_descriptor_, &CMsgTEProjectedDecal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTESmoke_descriptor_, &CMsgTESmoke::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CMsgTEWorldDecal_descriptor_, &CMsgTEWorldDecal::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_te_2eproto() {
  delete CMsgTEArmorRicochet::default_instance_;
  delete CMsgTEArmorRicochet_reflection_;
  delete CMsgTEBaseBeam::default_instance_;
  delete CMsgTEBaseBeam_reflection_;
  delete CMsgTEBeamEntPoint::default_instance_;
  delete CMsgTEBeamEntPoint_reflection_;
  delete CMsgTEBeamEnts::default_instance_;
  delete CMsgTEBeamEnts_reflection_;
  delete CMsgTEBeamPoints::default_instance_;
  delete CMsgTEBeamPoints_reflection_;
  delete CMsgTEBeamRing::default_instance_;
  delete CMsgTEBeamRing_reflection_;
  delete CMsgTEBreakModel::default_instance_;
  delete CMsgTEBreakModel_reflection_;
  delete CMsgTEBSPDecal::default_instance_;
  delete CMsgTEBSPDecal_reflection_;
  delete CMsgTEBubbles::default_instance_;
  delete CMsgTEBubbles_reflection_;
  delete CMsgTEBubbleTrail::default_instance_;
  delete CMsgTEBubbleTrail_reflection_;
  delete CMsgTEDecal::default_instance_;
  delete CMsgTEDecal_reflection_;
  delete CMsgEffectData::default_instance_;
  delete CMsgEffectData_reflection_;
  delete CMsgTEEffectDispatch::default_instance_;
  delete CMsgTEEffectDispatch_reflection_;
  delete CMsgTEEnergySplash::default_instance_;
  delete CMsgTEEnergySplash_reflection_;
  delete CMsgTEFizz::default_instance_;
  delete CMsgTEFizz_reflection_;
  delete CMsgTEShatterSurface::default_instance_;
  delete CMsgTEShatterSurface_reflection_;
  delete CMsgTEGlowSprite::default_instance_;
  delete CMsgTEGlowSprite_reflection_;
  delete CMsgTEImpact::default_instance_;
  delete CMsgTEImpact_reflection_;
  delete CMsgTEMuzzleFlash::default_instance_;
  delete CMsgTEMuzzleFlash_reflection_;
  delete CMsgTEBloodStream::default_instance_;
  delete CMsgTEBloodStream_reflection_;
  delete CMsgTEExplosion::default_instance_;
  delete CMsgTEExplosion_reflection_;
  delete CMsgTEDust::default_instance_;
  delete CMsgTEDust_reflection_;
  delete CMsgTELargeFunnel::default_instance_;
  delete CMsgTELargeFunnel_reflection_;
  delete CMsgTESparks::default_instance_;
  delete CMsgTESparks_reflection_;
  delete CMsgTEPhysicsProp::default_instance_;
  delete CMsgTEPhysicsProp_reflection_;
  delete CMsgTEPlayerDecal::default_instance_;
  delete CMsgTEPlayerDecal_reflection_;
  delete CMsgTEProjectedDecal::default_instance_;
  delete CMsgTEProjectedDecal_reflection_;
  delete CMsgTESmoke::default_instance_;
  delete CMsgTESmoke_reflection_;
  delete CMsgTEWorldDecal::default_instance_;
  delete CMsgTEWorldDecal_reflection_;
}

void protobuf_AddDesc_te_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_networkbasetypes_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\010te.proto\032\026networkbasetypes.proto\"I\n\023CM"
    "sgTEArmorRicochet\022\030\n\003pos\030\001 \001(\0132\013.CMsgVec"
    "tor\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector\"\341\001\n\016CMsgTE"
    "BaseBeam\022\022\n\nmodelindex\030\001 \001(\006\022\021\n\thaloinde"
    "x\030\002 \001(\006\022\022\n\nstartframe\030\003 \001(\r\022\021\n\tframerate"
    "\030\004 \001(\r\022\014\n\004life\030\005 \001(\002\022\r\n\005width\030\006 \001(\002\022\020\n\010e"
    "ndwidth\030\007 \001(\002\022\022\n\nfadelength\030\010 \001(\r\022\021\n\tamp"
    "litude\030\t \001(\002\022\r\n\005color\030\n \001(\007\022\r\n\005speed\030\013 \001"
    "(\r\022\r\n\005flags\030\014 \001(\r\"\221\001\n\022CMsgTEBeamEntPoint"
    "\022\035\n\004base\030\001 \001(\0132\017.CMsgTEBaseBeam\022\023\n\013start"
    "entity\030\002 \001(\r\022\021\n\tendentity\030\003 \001(\r\022\032\n\005start"
    "\030\004 \001(\0132\013.CMsgVector\022\030\n\003end\030\005 \001(\0132\013.CMsgV"
    "ector\"W\n\016CMsgTEBeamEnts\022\035\n\004base\030\001 \001(\0132\017."
    "CMsgTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\te"
    "ndentity\030\003 \001(\r\"g\n\020CMsgTEBeamPoints\022\035\n\004ba"
    "se\030\001 \001(\0132\017.CMsgTEBaseBeam\022\032\n\005start\030\002 \001(\013"
    "2\013.CMsgVector\022\030\n\003end\030\003 \001(\0132\013.CMsgVector\""
    "W\n\016CMsgTEBeamRing\022\035\n\004base\030\001 \001(\0132\017.CMsgTE"
    "BaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tendenti"
    "ty\030\003 \001(\r\"\335\001\n\020CMsgTEBreakModel\022\033\n\006origin\030"
    "\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013.CMs"
    "gQAngle\022\031\n\004size\030\003 \001(\0132\013.CMsgVector\022\035\n\010ve"
    "locity\030\004 \001(\0132\013.CMsgVector\022\025\n\rrandomizati"
    "on\030\005 \001(\r\022\022\n\nmodelindex\030\006 \001(\006\022\r\n\005count\030\007 "
    "\001(\r\022\014\n\004time\030\010 \001(\002\022\r\n\005flags\030\t \001(\r\"\205\001\n\016CMs"
    "gTEBSPDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector"
    "\022\033\n\006normal\030\002 \001(\0132\013.CMsgVector\022\032\n\005saxis\030\003"
    " \001(\0132\013.CMsgVector\022\016\n\006entity\030\004 \001(\r\022\r\n\005ind"
    "ex\030\005 \001(\r\"s\n\rCMsgTEBubbles\022\031\n\004mins\030\001 \001(\0132"
    "\013.CMsgVector\022\031\n\004maxs\030\002 \001(\0132\013.CMsgVector\022"
    "\016\n\006height\030\003 \001(\002\022\r\n\005count\030\004 \001(\r\022\r\n\005speed\030"
    "\005 \001(\002\"w\n\021CMsgTEBubbleTrail\022\031\n\004mins\030\001 \001(\013"
    "2\013.CMsgVector\022\031\n\004maxs\030\002 \001(\0132\013.CMsgVector"
    "\022\016\n\006waterz\030\003 \001(\002\022\r\n\005count\030\004 \001(\r\022\r\n\005speed"
    "\030\005 \001(\002\"u\n\013CMsgTEDecal\022\033\n\006origin\030\001 \001(\0132\013."
    "CMsgVector\022\032\n\005start\030\002 \001(\0132\013.CMsgVector\022\016"
    "\n\006entity\030\003 \001(\r\022\016\n\006hitbox\030\004 \001(\r\022\r\n\005index\030"
    "\005 \001(\r\"\235\003\n\016CMsgEffectData\022\033\n\006origin\030\001 \001(\013"
    "2\013.CMsgVector\022\032\n\005start\030\002 \001(\0132\013.CMsgVecto"
    "r\022\033\n\006normal\030\003 \001(\0132\013.CMsgVector\022\033\n\006angles"
    "\030\004 \001(\0132\013.CMsgQAngle\022\016\n\006entity\030\005 \001(\007\022\023\n\013o"
    "therentity\030\006 \001(\007\022\r\n\005scale\030\007 \001(\002\022\021\n\tmagni"
    "tude\030\010 \001(\002\022\016\n\006radius\030\t \001(\002\022\023\n\013surfacepro"
    "p\030\n \001(\007\022\023\n\013effectindex\030\013 \001(\006\022\022\n\ndamagety"
    "pe\030\014 \001(\r\022\020\n\010material\030\r \001(\r\022\016\n\006hitbox\030\016 \001"
    "(\r\022\r\n\005color\030\017 \001(\r\022\r\n\005flags\030\020 \001(\r\022\027\n\017atta"
    "chmentindex\030\021 \001(\005\022\022\n\neffectname\030\022 \001(\r\022\026\n"
    "\016attachmentname\030\023 \001(\r\";\n\024CMsgTEEffectDis"
    "patch\022#\n\neffectdata\030\001 \001(\0132\017.CMsgEffectDa"
    "ta\"[\n\022CMsgTEEnergySplash\022\030\n\003pos\030\001 \001(\0132\013."
    "CMsgVector\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector\022\021\n\t"
    "explosive\030\003 \001(\010\">\n\nCMsgTEFizz\022\016\n\006entity\030"
    "\001 \001(\r\022\017\n\007density\030\002 \001(\r\022\017\n\007current\030\003 \001(\005\""
    "\371\001\n\024CMsgTEShatterSurface\022\033\n\006origin\030\001 \001(\013"
    "2\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013.CMsgQAng"
    "le\022\032\n\005force\030\003 \001(\0132\013.CMsgVector\022\035\n\010forcep"
    "os\030\004 \001(\0132\013.CMsgVector\022\r\n\005width\030\005 \001(\002\022\016\n\006"
    "height\030\006 \001(\002\022\021\n\tshardsize\030\007 \001(\002\022\023\n\013surfa"
    "cetype\030\010 \001(\r\022\022\n\nfrontcolor\030\t \001(\007\022\021\n\tback"
    "color\030\n \001(\007\"`\n\020CMsgTEGlowSprite\022\033\n\006origi"
    "n\030\001 \001(\0132\013.CMsgVector\022\r\n\005scale\030\002 \001(\002\022\014\n\004l"
    "ife\030\003 \001(\002\022\022\n\nbrightness\030\004 \001(\r\"V\n\014CMsgTEI"
    "mpact\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006no"
    "rmal\030\002 \001(\0132\013.CMsgVector\022\014\n\004type\030\003 \001(\r\"j\n"
    "\021CMsgTEMuzzleFlash\022\033\n\006origin\030\001 \001(\0132\013.CMs"
    "gVector\022\033\n\006angles\030\002 \001(\0132\013.CMsgQAngle\022\r\n\005"
    "scale\030\003 \001(\002\022\014\n\004type\030\004 \001(\r\"o\n\021CMsgTEBlood"
    "Stream\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\036\n\td"
    "irection\030\002 \001(\0132\013.CMsgVector\022\r\n\005color\030\003 \001"
    "(\007\022\016\n\006amount\030\004 \001(\r\"\316\001\n\017CMsgTEExplosion\022\033"
    "\n\006origin\030\001 \001(\0132\013.CMsgVector\022\021\n\tframerate"
    "\030\002 \001(\r\022\r\n\005flags\030\003 \001(\r\022\033\n\006normal\030\004 \001(\0132\013."
    "CMsgVector\022\024\n\014materialtype\030\005 \001(\r\022\016\n\006radi"
    "us\030\006 \001(\r\022\021\n\tmagnitude\030\007 \001(\r\022\r\n\005scale\030\010 \001"
    "(\002\022\027\n\017affect_ragdolls\030\t \001(\010\"f\n\nCMsgTEDus"
    "t\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\014\n\004size\030\002"
    " \001(\002\022\r\n\005speed\030\003 \001(\002\022\036\n\tdirection\030\004 \001(\0132\013"
    ".CMsgVector\"B\n\021CMsgTELargeFunnel\022\033\n\006orig"
    "in\030\001 \001(\0132\013.CMsgVector\022\020\n\010reversed\030\002 \001(\r\""
    "n\n\014CMsgTESparks\022\033\n\006origin\030\001 \001(\0132\013.CMsgVe"
    "ctor\022\021\n\tmagnitude\030\002 \001(\r\022\016\n\006length\030\003 \001(\r\022"
    "\036\n\tdirection\030\004 \001(\0132\013.CMsgVector\"\352\001\n\021CMsg"
    "TEPhysicsProp\022\033\n\006origin\030\001 \001(\0132\013.CMsgVect"
    "or\022\035\n\010velocity\030\002 \001(\0132\013.CMsgVector\022\033\n\006ang"
    "les\030\003 \001(\0132\013.CMsgQAngle\022\014\n\004skin\030\004 \001(\007\022\r\n\005"
    "flags\030\005 \001(\r\022\017\n\007effects\030\006 \001(\r\022\r\n\005color\030\007 "
    "\001(\007\022\022\n\nmodelindex\030\010 \001(\006\022\034\n\024breakmodelsno"
    "ttomake\030\t \001(\r\022\r\n\005scale\030\n \001(\002\"P\n\021CMsgTEPl"
    "ayerDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\016"
    "\n\006player\030\002 \001(\r\022\016\n\006entity\030\003 \001(\r\"q\n\024CMsgTE"
    "ProjectedDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
    "tor\022\033\n\006angles\030\002 \001(\0132\013.CMsgQAngle\022\r\n\005inde"
    "x\030\003 \001(\r\022\020\n\010distance\030\004 \001(\002\"9\n\013CMsgTESmoke"
    "\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\r\n\005scale\030\002"
    " \001(\002\"[\n\020CMsgTEWorldDecal\022\033\n\006origin\030\001 \001(\013"
    "2\013.CMsgVector\022\033\n\006normal\030\002 \001(\0132\013.CMsgVect"
    "or\022\r\n\005index\030\003 \001(\r*\323\004\n\016ETEProtobufIds\022\030\n\023"
    "TE_EffectDispatchId\020\220\003\022\027\n\022TE_ArmorRicoch"
    "etId\020\221\003\022\026\n\021TE_BeamEntPointId\020\222\003\022\022\n\rTE_Be"
    "amEntsId\020\223\003\022\024\n\017TE_BeamPointsId\020\224\003\022\022\n\rTE_"
    "BeamRingId\020\225\003\022\024\n\017TE_BreakModelId\020\226\003\022\022\n\rT"
    "E_BSPDecalId\020\227\003\022\021\n\014TE_BubblesId\020\230\003\022\025\n\020TE"
    "_BubbleTrailId\020\231\003\022\017\n\nTE_DecalId\020\232\003\022\024\n\017TE"
    "_WorldDecalId\020\233\003\022\026\n\021TE_EnergySplashId\020\234\003"
    "\022\016\n\tTE_FizzId\020\235\003\022\030\n\023TE_ShatterSurfaceId\020"
    "\236\003\022\024\n\017TE_GlowSpriteId\020\237\003\022\020\n\013TE_ImpactId\020"
    "\240\003\022\025\n\020TE_MuzzleFlashId\020\241\003\022\025\n\020TE_BloodStr"
    "eamId\020\242\003\022\023\n\016TE_ExplosionId\020\243\003\022\016\n\tTE_Dust"
    "Id\020\244\003\022\025\n\020TE_LargeFunnelId\020\245\003\022\020\n\013TE_Spark"
    "sId\020\246\003\022\025\n\020TE_PhysicsPropId\020\247\003\022\025\n\020TE_Play"
    "erDecalId\020\250\003\022\030\n\023TE_ProjectedDecalId\020\251\003\022\017"
    "\n\nTE_SmokeId\020\252\003B\005H\001\200\001\000", 4462);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "te.proto", &protobuf_RegisterTypes);
  CMsgTEArmorRicochet::default_instance_ = new CMsgTEArmorRicochet();
  CMsgTEBaseBeam::default_instance_ = new CMsgTEBaseBeam();
  CMsgTEBeamEntPoint::default_instance_ = new CMsgTEBeamEntPoint();
  CMsgTEBeamEnts::default_instance_ = new CMsgTEBeamEnts();
  CMsgTEBeamPoints::default_instance_ = new CMsgTEBeamPoints();
  CMsgTEBeamRing::default_instance_ = new CMsgTEBeamRing();
  CMsgTEBreakModel::default_instance_ = new CMsgTEBreakModel();
  CMsgTEBSPDecal::default_instance_ = new CMsgTEBSPDecal();
  CMsgTEBubbles::default_instance_ = new CMsgTEBubbles();
  CMsgTEBubbleTrail::default_instance_ = new CMsgTEBubbleTrail();
  CMsgTEDecal::default_instance_ = new CMsgTEDecal();
  CMsgEffectData::default_instance_ = new CMsgEffectData();
  CMsgTEEffectDispatch::default_instance_ = new CMsgTEEffectDispatch();
  CMsgTEEnergySplash::default_instance_ = new CMsgTEEnergySplash();
  CMsgTEFizz::default_instance_ = new CMsgTEFizz();
  CMsgTEShatterSurface::default_instance_ = new CMsgTEShatterSurface();
  CMsgTEGlowSprite::default_instance_ = new CMsgTEGlowSprite();
  CMsgTEImpact::default_instance_ = new CMsgTEImpact();
  CMsgTEMuzzleFlash::default_instance_ = new CMsgTEMuzzleFlash();
  CMsgTEBloodStream::default_instance_ = new CMsgTEBloodStream();
  CMsgTEExplosion::default_instance_ = new CMsgTEExplosion();
  CMsgTEDust::default_instance_ = new CMsgTEDust();
  CMsgTELargeFunnel::default_instance_ = new CMsgTELargeFunnel();
  CMsgTESparks::default_instance_ = new CMsgTESparks();
  CMsgTEPhysicsProp::default_instance_ = new CMsgTEPhysicsProp();
  CMsgTEPlayerDecal::default_instance_ = new CMsgTEPlayerDecal();
  CMsgTEProjectedDecal::default_instance_ = new CMsgTEProjectedDecal();
  CMsgTESmoke::default_instance_ = new CMsgTESmoke();
  CMsgTEWorldDecal::default_instance_ = new CMsgTEWorldDecal();
  CMsgTEArmorRicochet::default_instance_->InitAsDefaultInstance();
  CMsgTEBaseBeam::default_instance_->InitAsDefaultInstance();
  CMsgTEBeamEntPoint::default_instance_->InitAsDefaultInstance();
  CMsgTEBeamEnts::default_instance_->InitAsDefaultInstance();
  CMsgTEBeamPoints::default_instance_->InitAsDefaultInstance();
  CMsgTEBeamRing::default_instance_->InitAsDefaultInstance();
  CMsgTEBreakModel::default_instance_->InitAsDefaultInstance();
  CMsgTEBSPDecal::default_instance_->InitAsDefaultInstance();
  CMsgTEBubbles::default_instance_->InitAsDefaultInstance();
  CMsgTEBubbleTrail::default_instance_->InitAsDefaultInstance();
  CMsgTEDecal::default_instance_->InitAsDefaultInstance();
  CMsgEffectData::default_instance_->InitAsDefaultInstance();
  CMsgTEEffectDispatch::default_instance_->InitAsDefaultInstance();
  CMsgTEEnergySplash::default_instance_->InitAsDefaultInstance();
  CMsgTEFizz::default_instance_->InitAsDefaultInstance();
  CMsgTEShatterSurface::default_instance_->InitAsDefaultInstance();
  CMsgTEGlowSprite::default_instance_->InitAsDefaultInstance();
  CMsgTEImpact::default_instance_->InitAsDefaultInstance();
  CMsgTEMuzzleFlash::default_instance_->InitAsDefaultInstance();
  CMsgTEBloodStream::default_instance_->InitAsDefaultInstance();
  CMsgTEExplosion::default_instance_->InitAsDefaultInstance();
  CMsgTEDust::default_instance_->InitAsDefaultInstance();
  CMsgTELargeFunnel::default_instance_->InitAsDefaultInstance();
  CMsgTESparks::default_instance_->InitAsDefaultInstance();
  CMsgTEPhysicsProp::default_instance_->InitAsDefaultInstance();
  CMsgTEPlayerDecal::default_instance_->InitAsDefaultInstance();
  CMsgTEProjectedDecal::default_instance_->InitAsDefaultInstance();
  CMsgTESmoke::default_instance_->InitAsDefaultInstance();
  CMsgTEWorldDecal::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_te_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_te_2eproto {
  StaticDescriptorInitializer_te_2eproto() {
    protobuf_AddDesc_te_2eproto();
  }
} static_descriptor_initializer_te_2eproto_;
const ::google::protobuf::EnumDescriptor* ETEProtobufIds_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ETEProtobufIds_descriptor_;
}
bool ETEProtobufIds_IsValid(int value) {
  switch(value) {
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 406:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int CMsgTEArmorRicochet::kPosFieldNumber;
const int CMsgTEArmorRicochet::kDirFieldNumber;
#endif  // !_MSC_VER

CMsgTEArmorRicochet::CMsgTEArmorRicochet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEArmorRicochet)
}

void CMsgTEArmorRicochet::InitAsDefaultInstance() {
  pos_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  dir_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEArmorRicochet::CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEArmorRicochet)
}

void CMsgTEArmorRicochet::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  dir_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEArmorRicochet::~CMsgTEArmorRicochet() {
  // @@protoc_insertion_point(destructor:CMsgTEArmorRicochet)
  SharedDtor();
}

void CMsgTEArmorRicochet::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete dir_;
  }
}

void CMsgTEArmorRicochet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEArmorRicochet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEArmorRicochet_descriptor_;
}

const CMsgTEArmorRicochet& CMsgTEArmorRicochet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEArmorRicochet* CMsgTEArmorRicochet::default_instance_ = NULL;

CMsgTEArmorRicochet* CMsgTEArmorRicochet::New(::google::protobuf::Arena* arena) const {
  CMsgTEArmorRicochet* n = new CMsgTEArmorRicochet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEArmorRicochet::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::CMsgVector::Clear();
    }
    if (has_dir()) {
      if (dir_ != NULL) dir_->::CMsgVector::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEArmorRicochet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEArmorRicochet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_dir;
        break;
      }

      // optional .CMsgVector dir = 2;
      case 2: {
        if (tag == 18) {
         parse_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dir()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEArmorRicochet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEArmorRicochet)
  return false;
#undef DO_
}

void CMsgTEArmorRicochet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEArmorRicochet)
  // optional .CMsgVector pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // optional .CMsgVector dir = 2;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->dir_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEArmorRicochet)
}

::google::protobuf::uint8* CMsgTEArmorRicochet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEArmorRicochet)
  // optional .CMsgVector pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->pos_, target);
  }

  // optional .CMsgVector dir = 2;
  if (has_dir()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->dir_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEArmorRicochet)
  return target;
}

int CMsgTEArmorRicochet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .CMsgVector pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pos_);
    }

    // optional .CMsgVector dir = 2;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->dir_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEArmorRicochet::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEArmorRicochet* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEArmorRicochet>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEArmorRicochet::MergeFrom(const CMsgTEArmorRicochet& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::CMsgVector::MergeFrom(from.pos());
    }
    if (from.has_dir()) {
      mutable_dir()->::CMsgVector::MergeFrom(from.dir());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEArmorRicochet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEArmorRicochet::CopyFrom(const CMsgTEArmorRicochet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEArmorRicochet::IsInitialized() const {

  return true;
}

void CMsgTEArmorRicochet::Swap(CMsgTEArmorRicochet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEArmorRicochet::InternalSwap(CMsgTEArmorRicochet* other) {
  std::swap(pos_, other->pos_);
  std::swap(dir_, other->dir_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEArmorRicochet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEArmorRicochet_descriptor_;
  metadata.reflection = CMsgTEArmorRicochet_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEArmorRicochet

// optional .CMsgVector pos = 1;
bool CMsgTEArmorRicochet::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEArmorRicochet::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEArmorRicochet::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEArmorRicochet::clear_pos() {
  if (pos_ != NULL) pos_->::CMsgVector::Clear();
  clear_has_pos();
}
const ::CMsgVector& CMsgTEArmorRicochet::pos() const {
  // @@protoc_insertion_point(field_get:CMsgTEArmorRicochet.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::CMsgVector* CMsgTEArmorRicochet::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEArmorRicochet.pos)
  return pos_;
}
::CMsgVector* CMsgTEArmorRicochet::release_pos() {
  clear_has_pos();
  ::CMsgVector* temp = pos_;
  pos_ = NULL;
  return temp;
}
void CMsgTEArmorRicochet::set_allocated_pos(::CMsgVector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEArmorRicochet.pos)
}

// optional .CMsgVector dir = 2;
bool CMsgTEArmorRicochet::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEArmorRicochet::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEArmorRicochet::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEArmorRicochet::clear_dir() {
  if (dir_ != NULL) dir_->::CMsgVector::Clear();
  clear_has_dir();
}
const ::CMsgVector& CMsgTEArmorRicochet::dir() const {
  // @@protoc_insertion_point(field_get:CMsgTEArmorRicochet.dir)
  return dir_ != NULL ? *dir_ : *default_instance_->dir_;
}
::CMsgVector* CMsgTEArmorRicochet::mutable_dir() {
  set_has_dir();
  if (dir_ == NULL) {
    dir_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEArmorRicochet.dir)
  return dir_;
}
::CMsgVector* CMsgTEArmorRicochet::release_dir() {
  clear_has_dir();
  ::CMsgVector* temp = dir_;
  dir_ = NULL;
  return temp;
}
void CMsgTEArmorRicochet::set_allocated_dir(::CMsgVector* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    set_has_dir();
  } else {
    clear_has_dir();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEArmorRicochet.dir)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBaseBeam::kModelindexFieldNumber;
const int CMsgTEBaseBeam::kHaloindexFieldNumber;
const int CMsgTEBaseBeam::kStartframeFieldNumber;
const int CMsgTEBaseBeam::kFramerateFieldNumber;
const int CMsgTEBaseBeam::kLifeFieldNumber;
const int CMsgTEBaseBeam::kWidthFieldNumber;
const int CMsgTEBaseBeam::kEndwidthFieldNumber;
const int CMsgTEBaseBeam::kFadelengthFieldNumber;
const int CMsgTEBaseBeam::kAmplitudeFieldNumber;
const int CMsgTEBaseBeam::kColorFieldNumber;
const int CMsgTEBaseBeam::kSpeedFieldNumber;
const int CMsgTEBaseBeam::kFlagsFieldNumber;
#endif  // !_MSC_VER

CMsgTEBaseBeam::CMsgTEBaseBeam()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBaseBeam)
}

void CMsgTEBaseBeam::InitAsDefaultInstance() {
}

CMsgTEBaseBeam::CMsgTEBaseBeam(const CMsgTEBaseBeam& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBaseBeam)
}

void CMsgTEBaseBeam::SharedCtor() {
  _cached_size_ = 0;
  modelindex_ = GOOGLE_ULONGLONG(0);
  haloindex_ = GOOGLE_ULONGLONG(0);
  startframe_ = 0u;
  framerate_ = 0u;
  life_ = 0;
  width_ = 0;
  endwidth_ = 0;
  fadelength_ = 0u;
  amplitude_ = 0;
  color_ = 0u;
  speed_ = 0u;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBaseBeam::~CMsgTEBaseBeam() {
  // @@protoc_insertion_point(destructor:CMsgTEBaseBeam)
  SharedDtor();
}

void CMsgTEBaseBeam::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CMsgTEBaseBeam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBaseBeam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBaseBeam_descriptor_;
}

const CMsgTEBaseBeam& CMsgTEBaseBeam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBaseBeam* CMsgTEBaseBeam::default_instance_ = NULL;

CMsgTEBaseBeam* CMsgTEBaseBeam::New(::google::protobuf::Arena* arena) const {
  CMsgTEBaseBeam* n = new CMsgTEBaseBeam;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBaseBeam::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBaseBeam*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(modelindex_, fadelength_);
  }
  ZR_(amplitude_, flags_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBaseBeam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBaseBeam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 modelindex = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
          set_has_modelindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_haloindex;
        break;
      }

      // optional fixed64 haloindex = 2;
      case 2: {
        if (tag == 17) {
         parse_haloindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &haloindex_)));
          set_has_haloindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_startframe;
        break;
      }

      // optional uint32 startframe = 3;
      case 3: {
        if (tag == 24) {
         parse_startframe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startframe_)));
          set_has_startframe();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_framerate;
        break;
      }

      // optional uint32 framerate = 4;
      case 4: {
        if (tag == 32) {
         parse_framerate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framerate_)));
          set_has_framerate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_life;
        break;
      }

      // optional float life = 5;
      case 5: {
        if (tag == 45) {
         parse_life:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &life_)));
          set_has_life();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_width;
        break;
      }

      // optional float width = 6;
      case 6: {
        if (tag == 53) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_endwidth;
        break;
      }

      // optional float endwidth = 7;
      case 7: {
        if (tag == 61) {
         parse_endwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &endwidth_)));
          set_has_endwidth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_fadelength;
        break;
      }

      // optional uint32 fadelength = 8;
      case 8: {
        if (tag == 64) {
         parse_fadelength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fadelength_)));
          set_has_fadelength();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_amplitude;
        break;
      }

      // optional float amplitude = 9;
      case 9: {
        if (tag == 77) {
         parse_amplitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &amplitude_)));
          set_has_amplitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_color;
        break;
      }

      // optional fixed32 color = 10;
      case 10: {
        if (tag == 85) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_speed;
        break;
      }

      // optional uint32 speed = 11;
      case 11: {
        if (tag == 88) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 12;
      case 12: {
        if (tag == 96) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBaseBeam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBaseBeam)
  return false;
#undef DO_
}

void CMsgTEBaseBeam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBaseBeam)
  // optional fixed64 modelindex = 1;
  if (has_modelindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->modelindex(), output);
  }

  // optional fixed64 haloindex = 2;
  if (has_haloindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(2, this->haloindex(), output);
  }

  // optional uint32 startframe = 3;
  if (has_startframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->startframe(), output);
  }

  // optional uint32 framerate = 4;
  if (has_framerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->framerate(), output);
  }

  // optional float life = 5;
  if (has_life()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->life(), output);
  }

  // optional float width = 6;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->width(), output);
  }

  // optional float endwidth = 7;
  if (has_endwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->endwidth(), output);
  }

  // optional uint32 fadelength = 8;
  if (has_fadelength()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->fadelength(), output);
  }

  // optional float amplitude = 9;
  if (has_amplitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->amplitude(), output);
  }

  // optional fixed32 color = 10;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->color(), output);
  }

  // optional uint32 speed = 11;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->speed(), output);
  }

  // optional uint32 flags = 12;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->flags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBaseBeam)
}

::google::protobuf::uint8* CMsgTEBaseBeam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBaseBeam)
  // optional fixed64 modelindex = 1;
  if (has_modelindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->modelindex(), target);
  }

  // optional fixed64 haloindex = 2;
  if (has_haloindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(2, this->haloindex(), target);
  }

  // optional uint32 startframe = 3;
  if (has_startframe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->startframe(), target);
  }

  // optional uint32 framerate = 4;
  if (has_framerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->framerate(), target);
  }

  // optional float life = 5;
  if (has_life()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->life(), target);
  }

  // optional float width = 6;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->width(), target);
  }

  // optional float endwidth = 7;
  if (has_endwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->endwidth(), target);
  }

  // optional uint32 fadelength = 8;
  if (has_fadelength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->fadelength(), target);
  }

  // optional float amplitude = 9;
  if (has_amplitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->amplitude(), target);
  }

  // optional fixed32 color = 10;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->color(), target);
  }

  // optional uint32 speed = 11;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->speed(), target);
  }

  // optional uint32 flags = 12;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->flags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBaseBeam)
  return target;
}

int CMsgTEBaseBeam::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional fixed64 modelindex = 1;
    if (has_modelindex()) {
      total_size += 1 + 8;
    }

    // optional fixed64 haloindex = 2;
    if (has_haloindex()) {
      total_size += 1 + 8;
    }

    // optional uint32 startframe = 3;
    if (has_startframe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startframe());
    }

    // optional uint32 framerate = 4;
    if (has_framerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framerate());
    }

    // optional float life = 5;
    if (has_life()) {
      total_size += 1 + 4;
    }

    // optional float width = 6;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // optional float endwidth = 7;
    if (has_endwidth()) {
      total_size += 1 + 4;
    }

    // optional uint32 fadelength = 8;
    if (has_fadelength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fadelength());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional float amplitude = 9;
    if (has_amplitude()) {
      total_size += 1 + 4;
    }

    // optional fixed32 color = 10;
    if (has_color()) {
      total_size += 1 + 4;
    }

    // optional uint32 speed = 11;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->speed());
    }

    // optional uint32 flags = 12;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBaseBeam::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBaseBeam* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBaseBeam>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBaseBeam::MergeFrom(const CMsgTEBaseBeam& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_modelindex()) {
      set_modelindex(from.modelindex());
    }
    if (from.has_haloindex()) {
      set_haloindex(from.haloindex());
    }
    if (from.has_startframe()) {
      set_startframe(from.startframe());
    }
    if (from.has_framerate()) {
      set_framerate(from.framerate());
    }
    if (from.has_life()) {
      set_life(from.life());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_endwidth()) {
      set_endwidth(from.endwidth());
    }
    if (from.has_fadelength()) {
      set_fadelength(from.fadelength());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_amplitude()) {
      set_amplitude(from.amplitude());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBaseBeam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBaseBeam::CopyFrom(const CMsgTEBaseBeam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBaseBeam::IsInitialized() const {

  return true;
}

void CMsgTEBaseBeam::Swap(CMsgTEBaseBeam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBaseBeam::InternalSwap(CMsgTEBaseBeam* other) {
  std::swap(modelindex_, other->modelindex_);
  std::swap(haloindex_, other->haloindex_);
  std::swap(startframe_, other->startframe_);
  std::swap(framerate_, other->framerate_);
  std::swap(life_, other->life_);
  std::swap(width_, other->width_);
  std::swap(endwidth_, other->endwidth_);
  std::swap(fadelength_, other->fadelength_);
  std::swap(amplitude_, other->amplitude_);
  std::swap(color_, other->color_);
  std::swap(speed_, other->speed_);
  std::swap(flags_, other->flags_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBaseBeam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBaseBeam_descriptor_;
  metadata.reflection = CMsgTEBaseBeam_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBaseBeam

// optional fixed64 modelindex = 1;
bool CMsgTEBaseBeam::has_modelindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBaseBeam::set_has_modelindex() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBaseBeam::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBaseBeam::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
 ::google::protobuf::uint64 CMsgTEBaseBeam::modelindex() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.modelindex)
  return modelindex_;
}
 void CMsgTEBaseBeam::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.modelindex)
}

// optional fixed64 haloindex = 2;
bool CMsgTEBaseBeam::has_haloindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBaseBeam::set_has_haloindex() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBaseBeam::clear_has_haloindex() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBaseBeam::clear_haloindex() {
  haloindex_ = GOOGLE_ULONGLONG(0);
  clear_has_haloindex();
}
 ::google::protobuf::uint64 CMsgTEBaseBeam::haloindex() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.haloindex)
  return haloindex_;
}
 void CMsgTEBaseBeam::set_haloindex(::google::protobuf::uint64 value) {
  set_has_haloindex();
  haloindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.haloindex)
}

// optional uint32 startframe = 3;
bool CMsgTEBaseBeam::has_startframe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBaseBeam::set_has_startframe() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBaseBeam::clear_has_startframe() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBaseBeam::clear_startframe() {
  startframe_ = 0u;
  clear_has_startframe();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::startframe() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.startframe)
  return startframe_;
}
 void CMsgTEBaseBeam::set_startframe(::google::protobuf::uint32 value) {
  set_has_startframe();
  startframe_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.startframe)
}

// optional uint32 framerate = 4;
bool CMsgTEBaseBeam::has_framerate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBaseBeam::set_has_framerate() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBaseBeam::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBaseBeam::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::framerate() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.framerate)
  return framerate_;
}
 void CMsgTEBaseBeam::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.framerate)
}

// optional float life = 5;
bool CMsgTEBaseBeam::has_life() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBaseBeam::set_has_life() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBaseBeam::clear_has_life() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBaseBeam::clear_life() {
  life_ = 0;
  clear_has_life();
}
 float CMsgTEBaseBeam::life() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.life)
  return life_;
}
 void CMsgTEBaseBeam::set_life(float value) {
  set_has_life();
  life_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.life)
}

// optional float width = 6;
bool CMsgTEBaseBeam::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgTEBaseBeam::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgTEBaseBeam::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgTEBaseBeam::clear_width() {
  width_ = 0;
  clear_has_width();
}
 float CMsgTEBaseBeam::width() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.width)
  return width_;
}
 void CMsgTEBaseBeam::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.width)
}

// optional float endwidth = 7;
bool CMsgTEBaseBeam::has_endwidth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgTEBaseBeam::set_has_endwidth() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgTEBaseBeam::clear_has_endwidth() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgTEBaseBeam::clear_endwidth() {
  endwidth_ = 0;
  clear_has_endwidth();
}
 float CMsgTEBaseBeam::endwidth() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.endwidth)
  return endwidth_;
}
 void CMsgTEBaseBeam::set_endwidth(float value) {
  set_has_endwidth();
  endwidth_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.endwidth)
}

// optional uint32 fadelength = 8;
bool CMsgTEBaseBeam::has_fadelength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgTEBaseBeam::set_has_fadelength() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgTEBaseBeam::clear_has_fadelength() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgTEBaseBeam::clear_fadelength() {
  fadelength_ = 0u;
  clear_has_fadelength();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::fadelength() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.fadelength)
  return fadelength_;
}
 void CMsgTEBaseBeam::set_fadelength(::google::protobuf::uint32 value) {
  set_has_fadelength();
  fadelength_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.fadelength)
}

// optional float amplitude = 9;
bool CMsgTEBaseBeam::has_amplitude() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgTEBaseBeam::set_has_amplitude() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgTEBaseBeam::clear_has_amplitude() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgTEBaseBeam::clear_amplitude() {
  amplitude_ = 0;
  clear_has_amplitude();
}
 float CMsgTEBaseBeam::amplitude() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.amplitude)
  return amplitude_;
}
 void CMsgTEBaseBeam::set_amplitude(float value) {
  set_has_amplitude();
  amplitude_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.amplitude)
}

// optional fixed32 color = 10;
bool CMsgTEBaseBeam::has_color() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void CMsgTEBaseBeam::set_has_color() {
  _has_bits_[0] |= 0x00000200u;
}
void CMsgTEBaseBeam::clear_has_color() {
  _has_bits_[0] &= ~0x00000200u;
}
void CMsgTEBaseBeam::clear_color() {
  color_ = 0u;
  clear_has_color();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::color() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.color)
  return color_;
}
 void CMsgTEBaseBeam::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.color)
}

// optional uint32 speed = 11;
bool CMsgTEBaseBeam::has_speed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void CMsgTEBaseBeam::set_has_speed() {
  _has_bits_[0] |= 0x00000400u;
}
void CMsgTEBaseBeam::clear_has_speed() {
  _has_bits_[0] &= ~0x00000400u;
}
void CMsgTEBaseBeam::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::speed() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.speed)
  return speed_;
}
 void CMsgTEBaseBeam::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.speed)
}

// optional uint32 flags = 12;
bool CMsgTEBaseBeam::has_flags() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void CMsgTEBaseBeam::set_has_flags() {
  _has_bits_[0] |= 0x00000800u;
}
void CMsgTEBaseBeam::clear_has_flags() {
  _has_bits_[0] &= ~0x00000800u;
}
void CMsgTEBaseBeam::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 CMsgTEBaseBeam::flags() const {
  // @@protoc_insertion_point(field_get:CMsgTEBaseBeam.flags)
  return flags_;
}
 void CMsgTEBaseBeam::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBaseBeam.flags)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBeamEntPoint::kBaseFieldNumber;
const int CMsgTEBeamEntPoint::kStartentityFieldNumber;
const int CMsgTEBeamEntPoint::kEndentityFieldNumber;
const int CMsgTEBeamEntPoint::kStartFieldNumber;
const int CMsgTEBeamEntPoint::kEndFieldNumber;
#endif  // !_MSC_VER

CMsgTEBeamEntPoint::CMsgTEBeamEntPoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBeamEntPoint)
}

void CMsgTEBeamEntPoint::InitAsDefaultInstance() {
  base_ = const_cast< ::CMsgTEBaseBeam*>(&::CMsgTEBaseBeam::default_instance());
  start_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  end_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEntPoint)
}

void CMsgTEBeamEntPoint::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  startentity_ = 0u;
  endentity_ = 0u;
  start_ = NULL;
  end_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBeamEntPoint::~CMsgTEBeamEntPoint() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEntPoint)
  SharedDtor();
}

void CMsgTEBeamEntPoint::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
    delete start_;
    delete end_;
  }
}

void CMsgTEBeamEntPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBeamEntPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBeamEntPoint_descriptor_;
}

const CMsgTEBeamEntPoint& CMsgTEBeamEntPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBeamEntPoint* CMsgTEBeamEntPoint::default_instance_ = NULL;

CMsgTEBeamEntPoint* CMsgTEBeamEntPoint::New(::google::protobuf::Arena* arena) const {
  CMsgTEBeamEntPoint* n = new CMsgTEBeamEntPoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBeamEntPoint::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBeamEntPoint*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(startentity_, endentity_);
    if (has_base()) {
      if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
    }
    if (has_start()) {
      if (start_ != NULL) start_->::CMsgVector::Clear();
    }
    if (has_end()) {
      if (end_ != NULL) end_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBeamEntPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBeamEntPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_startentity;
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (tag == 16) {
         parse_startentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
          set_has_startentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_endentity;
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (tag == 24) {
         parse_endentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
          set_has_endentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_start;
        break;
      }

      // optional .CMsgVector start = 4;
      case 4: {
        if (tag == 34) {
         parse_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_end;
        break;
      }

      // optional .CMsgVector end = 5;
      case 5: {
        if (tag == 42) {
         parse_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBeamEntPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBeamEntPoint)
  return false;
#undef DO_
}

void CMsgTEBeamEntPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBeamEntPoint)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  // optional .CMsgVector start = 4;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->start_, output);
  }

  // optional .CMsgVector end = 5;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->end_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBeamEntPoint)
}

::google::protobuf::uint8* CMsgTEBeamEntPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEntPoint)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->base_, target);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  // optional .CMsgVector start = 4;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->start_, target);
  }

  // optional .CMsgVector end = 5;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->end_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEntPoint)
  return target;
}

int CMsgTEBeamEntPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional uint32 startentity = 2;
    if (has_startentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (has_endentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

    // optional .CMsgVector start = 4;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->start_);
    }

    // optional .CMsgVector end = 5;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBeamEntPoint::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBeamEntPoint* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBeamEntPoint>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBeamEntPoint::MergeFrom(const CMsgTEBeamEntPoint& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (from.has_startentity()) {
      set_startentity(from.startentity());
    }
    if (from.has_endentity()) {
      set_endentity(from.endentity());
    }
    if (from.has_start()) {
      mutable_start()->::CMsgVector::MergeFrom(from.start());
    }
    if (from.has_end()) {
      mutable_end()->::CMsgVector::MergeFrom(from.end());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBeamEntPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEntPoint::CopyFrom(const CMsgTEBeamEntPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEntPoint::IsInitialized() const {

  return true;
}

void CMsgTEBeamEntPoint::Swap(CMsgTEBeamEntPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamEntPoint::InternalSwap(CMsgTEBeamEntPoint* other) {
  std::swap(base_, other->base_);
  std::swap(startentity_, other->startentity_);
  std::swap(endentity_, other->endentity_);
  std::swap(start_, other->start_);
  std::swap(end_, other->end_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBeamEntPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBeamEntPoint_descriptor_;
  metadata.reflection = CMsgTEBeamEntPoint_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBeamEntPoint

// optional .CMsgTEBaseBeam base = 1;
bool CMsgTEBeamEntPoint::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBeamEntPoint::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBeamEntPoint::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBeamEntPoint::clear_base() {
  if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
const ::CMsgTEBaseBeam& CMsgTEBeamEntPoint::base() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEntPoint.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::CMsgTEBaseBeam* CMsgTEBeamEntPoint::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamEntPoint.base)
  return base_;
}
::CMsgTEBaseBeam* CMsgTEBeamEntPoint::release_base() {
  clear_has_base();
  ::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
void CMsgTEBeamEntPoint::set_allocated_base(::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamEntPoint.base)
}

// optional uint32 startentity = 2;
bool CMsgTEBeamEntPoint::has_startentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBeamEntPoint::set_has_startentity() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBeamEntPoint::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEntPoint::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
 ::google::protobuf::uint32 CMsgTEBeamEntPoint::startentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEntPoint.startentity)
  return startentity_;
}
 void CMsgTEBeamEntPoint::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamEntPoint.startentity)
}

// optional uint32 endentity = 3;
bool CMsgTEBeamEntPoint::has_endentity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBeamEntPoint::set_has_endentity() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBeamEntPoint::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBeamEntPoint::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
 ::google::protobuf::uint32 CMsgTEBeamEntPoint::endentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEntPoint.endentity)
  return endentity_;
}
 void CMsgTEBeamEntPoint::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamEntPoint.endentity)
}

// optional .CMsgVector start = 4;
bool CMsgTEBeamEntPoint::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBeamEntPoint::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBeamEntPoint::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBeamEntPoint::clear_start() {
  if (start_ != NULL) start_->::CMsgVector::Clear();
  clear_has_start();
}
const ::CMsgVector& CMsgTEBeamEntPoint::start() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEntPoint.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
::CMsgVector* CMsgTEBeamEntPoint::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamEntPoint.start)
  return start_;
}
::CMsgVector* CMsgTEBeamEntPoint::release_start() {
  clear_has_start();
  ::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
void CMsgTEBeamEntPoint::set_allocated_start(::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamEntPoint.start)
}

// optional .CMsgVector end = 5;
bool CMsgTEBeamEntPoint::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBeamEntPoint::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBeamEntPoint::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBeamEntPoint::clear_end() {
  if (end_ != NULL) end_->::CMsgVector::Clear();
  clear_has_end();
}
const ::CMsgVector& CMsgTEBeamEntPoint::end() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEntPoint.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
::CMsgVector* CMsgTEBeamEntPoint::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    end_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamEntPoint.end)
  return end_;
}
::CMsgVector* CMsgTEBeamEntPoint::release_end() {
  clear_has_end();
  ::CMsgVector* temp = end_;
  end_ = NULL;
  return temp;
}
void CMsgTEBeamEntPoint::set_allocated_end(::CMsgVector* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamEntPoint.end)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBeamEnts::kBaseFieldNumber;
const int CMsgTEBeamEnts::kStartentityFieldNumber;
const int CMsgTEBeamEnts::kEndentityFieldNumber;
#endif  // !_MSC_VER

CMsgTEBeamEnts::CMsgTEBeamEnts()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBeamEnts)
}

void CMsgTEBeamEnts::InitAsDefaultInstance() {
  base_ = const_cast< ::CMsgTEBaseBeam*>(&::CMsgTEBaseBeam::default_instance());
}

CMsgTEBeamEnts::CMsgTEBeamEnts(const CMsgTEBeamEnts& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEnts)
}

void CMsgTEBeamEnts::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  startentity_ = 0u;
  endentity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBeamEnts::~CMsgTEBeamEnts() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEnts)
  SharedDtor();
}

void CMsgTEBeamEnts::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void CMsgTEBeamEnts::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBeamEnts::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBeamEnts_descriptor_;
}

const CMsgTEBeamEnts& CMsgTEBeamEnts::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBeamEnts* CMsgTEBeamEnts::default_instance_ = NULL;

CMsgTEBeamEnts* CMsgTEBeamEnts::New(::google::protobuf::Arena* arena) const {
  CMsgTEBeamEnts* n = new CMsgTEBeamEnts;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBeamEnts::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBeamEnts*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(startentity_, endentity_);
    if (has_base()) {
      if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBeamEnts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBeamEnts)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_startentity;
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (tag == 16) {
         parse_startentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
          set_has_startentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_endentity;
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (tag == 24) {
         parse_endentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
          set_has_endentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBeamEnts)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBeamEnts)
  return false;
#undef DO_
}

void CMsgTEBeamEnts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBeamEnts)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBeamEnts)
}

::google::protobuf::uint8* CMsgTEBeamEnts::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEnts)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->base_, target);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEnts)
  return target;
}

int CMsgTEBeamEnts::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional uint32 startentity = 2;
    if (has_startentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (has_endentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBeamEnts::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBeamEnts* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBeamEnts>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBeamEnts::MergeFrom(const CMsgTEBeamEnts& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (from.has_startentity()) {
      set_startentity(from.startentity());
    }
    if (from.has_endentity()) {
      set_endentity(from.endentity());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBeamEnts::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEnts::CopyFrom(const CMsgTEBeamEnts& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEnts::IsInitialized() const {

  return true;
}

void CMsgTEBeamEnts::Swap(CMsgTEBeamEnts* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamEnts::InternalSwap(CMsgTEBeamEnts* other) {
  std::swap(base_, other->base_);
  std::swap(startentity_, other->startentity_);
  std::swap(endentity_, other->endentity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBeamEnts::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBeamEnts_descriptor_;
  metadata.reflection = CMsgTEBeamEnts_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBeamEnts

// optional .CMsgTEBaseBeam base = 1;
bool CMsgTEBeamEnts::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBeamEnts::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBeamEnts::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBeamEnts::clear_base() {
  if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
const ::CMsgTEBaseBeam& CMsgTEBeamEnts::base() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEnts.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::CMsgTEBaseBeam* CMsgTEBeamEnts::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamEnts.base)
  return base_;
}
::CMsgTEBaseBeam* CMsgTEBeamEnts::release_base() {
  clear_has_base();
  ::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
void CMsgTEBeamEnts::set_allocated_base(::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamEnts.base)
}

// optional uint32 startentity = 2;
bool CMsgTEBeamEnts::has_startentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBeamEnts::set_has_startentity() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBeamEnts::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEnts::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
 ::google::protobuf::uint32 CMsgTEBeamEnts::startentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEnts.startentity)
  return startentity_;
}
 void CMsgTEBeamEnts::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamEnts.startentity)
}

// optional uint32 endentity = 3;
bool CMsgTEBeamEnts::has_endentity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBeamEnts::set_has_endentity() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBeamEnts::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBeamEnts::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
 ::google::protobuf::uint32 CMsgTEBeamEnts::endentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamEnts.endentity)
  return endentity_;
}
 void CMsgTEBeamEnts::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamEnts.endentity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBeamPoints::kBaseFieldNumber;
const int CMsgTEBeamPoints::kStartFieldNumber;
const int CMsgTEBeamPoints::kEndFieldNumber;
#endif  // !_MSC_VER

CMsgTEBeamPoints::CMsgTEBeamPoints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBeamPoints)
}

void CMsgTEBeamPoints::InitAsDefaultInstance() {
  base_ = const_cast< ::CMsgTEBaseBeam*>(&::CMsgTEBaseBeam::default_instance());
  start_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  end_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBeamPoints::CMsgTEBeamPoints(const CMsgTEBeamPoints& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamPoints)
}

void CMsgTEBeamPoints::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  start_ = NULL;
  end_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBeamPoints::~CMsgTEBeamPoints() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamPoints)
  SharedDtor();
}

void CMsgTEBeamPoints::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
    delete start_;
    delete end_;
  }
}

void CMsgTEBeamPoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBeamPoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBeamPoints_descriptor_;
}

const CMsgTEBeamPoints& CMsgTEBeamPoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBeamPoints* CMsgTEBeamPoints::default_instance_ = NULL;

CMsgTEBeamPoints* CMsgTEBeamPoints::New(::google::protobuf::Arena* arena) const {
  CMsgTEBeamPoints* n = new CMsgTEBeamPoints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBeamPoints::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_base()) {
      if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
    }
    if (has_start()) {
      if (start_ != NULL) start_->::CMsgVector::Clear();
    }
    if (has_end()) {
      if (end_ != NULL) end_->::CMsgVector::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBeamPoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBeamPoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_start;
        break;
      }

      // optional .CMsgVector start = 2;
      case 2: {
        if (tag == 18) {
         parse_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_end;
        break;
      }

      // optional .CMsgVector end = 3;
      case 3: {
        if (tag == 26) {
         parse_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBeamPoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBeamPoints)
  return false;
#undef DO_
}

void CMsgTEBeamPoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBeamPoints)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->start_, output);
  }

  // optional .CMsgVector end = 3;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->end_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBeamPoints)
}

::google::protobuf::uint8* CMsgTEBeamPoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamPoints)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->base_, target);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->start_, target);
  }

  // optional .CMsgVector end = 3;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->end_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamPoints)
  return target;
}

int CMsgTEBeamPoints::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional .CMsgVector start = 2;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->start_);
    }

    // optional .CMsgVector end = 3;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBeamPoints::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBeamPoints* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBeamPoints>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBeamPoints::MergeFrom(const CMsgTEBeamPoints& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (from.has_start()) {
      mutable_start()->::CMsgVector::MergeFrom(from.start());
    }
    if (from.has_end()) {
      mutable_end()->::CMsgVector::MergeFrom(from.end());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBeamPoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamPoints::CopyFrom(const CMsgTEBeamPoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamPoints::IsInitialized() const {

  return true;
}

void CMsgTEBeamPoints::Swap(CMsgTEBeamPoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamPoints::InternalSwap(CMsgTEBeamPoints* other) {
  std::swap(base_, other->base_);
  std::swap(start_, other->start_);
  std::swap(end_, other->end_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBeamPoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBeamPoints_descriptor_;
  metadata.reflection = CMsgTEBeamPoints_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBeamPoints

// optional .CMsgTEBaseBeam base = 1;
bool CMsgTEBeamPoints::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBeamPoints::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBeamPoints::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBeamPoints::clear_base() {
  if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
const ::CMsgTEBaseBeam& CMsgTEBeamPoints::base() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamPoints.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::CMsgTEBaseBeam* CMsgTEBeamPoints::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamPoints.base)
  return base_;
}
::CMsgTEBaseBeam* CMsgTEBeamPoints::release_base() {
  clear_has_base();
  ::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
void CMsgTEBeamPoints::set_allocated_base(::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamPoints.base)
}

// optional .CMsgVector start = 2;
bool CMsgTEBeamPoints::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBeamPoints::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBeamPoints::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamPoints::clear_start() {
  if (start_ != NULL) start_->::CMsgVector::Clear();
  clear_has_start();
}
const ::CMsgVector& CMsgTEBeamPoints::start() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamPoints.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
::CMsgVector* CMsgTEBeamPoints::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamPoints.start)
  return start_;
}
::CMsgVector* CMsgTEBeamPoints::release_start() {
  clear_has_start();
  ::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
void CMsgTEBeamPoints::set_allocated_start(::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamPoints.start)
}

// optional .CMsgVector end = 3;
bool CMsgTEBeamPoints::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBeamPoints::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBeamPoints::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBeamPoints::clear_end() {
  if (end_ != NULL) end_->::CMsgVector::Clear();
  clear_has_end();
}
const ::CMsgVector& CMsgTEBeamPoints::end() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamPoints.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
::CMsgVector* CMsgTEBeamPoints::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    end_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamPoints.end)
  return end_;
}
::CMsgVector* CMsgTEBeamPoints::release_end() {
  clear_has_end();
  ::CMsgVector* temp = end_;
  end_ = NULL;
  return temp;
}
void CMsgTEBeamPoints::set_allocated_end(::CMsgVector* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamPoints.end)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBeamRing::kBaseFieldNumber;
const int CMsgTEBeamRing::kStartentityFieldNumber;
const int CMsgTEBeamRing::kEndentityFieldNumber;
#endif  // !_MSC_VER

CMsgTEBeamRing::CMsgTEBeamRing()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBeamRing)
}

void CMsgTEBeamRing::InitAsDefaultInstance() {
  base_ = const_cast< ::CMsgTEBaseBeam*>(&::CMsgTEBaseBeam::default_instance());
}

CMsgTEBeamRing::CMsgTEBeamRing(const CMsgTEBeamRing& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamRing)
}

void CMsgTEBeamRing::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  startentity_ = 0u;
  endentity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBeamRing::~CMsgTEBeamRing() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamRing)
  SharedDtor();
}

void CMsgTEBeamRing::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

void CMsgTEBeamRing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBeamRing::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBeamRing_descriptor_;
}

const CMsgTEBeamRing& CMsgTEBeamRing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBeamRing* CMsgTEBeamRing::default_instance_ = NULL;

CMsgTEBeamRing* CMsgTEBeamRing::New(::google::protobuf::Arena* arena) const {
  CMsgTEBeamRing* n = new CMsgTEBeamRing;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBeamRing::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBeamRing*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(startentity_, endentity_);
    if (has_base()) {
      if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBeamRing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBeamRing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_startentity;
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (tag == 16) {
         parse_startentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
          set_has_startentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_endentity;
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (tag == 24) {
         parse_endentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
          set_has_endentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBeamRing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBeamRing)
  return false;
#undef DO_
}

void CMsgTEBeamRing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBeamRing)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBeamRing)
}

::google::protobuf::uint8* CMsgTEBeamRing::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamRing)
  // optional .CMsgTEBaseBeam base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->base_, target);
  }

  // optional uint32 startentity = 2;
  if (has_startentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (has_endentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamRing)
  return target;
}

int CMsgTEBeamRing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional uint32 startentity = 2;
    if (has_startentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (has_endentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBeamRing::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBeamRing* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBeamRing>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBeamRing::MergeFrom(const CMsgTEBeamRing& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (from.has_startentity()) {
      set_startentity(from.startentity());
    }
    if (from.has_endentity()) {
      set_endentity(from.endentity());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBeamRing::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamRing::CopyFrom(const CMsgTEBeamRing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamRing::IsInitialized() const {

  return true;
}

void CMsgTEBeamRing::Swap(CMsgTEBeamRing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamRing::InternalSwap(CMsgTEBeamRing* other) {
  std::swap(base_, other->base_);
  std::swap(startentity_, other->startentity_);
  std::swap(endentity_, other->endentity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBeamRing::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBeamRing_descriptor_;
  metadata.reflection = CMsgTEBeamRing_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBeamRing

// optional .CMsgTEBaseBeam base = 1;
bool CMsgTEBeamRing::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBeamRing::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBeamRing::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBeamRing::clear_base() {
  if (base_ != NULL) base_->::CMsgTEBaseBeam::Clear();
  clear_has_base();
}
const ::CMsgTEBaseBeam& CMsgTEBeamRing::base() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamRing.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::CMsgTEBaseBeam* CMsgTEBeamRing::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::CMsgTEBaseBeam;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBeamRing.base)
  return base_;
}
::CMsgTEBaseBeam* CMsgTEBeamRing::release_base() {
  clear_has_base();
  ::CMsgTEBaseBeam* temp = base_;
  base_ = NULL;
  return temp;
}
void CMsgTEBeamRing::set_allocated_base(::CMsgTEBaseBeam* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBeamRing.base)
}

// optional uint32 startentity = 2;
bool CMsgTEBeamRing::has_startentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBeamRing::set_has_startentity() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBeamRing::clear_has_startentity() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamRing::clear_startentity() {
  startentity_ = 0u;
  clear_has_startentity();
}
 ::google::protobuf::uint32 CMsgTEBeamRing::startentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamRing.startentity)
  return startentity_;
}
 void CMsgTEBeamRing::set_startentity(::google::protobuf::uint32 value) {
  set_has_startentity();
  startentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamRing.startentity)
}

// optional uint32 endentity = 3;
bool CMsgTEBeamRing::has_endentity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBeamRing::set_has_endentity() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBeamRing::clear_has_endentity() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBeamRing::clear_endentity() {
  endentity_ = 0u;
  clear_has_endentity();
}
 ::google::protobuf::uint32 CMsgTEBeamRing::endentity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBeamRing.endentity)
  return endentity_;
}
 void CMsgTEBeamRing::set_endentity(::google::protobuf::uint32 value) {
  set_has_endentity();
  endentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBeamRing.endentity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBreakModel::kOriginFieldNumber;
const int CMsgTEBreakModel::kAnglesFieldNumber;
const int CMsgTEBreakModel::kSizeFieldNumber;
const int CMsgTEBreakModel::kVelocityFieldNumber;
const int CMsgTEBreakModel::kRandomizationFieldNumber;
const int CMsgTEBreakModel::kModelindexFieldNumber;
const int CMsgTEBreakModel::kCountFieldNumber;
const int CMsgTEBreakModel::kTimeFieldNumber;
const int CMsgTEBreakModel::kFlagsFieldNumber;
#endif  // !_MSC_VER

CMsgTEBreakModel::CMsgTEBreakModel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBreakModel)
}

void CMsgTEBreakModel::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
  size_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  velocity_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBreakModel::CMsgTEBreakModel(const CMsgTEBreakModel& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBreakModel)
}

void CMsgTEBreakModel::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  angles_ = NULL;
  size_ = NULL;
  velocity_ = NULL;
  randomization_ = 0u;
  modelindex_ = GOOGLE_ULONGLONG(0);
  count_ = 0u;
  time_ = 0;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBreakModel::~CMsgTEBreakModel() {
  // @@protoc_insertion_point(destructor:CMsgTEBreakModel)
  SharedDtor();
}

void CMsgTEBreakModel::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete angles_;
    delete size_;
    delete velocity_;
  }
}

void CMsgTEBreakModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBreakModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBreakModel_descriptor_;
}

const CMsgTEBreakModel& CMsgTEBreakModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBreakModel* CMsgTEBreakModel::default_instance_ = NULL;

CMsgTEBreakModel* CMsgTEBreakModel::New(::google::protobuf::Arena* arena) const {
  CMsgTEBreakModel* n = new CMsgTEBreakModel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBreakModel::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBreakModel*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(modelindex_, time_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
    if (has_size()) {
      if (size_ != NULL) size_->::CMsgVector::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::CMsgVector::Clear();
    }
  }
  flags_ = 0u;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBreakModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBreakModel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 2;
      case 2: {
        if (tag == 18) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_size;
        break;
      }

      // optional .CMsgVector size = 3;
      case 3: {
        if (tag == 26) {
         parse_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_velocity;
        break;
      }

      // optional .CMsgVector velocity = 4;
      case 4: {
        if (tag == 34) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_randomization;
        break;
      }

      // optional uint32 randomization = 5;
      case 5: {
        if (tag == 40) {
         parse_randomization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &randomization_)));
          set_has_randomization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_modelindex;
        break;
      }

      // optional fixed64 modelindex = 6;
      case 6: {
        if (tag == 49) {
         parse_modelindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
          set_has_modelindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_count;
        break;
      }

      // optional uint32 count = 7;
      case 7: {
        if (tag == 56) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_time;
        break;
      }

      // optional float time = 8;
      case 8: {
        if (tag == 69) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 9;
      case 9: {
        if (tag == 72) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBreakModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBreakModel)
  return false;
#undef DO_
}

void CMsgTEBreakModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBreakModel)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angles_, output);
  }

  // optional .CMsgVector size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->size_, output);
  }

  // optional .CMsgVector velocity = 4;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->velocity_, output);
  }

  // optional uint32 randomization = 5;
  if (has_randomization()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->randomization(), output);
  }

  // optional fixed64 modelindex = 6;
  if (has_modelindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(6, this->modelindex(), output);
  }

  // optional uint32 count = 7;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->count(), output);
  }

  // optional float time = 8;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->time(), output);
  }

  // optional uint32 flags = 9;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->flags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBreakModel)
}

::google::protobuf::uint8* CMsgTEBreakModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBreakModel)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->angles_, target);
  }

  // optional .CMsgVector size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->size_, target);
  }

  // optional .CMsgVector velocity = 4;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->velocity_, target);
  }

  // optional uint32 randomization = 5;
  if (has_randomization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->randomization(), target);
  }

  // optional fixed64 modelindex = 6;
  if (has_modelindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(6, this->modelindex(), target);
  }

  // optional uint32 count = 7;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->count(), target);
  }

  // optional float time = 8;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->time(), target);
  }

  // optional uint32 flags = 9;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->flags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBreakModel)
  return target;
}

int CMsgTEBreakModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional .CMsgVector size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->size_);
    }

    // optional .CMsgVector velocity = 4;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->velocity_);
    }

    // optional uint32 randomization = 5;
    if (has_randomization()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->randomization());
    }

    // optional fixed64 modelindex = 6;
    if (has_modelindex()) {
      total_size += 1 + 8;
    }

    // optional uint32 count = 7;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float time = 8;
    if (has_time()) {
      total_size += 1 + 4;
    }

  }
  // optional uint32 flags = 9;
  if (has_flags()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBreakModel::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBreakModel* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBreakModel>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBreakModel::MergeFrom(const CMsgTEBreakModel& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_size()) {
      mutable_size()->::CMsgVector::MergeFrom(from.size());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::CMsgVector::MergeFrom(from.velocity());
    }
    if (from.has_randomization()) {
      set_randomization(from.randomization());
    }
    if (from.has_modelindex()) {
      set_modelindex(from.modelindex());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBreakModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBreakModel::CopyFrom(const CMsgTEBreakModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBreakModel::IsInitialized() const {

  return true;
}

void CMsgTEBreakModel::Swap(CMsgTEBreakModel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBreakModel::InternalSwap(CMsgTEBreakModel* other) {
  std::swap(origin_, other->origin_);
  std::swap(angles_, other->angles_);
  std::swap(size_, other->size_);
  std::swap(velocity_, other->velocity_);
  std::swap(randomization_, other->randomization_);
  std::swap(modelindex_, other->modelindex_);
  std::swap(count_, other->count_);
  std::swap(time_, other->time_);
  std::swap(flags_, other->flags_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBreakModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBreakModel_descriptor_;
  metadata.reflection = CMsgTEBreakModel_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBreakModel

// optional .CMsgVector origin = 1;
bool CMsgTEBreakModel::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBreakModel::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBreakModel::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBreakModel::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEBreakModel::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEBreakModel::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBreakModel.origin)
  return origin_;
}
::CMsgVector* CMsgTEBreakModel::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEBreakModel::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBreakModel.origin)
}

// optional .CMsgQAngle angles = 2;
bool CMsgTEBreakModel::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBreakModel::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBreakModel::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBreakModel::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgTEBreakModel::angles() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgTEBreakModel::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBreakModel.angles)
  return angles_;
}
::CMsgQAngle* CMsgTEBreakModel::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgTEBreakModel::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBreakModel.angles)
}

// optional .CMsgVector size = 3;
bool CMsgTEBreakModel::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBreakModel::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBreakModel::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBreakModel::clear_size() {
  if (size_ != NULL) size_->::CMsgVector::Clear();
  clear_has_size();
}
const ::CMsgVector& CMsgTEBreakModel::size() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.size)
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
::CMsgVector* CMsgTEBreakModel::mutable_size() {
  set_has_size();
  if (size_ == NULL) {
    size_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBreakModel.size)
  return size_;
}
::CMsgVector* CMsgTEBreakModel::release_size() {
  clear_has_size();
  ::CMsgVector* temp = size_;
  size_ = NULL;
  return temp;
}
void CMsgTEBreakModel::set_allocated_size(::CMsgVector* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBreakModel.size)
}

// optional .CMsgVector velocity = 4;
bool CMsgTEBreakModel::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBreakModel::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBreakModel::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBreakModel::clear_velocity() {
  if (velocity_ != NULL) velocity_->::CMsgVector::Clear();
  clear_has_velocity();
}
const ::CMsgVector& CMsgTEBreakModel::velocity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
::CMsgVector* CMsgTEBreakModel::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBreakModel.velocity)
  return velocity_;
}
::CMsgVector* CMsgTEBreakModel::release_velocity() {
  clear_has_velocity();
  ::CMsgVector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
void CMsgTEBreakModel::set_allocated_velocity(::CMsgVector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBreakModel.velocity)
}

// optional uint32 randomization = 5;
bool CMsgTEBreakModel::has_randomization() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBreakModel::set_has_randomization() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBreakModel::clear_has_randomization() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBreakModel::clear_randomization() {
  randomization_ = 0u;
  clear_has_randomization();
}
 ::google::protobuf::uint32 CMsgTEBreakModel::randomization() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.randomization)
  return randomization_;
}
 void CMsgTEBreakModel::set_randomization(::google::protobuf::uint32 value) {
  set_has_randomization();
  randomization_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBreakModel.randomization)
}

// optional fixed64 modelindex = 6;
bool CMsgTEBreakModel::has_modelindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgTEBreakModel::set_has_modelindex() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgTEBreakModel::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgTEBreakModel::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
 ::google::protobuf::uint64 CMsgTEBreakModel::modelindex() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.modelindex)
  return modelindex_;
}
 void CMsgTEBreakModel::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBreakModel.modelindex)
}

// optional uint32 count = 7;
bool CMsgTEBreakModel::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgTEBreakModel::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgTEBreakModel::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgTEBreakModel::clear_count() {
  count_ = 0u;
  clear_has_count();
}
 ::google::protobuf::uint32 CMsgTEBreakModel::count() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.count)
  return count_;
}
 void CMsgTEBreakModel::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBreakModel.count)
}

// optional float time = 8;
bool CMsgTEBreakModel::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgTEBreakModel::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgTEBreakModel::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgTEBreakModel::clear_time() {
  time_ = 0;
  clear_has_time();
}
 float CMsgTEBreakModel::time() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.time)
  return time_;
}
 void CMsgTEBreakModel::set_time(float value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBreakModel.time)
}

// optional uint32 flags = 9;
bool CMsgTEBreakModel::has_flags() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgTEBreakModel::set_has_flags() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgTEBreakModel::clear_has_flags() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgTEBreakModel::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 CMsgTEBreakModel::flags() const {
  // @@protoc_insertion_point(field_get:CMsgTEBreakModel.flags)
  return flags_;
}
 void CMsgTEBreakModel::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBreakModel.flags)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBSPDecal::kOriginFieldNumber;
const int CMsgTEBSPDecal::kNormalFieldNumber;
const int CMsgTEBSPDecal::kSaxisFieldNumber;
const int CMsgTEBSPDecal::kEntityFieldNumber;
const int CMsgTEBSPDecal::kIndexFieldNumber;
#endif  // !_MSC_VER

CMsgTEBSPDecal::CMsgTEBSPDecal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBSPDecal)
}

void CMsgTEBSPDecal::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  normal_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  saxis_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBSPDecal::CMsgTEBSPDecal(const CMsgTEBSPDecal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBSPDecal)
}

void CMsgTEBSPDecal::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  normal_ = NULL;
  saxis_ = NULL;
  entity_ = 0u;
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBSPDecal::~CMsgTEBSPDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEBSPDecal)
  SharedDtor();
}

void CMsgTEBSPDecal::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete normal_;
    delete saxis_;
  }
}

void CMsgTEBSPDecal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBSPDecal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBSPDecal_descriptor_;
}

const CMsgTEBSPDecal& CMsgTEBSPDecal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBSPDecal* CMsgTEBSPDecal::default_instance_ = NULL;

CMsgTEBSPDecal* CMsgTEBSPDecal::New(::google::protobuf::Arena* arena) const {
  CMsgTEBSPDecal* n = new CMsgTEBSPDecal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBSPDecal::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBSPDecal*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(entity_, index_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::CMsgVector::Clear();
    }
    if (has_saxis()) {
      if (saxis_ != NULL) saxis_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBSPDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBSPDecal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_normal;
        break;
      }

      // optional .CMsgVector normal = 2;
      case 2: {
        if (tag == 18) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_saxis;
        break;
      }

      // optional .CMsgVector saxis = 3;
      case 3: {
        if (tag == 26) {
         parse_saxis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_saxis()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_entity;
        break;
      }

      // optional uint32 entity = 4;
      case 4: {
        if (tag == 32) {
         parse_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_index;
        break;
      }

      // optional uint32 index = 5;
      case 5: {
        if (tag == 40) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBSPDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBSPDecal)
  return false;
#undef DO_
}

void CMsgTEBSPDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBSPDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->normal_, output);
  }

  // optional .CMsgVector saxis = 3;
  if (has_saxis()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->saxis_, output);
  }

  // optional uint32 entity = 4;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->entity(), output);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBSPDecal)
}

::google::protobuf::uint8* CMsgTEBSPDecal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBSPDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->normal_, target);
  }

  // optional .CMsgVector saxis = 3;
  if (has_saxis()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->saxis_, target);
  }

  // optional uint32 entity = 4;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->entity(), target);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBSPDecal)
  return target;
}

int CMsgTEBSPDecal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector normal = 2;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->normal_);
    }

    // optional .CMsgVector saxis = 3;
    if (has_saxis()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->saxis_);
    }

    // optional uint32 entity = 4;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 index = 5;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBSPDecal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBSPDecal* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBSPDecal>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBSPDecal::MergeFrom(const CMsgTEBSPDecal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_normal()) {
      mutable_normal()->::CMsgVector::MergeFrom(from.normal());
    }
    if (from.has_saxis()) {
      mutable_saxis()->::CMsgVector::MergeFrom(from.saxis());
    }
    if (from.has_entity()) {
      set_entity(from.entity());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBSPDecal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBSPDecal::CopyFrom(const CMsgTEBSPDecal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBSPDecal::IsInitialized() const {

  return true;
}

void CMsgTEBSPDecal::Swap(CMsgTEBSPDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBSPDecal::InternalSwap(CMsgTEBSPDecal* other) {
  std::swap(origin_, other->origin_);
  std::swap(normal_, other->normal_);
  std::swap(saxis_, other->saxis_);
  std::swap(entity_, other->entity_);
  std::swap(index_, other->index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBSPDecal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBSPDecal_descriptor_;
  metadata.reflection = CMsgTEBSPDecal_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBSPDecal

// optional .CMsgVector origin = 1;
bool CMsgTEBSPDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBSPDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBSPDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBSPDecal::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEBSPDecal::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEBSPDecal.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEBSPDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBSPDecal.origin)
  return origin_;
}
::CMsgVector* CMsgTEBSPDecal::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEBSPDecal::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBSPDecal.origin)
}

// optional .CMsgVector normal = 2;
bool CMsgTEBSPDecal::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBSPDecal::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBSPDecal::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBSPDecal::clear_normal() {
  if (normal_ != NULL) normal_->::CMsgVector::Clear();
  clear_has_normal();
}
const ::CMsgVector& CMsgTEBSPDecal::normal() const {
  // @@protoc_insertion_point(field_get:CMsgTEBSPDecal.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
::CMsgVector* CMsgTEBSPDecal::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBSPDecal.normal)
  return normal_;
}
::CMsgVector* CMsgTEBSPDecal::release_normal() {
  clear_has_normal();
  ::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
void CMsgTEBSPDecal::set_allocated_normal(::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBSPDecal.normal)
}

// optional .CMsgVector saxis = 3;
bool CMsgTEBSPDecal::has_saxis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBSPDecal::set_has_saxis() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBSPDecal::clear_has_saxis() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBSPDecal::clear_saxis() {
  if (saxis_ != NULL) saxis_->::CMsgVector::Clear();
  clear_has_saxis();
}
const ::CMsgVector& CMsgTEBSPDecal::saxis() const {
  // @@protoc_insertion_point(field_get:CMsgTEBSPDecal.saxis)
  return saxis_ != NULL ? *saxis_ : *default_instance_->saxis_;
}
::CMsgVector* CMsgTEBSPDecal::mutable_saxis() {
  set_has_saxis();
  if (saxis_ == NULL) {
    saxis_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBSPDecal.saxis)
  return saxis_;
}
::CMsgVector* CMsgTEBSPDecal::release_saxis() {
  clear_has_saxis();
  ::CMsgVector* temp = saxis_;
  saxis_ = NULL;
  return temp;
}
void CMsgTEBSPDecal::set_allocated_saxis(::CMsgVector* saxis) {
  delete saxis_;
  saxis_ = saxis;
  if (saxis) {
    set_has_saxis();
  } else {
    clear_has_saxis();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBSPDecal.saxis)
}

// optional uint32 entity = 4;
bool CMsgTEBSPDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBSPDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBSPDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBSPDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
 ::google::protobuf::uint32 CMsgTEBSPDecal::entity() const {
  // @@protoc_insertion_point(field_get:CMsgTEBSPDecal.entity)
  return entity_;
}
 void CMsgTEBSPDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBSPDecal.entity)
}

// optional uint32 index = 5;
bool CMsgTEBSPDecal::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBSPDecal::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBSPDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBSPDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 CMsgTEBSPDecal::index() const {
  // @@protoc_insertion_point(field_get:CMsgTEBSPDecal.index)
  return index_;
}
 void CMsgTEBSPDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBSPDecal.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBubbles::kMinsFieldNumber;
const int CMsgTEBubbles::kMaxsFieldNumber;
const int CMsgTEBubbles::kHeightFieldNumber;
const int CMsgTEBubbles::kCountFieldNumber;
const int CMsgTEBubbles::kSpeedFieldNumber;
#endif  // !_MSC_VER

CMsgTEBubbles::CMsgTEBubbles()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBubbles)
}

void CMsgTEBubbles::InitAsDefaultInstance() {
  mins_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  maxs_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBubbles::CMsgTEBubbles(const CMsgTEBubbles& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbles)
}

void CMsgTEBubbles::SharedCtor() {
  _cached_size_ = 0;
  mins_ = NULL;
  maxs_ = NULL;
  height_ = 0;
  count_ = 0u;
  speed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBubbles::~CMsgTEBubbles() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbles)
  SharedDtor();
}

void CMsgTEBubbles::SharedDtor() {
  if (this != default_instance_) {
    delete mins_;
    delete maxs_;
  }
}

void CMsgTEBubbles::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBubbles::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBubbles_descriptor_;
}

const CMsgTEBubbles& CMsgTEBubbles::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBubbles* CMsgTEBubbles::default_instance_ = NULL;

CMsgTEBubbles* CMsgTEBubbles::New(::google::protobuf::Arena* arena) const {
  CMsgTEBubbles* n = new CMsgTEBubbles;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBubbles::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBubbles*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(height_, speed_);
    if (has_mins()) {
      if (mins_ != NULL) mins_->::CMsgVector::Clear();
    }
    if (has_maxs()) {
      if (maxs_ != NULL) maxs_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBubbles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBubbles)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector mins = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mins()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_maxs;
        break;
      }

      // optional .CMsgVector maxs = 2;
      case 2: {
        if (tag == 18) {
         parse_maxs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_maxs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_height;
        break;
      }

      // optional float height = 3;
      case 3: {
        if (tag == 29) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (tag == 32) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_speed;
        break;
      }

      // optional float speed = 5;
      case 5: {
        if (tag == 45) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBubbles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBubbles)
  return false;
#undef DO_
}

void CMsgTEBubbles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBubbles)
  // optional .CMsgVector mins = 1;
  if (has_mins()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->mins_, output);
  }

  // optional .CMsgVector maxs = 2;
  if (has_maxs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->maxs_, output);
  }

  // optional float height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  // optional float speed = 5;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBubbles)
}

::google::protobuf::uint8* CMsgTEBubbles::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbles)
  // optional .CMsgVector mins = 1;
  if (has_mins()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->mins_, target);
  }

  // optional .CMsgVector maxs = 2;
  if (has_maxs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->maxs_, target);
  }

  // optional float height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->count(), target);
  }

  // optional float speed = 5;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbles)
  return target;
}

int CMsgTEBubbles::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .CMsgVector mins = 1;
    if (has_mins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (has_maxs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->maxs_);
    }

    // optional float height = 3;
    if (has_height()) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float speed = 5;
    if (has_speed()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBubbles::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBubbles* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBubbles>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBubbles::MergeFrom(const CMsgTEBubbles& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mins()) {
      mutable_mins()->::CMsgVector::MergeFrom(from.mins());
    }
    if (from.has_maxs()) {
      mutable_maxs()->::CMsgVector::MergeFrom(from.maxs());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBubbles::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbles::CopyFrom(const CMsgTEBubbles& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbles::IsInitialized() const {

  return true;
}

void CMsgTEBubbles::Swap(CMsgTEBubbles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBubbles::InternalSwap(CMsgTEBubbles* other) {
  std::swap(mins_, other->mins_);
  std::swap(maxs_, other->maxs_);
  std::swap(height_, other->height_);
  std::swap(count_, other->count_);
  std::swap(speed_, other->speed_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBubbles::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBubbles_descriptor_;
  metadata.reflection = CMsgTEBubbles_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBubbles

// optional .CMsgVector mins = 1;
bool CMsgTEBubbles::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBubbles::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBubbles::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbles::clear_mins() {
  if (mins_ != NULL) mins_->::CMsgVector::Clear();
  clear_has_mins();
}
const ::CMsgVector& CMsgTEBubbles::mins() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbles.mins)
  return mins_ != NULL ? *mins_ : *default_instance_->mins_;
}
::CMsgVector* CMsgTEBubbles::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) {
    mins_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBubbles.mins)
  return mins_;
}
::CMsgVector* CMsgTEBubbles::release_mins() {
  clear_has_mins();
  ::CMsgVector* temp = mins_;
  mins_ = NULL;
  return temp;
}
void CMsgTEBubbles::set_allocated_mins(::CMsgVector* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBubbles.mins)
}

// optional .CMsgVector maxs = 2;
bool CMsgTEBubbles::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBubbles::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBubbles::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBubbles::clear_maxs() {
  if (maxs_ != NULL) maxs_->::CMsgVector::Clear();
  clear_has_maxs();
}
const ::CMsgVector& CMsgTEBubbles::maxs() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbles.maxs)
  return maxs_ != NULL ? *maxs_ : *default_instance_->maxs_;
}
::CMsgVector* CMsgTEBubbles::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) {
    maxs_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBubbles.maxs)
  return maxs_;
}
::CMsgVector* CMsgTEBubbles::release_maxs() {
  clear_has_maxs();
  ::CMsgVector* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
void CMsgTEBubbles::set_allocated_maxs(::CMsgVector* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBubbles.maxs)
}

// optional float height = 3;
bool CMsgTEBubbles::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBubbles::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBubbles::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBubbles::clear_height() {
  height_ = 0;
  clear_has_height();
}
 float CMsgTEBubbles::height() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbles.height)
  return height_;
}
 void CMsgTEBubbles::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbles.height)
}

// optional uint32 count = 4;
bool CMsgTEBubbles::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBubbles::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBubbles::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBubbles::clear_count() {
  count_ = 0u;
  clear_has_count();
}
 ::google::protobuf::uint32 CMsgTEBubbles::count() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbles.count)
  return count_;
}
 void CMsgTEBubbles::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbles.count)
}

// optional float speed = 5;
bool CMsgTEBubbles::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBubbles::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBubbles::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBubbles::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float CMsgTEBubbles::speed() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbles.speed)
  return speed_;
}
 void CMsgTEBubbles::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbles.speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBubbleTrail::kMinsFieldNumber;
const int CMsgTEBubbleTrail::kMaxsFieldNumber;
const int CMsgTEBubbleTrail::kWaterzFieldNumber;
const int CMsgTEBubbleTrail::kCountFieldNumber;
const int CMsgTEBubbleTrail::kSpeedFieldNumber;
#endif  // !_MSC_VER

CMsgTEBubbleTrail::CMsgTEBubbleTrail()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBubbleTrail)
}

void CMsgTEBubbleTrail::InitAsDefaultInstance() {
  mins_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  maxs_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBubbleTrail::CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbleTrail)
}

void CMsgTEBubbleTrail::SharedCtor() {
  _cached_size_ = 0;
  mins_ = NULL;
  maxs_ = NULL;
  waterz_ = 0;
  count_ = 0u;
  speed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBubbleTrail::~CMsgTEBubbleTrail() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbleTrail)
  SharedDtor();
}

void CMsgTEBubbleTrail::SharedDtor() {
  if (this != default_instance_) {
    delete mins_;
    delete maxs_;
  }
}

void CMsgTEBubbleTrail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBubbleTrail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBubbleTrail_descriptor_;
}

const CMsgTEBubbleTrail& CMsgTEBubbleTrail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBubbleTrail* CMsgTEBubbleTrail::default_instance_ = NULL;

CMsgTEBubbleTrail* CMsgTEBubbleTrail::New(::google::protobuf::Arena* arena) const {
  CMsgTEBubbleTrail* n = new CMsgTEBubbleTrail;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBubbleTrail::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBubbleTrail*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(waterz_, speed_);
    if (has_mins()) {
      if (mins_ != NULL) mins_->::CMsgVector::Clear();
    }
    if (has_maxs()) {
      if (maxs_ != NULL) maxs_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBubbleTrail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBubbleTrail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector mins = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mins()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_maxs;
        break;
      }

      // optional .CMsgVector maxs = 2;
      case 2: {
        if (tag == 18) {
         parse_maxs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_maxs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_waterz;
        break;
      }

      // optional float waterz = 3;
      case 3: {
        if (tag == 29) {
         parse_waterz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &waterz_)));
          set_has_waterz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (tag == 32) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_speed;
        break;
      }

      // optional float speed = 5;
      case 5: {
        if (tag == 45) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBubbleTrail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBubbleTrail)
  return false;
#undef DO_
}

void CMsgTEBubbleTrail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBubbleTrail)
  // optional .CMsgVector mins = 1;
  if (has_mins()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->mins_, output);
  }

  // optional .CMsgVector maxs = 2;
  if (has_maxs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->maxs_, output);
  }

  // optional float waterz = 3;
  if (has_waterz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->waterz(), output);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  // optional float speed = 5;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBubbleTrail)
}

::google::protobuf::uint8* CMsgTEBubbleTrail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbleTrail)
  // optional .CMsgVector mins = 1;
  if (has_mins()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->mins_, target);
  }

  // optional .CMsgVector maxs = 2;
  if (has_maxs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->maxs_, target);
  }

  // optional float waterz = 3;
  if (has_waterz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->waterz(), target);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->count(), target);
  }

  // optional float speed = 5;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbleTrail)
  return target;
}

int CMsgTEBubbleTrail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .CMsgVector mins = 1;
    if (has_mins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (has_maxs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->maxs_);
    }

    // optional float waterz = 3;
    if (has_waterz()) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float speed = 5;
    if (has_speed()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBubbleTrail::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBubbleTrail* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBubbleTrail>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBubbleTrail::MergeFrom(const CMsgTEBubbleTrail& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mins()) {
      mutable_mins()->::CMsgVector::MergeFrom(from.mins());
    }
    if (from.has_maxs()) {
      mutable_maxs()->::CMsgVector::MergeFrom(from.maxs());
    }
    if (from.has_waterz()) {
      set_waterz(from.waterz());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBubbleTrail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbleTrail::CopyFrom(const CMsgTEBubbleTrail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbleTrail::IsInitialized() const {

  return true;
}

void CMsgTEBubbleTrail::Swap(CMsgTEBubbleTrail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBubbleTrail::InternalSwap(CMsgTEBubbleTrail* other) {
  std::swap(mins_, other->mins_);
  std::swap(maxs_, other->maxs_);
  std::swap(waterz_, other->waterz_);
  std::swap(count_, other->count_);
  std::swap(speed_, other->speed_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBubbleTrail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBubbleTrail_descriptor_;
  metadata.reflection = CMsgTEBubbleTrail_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBubbleTrail

// optional .CMsgVector mins = 1;
bool CMsgTEBubbleTrail::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBubbleTrail::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBubbleTrail::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbleTrail::clear_mins() {
  if (mins_ != NULL) mins_->::CMsgVector::Clear();
  clear_has_mins();
}
const ::CMsgVector& CMsgTEBubbleTrail::mins() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbleTrail.mins)
  return mins_ != NULL ? *mins_ : *default_instance_->mins_;
}
::CMsgVector* CMsgTEBubbleTrail::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) {
    mins_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBubbleTrail.mins)
  return mins_;
}
::CMsgVector* CMsgTEBubbleTrail::release_mins() {
  clear_has_mins();
  ::CMsgVector* temp = mins_;
  mins_ = NULL;
  return temp;
}
void CMsgTEBubbleTrail::set_allocated_mins(::CMsgVector* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBubbleTrail.mins)
}

// optional .CMsgVector maxs = 2;
bool CMsgTEBubbleTrail::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBubbleTrail::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBubbleTrail::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBubbleTrail::clear_maxs() {
  if (maxs_ != NULL) maxs_->::CMsgVector::Clear();
  clear_has_maxs();
}
const ::CMsgVector& CMsgTEBubbleTrail::maxs() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbleTrail.maxs)
  return maxs_ != NULL ? *maxs_ : *default_instance_->maxs_;
}
::CMsgVector* CMsgTEBubbleTrail::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) {
    maxs_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBubbleTrail.maxs)
  return maxs_;
}
::CMsgVector* CMsgTEBubbleTrail::release_maxs() {
  clear_has_maxs();
  ::CMsgVector* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
void CMsgTEBubbleTrail::set_allocated_maxs(::CMsgVector* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBubbleTrail.maxs)
}

// optional float waterz = 3;
bool CMsgTEBubbleTrail::has_waterz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBubbleTrail::set_has_waterz() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBubbleTrail::clear_has_waterz() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBubbleTrail::clear_waterz() {
  waterz_ = 0;
  clear_has_waterz();
}
 float CMsgTEBubbleTrail::waterz() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbleTrail.waterz)
  return waterz_;
}
 void CMsgTEBubbleTrail::set_waterz(float value) {
  set_has_waterz();
  waterz_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbleTrail.waterz)
}

// optional uint32 count = 4;
bool CMsgTEBubbleTrail::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBubbleTrail::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBubbleTrail::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBubbleTrail::clear_count() {
  count_ = 0u;
  clear_has_count();
}
 ::google::protobuf::uint32 CMsgTEBubbleTrail::count() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbleTrail.count)
  return count_;
}
 void CMsgTEBubbleTrail::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbleTrail.count)
}

// optional float speed = 5;
bool CMsgTEBubbleTrail::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEBubbleTrail::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEBubbleTrail::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEBubbleTrail::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float CMsgTEBubbleTrail::speed() const {
  // @@protoc_insertion_point(field_get:CMsgTEBubbleTrail.speed)
  return speed_;
}
 void CMsgTEBubbleTrail::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBubbleTrail.speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEDecal::kOriginFieldNumber;
const int CMsgTEDecal::kStartFieldNumber;
const int CMsgTEDecal::kEntityFieldNumber;
const int CMsgTEDecal::kHitboxFieldNumber;
const int CMsgTEDecal::kIndexFieldNumber;
#endif  // !_MSC_VER

CMsgTEDecal::CMsgTEDecal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEDecal)
}

void CMsgTEDecal::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  start_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEDecal::CMsgTEDecal(const CMsgTEDecal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEDecal)
}

void CMsgTEDecal::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  start_ = NULL;
  entity_ = 0u;
  hitbox_ = 0u;
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEDecal::~CMsgTEDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEDecal)
  SharedDtor();
}

void CMsgTEDecal::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete start_;
  }
}

void CMsgTEDecal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEDecal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEDecal_descriptor_;
}

const CMsgTEDecal& CMsgTEDecal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEDecal* CMsgTEDecal::default_instance_ = NULL;

CMsgTEDecal* CMsgTEDecal::New(::google::protobuf::Arena* arena) const {
  CMsgTEDecal* n = new CMsgTEDecal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEDecal::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEDecal*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(entity_, index_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_start()) {
      if (start_ != NULL) start_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEDecal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_start;
        break;
      }

      // optional .CMsgVector start = 2;
      case 2: {
        if (tag == 18) {
         parse_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_entity;
        break;
      }

      // optional uint32 entity = 3;
      case 3: {
        if (tag == 24) {
         parse_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_hitbox;
        break;
      }

      // optional uint32 hitbox = 4;
      case 4: {
        if (tag == 32) {
         parse_hitbox:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitbox_)));
          set_has_hitbox();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_index;
        break;
      }

      // optional uint32 index = 5;
      case 5: {
        if (tag == 40) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEDecal)
  return false;
#undef DO_
}

void CMsgTEDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->start_, output);
  }

  // optional uint32 entity = 3;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->entity(), output);
  }

  // optional uint32 hitbox = 4;
  if (has_hitbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hitbox(), output);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEDecal)
}

::google::protobuf::uint8* CMsgTEDecal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->start_, target);
  }

  // optional uint32 entity = 3;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->entity(), target);
  }

  // optional uint32 hitbox = 4;
  if (has_hitbox()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->hitbox(), target);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDecal)
  return target;
}

int CMsgTEDecal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector start = 2;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->start_);
    }

    // optional uint32 entity = 3;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 hitbox = 4;
    if (has_hitbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitbox());
    }

    // optional uint32 index = 5;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEDecal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEDecal* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEDecal>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEDecal::MergeFrom(const CMsgTEDecal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_start()) {
      mutable_start()->::CMsgVector::MergeFrom(from.start());
    }
    if (from.has_entity()) {
      set_entity(from.entity());
    }
    if (from.has_hitbox()) {
      set_hitbox(from.hitbox());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEDecal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDecal::CopyFrom(const CMsgTEDecal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDecal::IsInitialized() const {

  return true;
}

void CMsgTEDecal::Swap(CMsgTEDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEDecal::InternalSwap(CMsgTEDecal* other) {
  std::swap(origin_, other->origin_);
  std::swap(start_, other->start_);
  std::swap(entity_, other->entity_);
  std::swap(hitbox_, other->hitbox_);
  std::swap(index_, other->index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEDecal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEDecal_descriptor_;
  metadata.reflection = CMsgTEDecal_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEDecal

// optional .CMsgVector origin = 1;
bool CMsgTEDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDecal::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEDecal::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEDecal.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEDecal.origin)
  return origin_;
}
::CMsgVector* CMsgTEDecal::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEDecal::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEDecal.origin)
}

// optional .CMsgVector start = 2;
bool CMsgTEDecal::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEDecal::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEDecal::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEDecal::clear_start() {
  if (start_ != NULL) start_->::CMsgVector::Clear();
  clear_has_start();
}
const ::CMsgVector& CMsgTEDecal::start() const {
  // @@protoc_insertion_point(field_get:CMsgTEDecal.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
::CMsgVector* CMsgTEDecal::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEDecal.start)
  return start_;
}
::CMsgVector* CMsgTEDecal::release_start() {
  clear_has_start();
  ::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
void CMsgTEDecal::set_allocated_start(::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEDecal.start)
}

// optional uint32 entity = 3;
bool CMsgTEDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
 ::google::protobuf::uint32 CMsgTEDecal::entity() const {
  // @@protoc_insertion_point(field_get:CMsgTEDecal.entity)
  return entity_;
}
 void CMsgTEDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEDecal.entity)
}

// optional uint32 hitbox = 4;
bool CMsgTEDecal::has_hitbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEDecal::set_has_hitbox() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEDecal::clear_has_hitbox() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEDecal::clear_hitbox() {
  hitbox_ = 0u;
  clear_has_hitbox();
}
 ::google::protobuf::uint32 CMsgTEDecal::hitbox() const {
  // @@protoc_insertion_point(field_get:CMsgTEDecal.hitbox)
  return hitbox_;
}
 void CMsgTEDecal::set_hitbox(::google::protobuf::uint32 value) {
  set_has_hitbox();
  hitbox_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEDecal.hitbox)
}

// optional uint32 index = 5;
bool CMsgTEDecal::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEDecal::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 CMsgTEDecal::index() const {
  // @@protoc_insertion_point(field_get:CMsgTEDecal.index)
  return index_;
}
 void CMsgTEDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEDecal.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgEffectData::kOriginFieldNumber;
const int CMsgEffectData::kStartFieldNumber;
const int CMsgEffectData::kNormalFieldNumber;
const int CMsgEffectData::kAnglesFieldNumber;
const int CMsgEffectData::kEntityFieldNumber;
const int CMsgEffectData::kOtherentityFieldNumber;
const int CMsgEffectData::kScaleFieldNumber;
const int CMsgEffectData::kMagnitudeFieldNumber;
const int CMsgEffectData::kRadiusFieldNumber;
const int CMsgEffectData::kSurfacepropFieldNumber;
const int CMsgEffectData::kEffectindexFieldNumber;
const int CMsgEffectData::kDamagetypeFieldNumber;
const int CMsgEffectData::kMaterialFieldNumber;
const int CMsgEffectData::kHitboxFieldNumber;
const int CMsgEffectData::kColorFieldNumber;
const int CMsgEffectData::kFlagsFieldNumber;
const int CMsgEffectData::kAttachmentindexFieldNumber;
const int CMsgEffectData::kEffectnameFieldNumber;
const int CMsgEffectData::kAttachmentnameFieldNumber;
#endif  // !_MSC_VER

CMsgEffectData::CMsgEffectData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgEffectData)
}

void CMsgEffectData::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  start_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  normal_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
}

CMsgEffectData::CMsgEffectData(const CMsgEffectData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgEffectData)
}

void CMsgEffectData::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  start_ = NULL;
  normal_ = NULL;
  angles_ = NULL;
  entity_ = 0u;
  otherentity_ = 0u;
  scale_ = 0;
  magnitude_ = 0;
  radius_ = 0;
  surfaceprop_ = 0u;
  effectindex_ = GOOGLE_ULONGLONG(0);
  damagetype_ = 0u;
  material_ = 0u;
  hitbox_ = 0u;
  color_ = 0u;
  flags_ = 0u;
  attachmentindex_ = 0;
  effectname_ = 0u;
  attachmentname_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgEffectData::~CMsgEffectData() {
  // @@protoc_insertion_point(destructor:CMsgEffectData)
  SharedDtor();
}

void CMsgEffectData::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete start_;
    delete normal_;
    delete angles_;
  }
}

void CMsgEffectData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgEffectData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgEffectData_descriptor_;
}

const CMsgEffectData& CMsgEffectData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgEffectData* CMsgEffectData::default_instance_ = NULL;

CMsgEffectData* CMsgEffectData::New(::google::protobuf::Arena* arena) const {
  CMsgEffectData* n = new CMsgEffectData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgEffectData::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgEffectData*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(entity_, magnitude_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_start()) {
      if (start_ != NULL) start_->::CMsgVector::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(radius_, flags_);
  }
  ZR_(attachmentindex_, attachmentname_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgEffectData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgEffectData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_start;
        break;
      }

      // optional .CMsgVector start = 2;
      case 2: {
        if (tag == 18) {
         parse_start:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_normal;
        break;
      }

      // optional .CMsgVector normal = 3;
      case 3: {
        if (tag == 26) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 4;
      case 4: {
        if (tag == 34) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_entity;
        break;
      }

      // optional fixed32 entity = 5;
      case 5: {
        if (tag == 45) {
         parse_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_otherentity;
        break;
      }

      // optional fixed32 otherentity = 6;
      case 6: {
        if (tag == 53) {
         parse_otherentity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &otherentity_)));
          set_has_otherentity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_scale;
        break;
      }

      // optional float scale = 7;
      case 7: {
        if (tag == 61) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_magnitude;
        break;
      }

      // optional float magnitude = 8;
      case 8: {
        if (tag == 69) {
         parse_magnitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &magnitude_)));
          set_has_magnitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_radius;
        break;
      }

      // optional float radius = 9;
      case 9: {
        if (tag == 77) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_surfaceprop;
        break;
      }

      // optional fixed32 surfaceprop = 10;
      case 10: {
        if (tag == 85) {
         parse_surfaceprop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &surfaceprop_)));
          set_has_surfaceprop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_effectindex;
        break;
      }

      // optional fixed64 effectindex = 11;
      case 11: {
        if (tag == 89) {
         parse_effectindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &effectindex_)));
          set_has_effectindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_damagetype;
        break;
      }

      // optional uint32 damagetype = 12;
      case 12: {
        if (tag == 96) {
         parse_damagetype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &damagetype_)));
          set_has_damagetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_material;
        break;
      }

      // optional uint32 material = 13;
      case 13: {
        if (tag == 104) {
         parse_material:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &material_)));
          set_has_material();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_hitbox;
        break;
      }

      // optional uint32 hitbox = 14;
      case 14: {
        if (tag == 112) {
         parse_hitbox:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitbox_)));
          set_has_hitbox();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_color;
        break;
      }

      // optional uint32 color = 15;
      case 15: {
        if (tag == 120) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 16;
      case 16: {
        if (tag == 128) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_attachmentindex;
        break;
      }

      // optional int32 attachmentindex = 17;
      case 17: {
        if (tag == 136) {
         parse_attachmentindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attachmentindex_)));
          set_has_attachmentindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_effectname;
        break;
      }

      // optional uint32 effectname = 18;
      case 18: {
        if (tag == 144) {
         parse_effectname:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &effectname_)));
          set_has_effectname();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_attachmentname;
        break;
      }

      // optional uint32 attachmentname = 19;
      case 19: {
        if (tag == 152) {
         parse_attachmentname:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attachmentname_)));
          set_has_attachmentname();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgEffectData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgEffectData)
  return false;
#undef DO_
}

void CMsgEffectData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgEffectData)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->start_, output);
  }

  // optional .CMsgVector normal = 3;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->normal_, output);
  }

  // optional .CMsgQAngle angles = 4;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->angles_, output);
  }

  // optional fixed32 entity = 5;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(5, this->entity(), output);
  }

  // optional fixed32 otherentity = 6;
  if (has_otherentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(6, this->otherentity(), output);
  }

  // optional float scale = 7;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->scale(), output);
  }

  // optional float magnitude = 8;
  if (has_magnitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->magnitude(), output);
  }

  // optional float radius = 9;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->radius(), output);
  }

  // optional fixed32 surfaceprop = 10;
  if (has_surfaceprop()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->surfaceprop(), output);
  }

  // optional fixed64 effectindex = 11;
  if (has_effectindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(11, this->effectindex(), output);
  }

  // optional uint32 damagetype = 12;
  if (has_damagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->damagetype(), output);
  }

  // optional uint32 material = 13;
  if (has_material()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->material(), output);
  }

  // optional uint32 hitbox = 14;
  if (has_hitbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->hitbox(), output);
  }

  // optional uint32 color = 15;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->color(), output);
  }

  // optional uint32 flags = 16;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->flags(), output);
  }

  // optional int32 attachmentindex = 17;
  if (has_attachmentindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->attachmentindex(), output);
  }

  // optional uint32 effectname = 18;
  if (has_effectname()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->effectname(), output);
  }

  // optional uint32 attachmentname = 19;
  if (has_attachmentname()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->attachmentname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgEffectData)
}

::google::protobuf::uint8* CMsgEffectData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgEffectData)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector start = 2;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->start_, target);
  }

  // optional .CMsgVector normal = 3;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->normal_, target);
  }

  // optional .CMsgQAngle angles = 4;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->angles_, target);
  }

  // optional fixed32 entity = 5;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(5, this->entity(), target);
  }

  // optional fixed32 otherentity = 6;
  if (has_otherentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(6, this->otherentity(), target);
  }

  // optional float scale = 7;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->scale(), target);
  }

  // optional float magnitude = 8;
  if (has_magnitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->magnitude(), target);
  }

  // optional float radius = 9;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->radius(), target);
  }

  // optional fixed32 surfaceprop = 10;
  if (has_surfaceprop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->surfaceprop(), target);
  }

  // optional fixed64 effectindex = 11;
  if (has_effectindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(11, this->effectindex(), target);
  }

  // optional uint32 damagetype = 12;
  if (has_damagetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->damagetype(), target);
  }

  // optional uint32 material = 13;
  if (has_material()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->material(), target);
  }

  // optional uint32 hitbox = 14;
  if (has_hitbox()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->hitbox(), target);
  }

  // optional uint32 color = 15;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->color(), target);
  }

  // optional uint32 flags = 16;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->flags(), target);
  }

  // optional int32 attachmentindex = 17;
  if (has_attachmentindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->attachmentindex(), target);
  }

  // optional uint32 effectname = 18;
  if (has_effectname()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(18, this->effectname(), target);
  }

  // optional uint32 attachmentname = 19;
  if (has_attachmentname()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(19, this->attachmentname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgEffectData)
  return target;
}

int CMsgEffectData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector start = 2;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->start_);
    }

    // optional .CMsgVector normal = 3;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->normal_);
    }

    // optional .CMsgQAngle angles = 4;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional fixed32 entity = 5;
    if (has_entity()) {
      total_size += 1 + 4;
    }

    // optional fixed32 otherentity = 6;
    if (has_otherentity()) {
      total_size += 1 + 4;
    }

    // optional float scale = 7;
    if (has_scale()) {
      total_size += 1 + 4;
    }

    // optional float magnitude = 8;
    if (has_magnitude()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional float radius = 9;
    if (has_radius()) {
      total_size += 1 + 4;
    }

    // optional fixed32 surfaceprop = 10;
    if (has_surfaceprop()) {
      total_size += 1 + 4;
    }

    // optional fixed64 effectindex = 11;
    if (has_effectindex()) {
      total_size += 1 + 8;
    }

    // optional uint32 damagetype = 12;
    if (has_damagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->damagetype());
    }

    // optional uint32 material = 13;
    if (has_material()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->material());
    }

    // optional uint32 hitbox = 14;
    if (has_hitbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitbox());
    }

    // optional uint32 color = 15;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->color());
    }

    // optional uint32 flags = 16;
    if (has_flags()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  if (_has_bits_[16 / 32] & 458752u) {
    // optional int32 attachmentindex = 17;
    if (has_attachmentindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->attachmentindex());
    }

    // optional uint32 effectname = 18;
    if (has_effectname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->effectname());
    }

    // optional uint32 attachmentname = 19;
    if (has_attachmentname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attachmentname());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgEffectData::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgEffectData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgEffectData>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgEffectData::MergeFrom(const CMsgEffectData& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_start()) {
      mutable_start()->::CMsgVector::MergeFrom(from.start());
    }
    if (from.has_normal()) {
      mutable_normal()->::CMsgVector::MergeFrom(from.normal());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_entity()) {
      set_entity(from.entity());
    }
    if (from.has_otherentity()) {
      set_otherentity(from.otherentity());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_magnitude()) {
      set_magnitude(from.magnitude());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_surfaceprop()) {
      set_surfaceprop(from.surfaceprop());
    }
    if (from.has_effectindex()) {
      set_effectindex(from.effectindex());
    }
    if (from.has_damagetype()) {
      set_damagetype(from.damagetype());
    }
    if (from.has_material()) {
      set_material(from.material());
    }
    if (from.has_hitbox()) {
      set_hitbox(from.hitbox());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_attachmentindex()) {
      set_attachmentindex(from.attachmentindex());
    }
    if (from.has_effectname()) {
      set_effectname(from.effectname());
    }
    if (from.has_attachmentname()) {
      set_attachmentname(from.attachmentname());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgEffectData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgEffectData::CopyFrom(const CMsgEffectData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgEffectData::IsInitialized() const {

  return true;
}

void CMsgEffectData::Swap(CMsgEffectData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgEffectData::InternalSwap(CMsgEffectData* other) {
  std::swap(origin_, other->origin_);
  std::swap(start_, other->start_);
  std::swap(normal_, other->normal_);
  std::swap(angles_, other->angles_);
  std::swap(entity_, other->entity_);
  std::swap(otherentity_, other->otherentity_);
  std::swap(scale_, other->scale_);
  std::swap(magnitude_, other->magnitude_);
  std::swap(radius_, other->radius_);
  std::swap(surfaceprop_, other->surfaceprop_);
  std::swap(effectindex_, other->effectindex_);
  std::swap(damagetype_, other->damagetype_);
  std::swap(material_, other->material_);
  std::swap(hitbox_, other->hitbox_);
  std::swap(color_, other->color_);
  std::swap(flags_, other->flags_);
  std::swap(attachmentindex_, other->attachmentindex_);
  std::swap(effectname_, other->effectname_);
  std::swap(attachmentname_, other->attachmentname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgEffectData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgEffectData_descriptor_;
  metadata.reflection = CMsgEffectData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgEffectData

// optional .CMsgVector origin = 1;
bool CMsgEffectData::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgEffectData::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgEffectData::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgEffectData::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgEffectData::origin() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgEffectData::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgEffectData.origin)
  return origin_;
}
::CMsgVector* CMsgEffectData::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgEffectData::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgEffectData.origin)
}

// optional .CMsgVector start = 2;
bool CMsgEffectData::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgEffectData::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgEffectData::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgEffectData::clear_start() {
  if (start_ != NULL) start_->::CMsgVector::Clear();
  clear_has_start();
}
const ::CMsgVector& CMsgEffectData::start() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
::CMsgVector* CMsgEffectData::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgEffectData.start)
  return start_;
}
::CMsgVector* CMsgEffectData::release_start() {
  clear_has_start();
  ::CMsgVector* temp = start_;
  start_ = NULL;
  return temp;
}
void CMsgEffectData::set_allocated_start(::CMsgVector* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgEffectData.start)
}

// optional .CMsgVector normal = 3;
bool CMsgEffectData::has_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgEffectData::set_has_normal() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgEffectData::clear_has_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgEffectData::clear_normal() {
  if (normal_ != NULL) normal_->::CMsgVector::Clear();
  clear_has_normal();
}
const ::CMsgVector& CMsgEffectData::normal() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
::CMsgVector* CMsgEffectData::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgEffectData.normal)
  return normal_;
}
::CMsgVector* CMsgEffectData::release_normal() {
  clear_has_normal();
  ::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
void CMsgEffectData::set_allocated_normal(::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgEffectData.normal)
}

// optional .CMsgQAngle angles = 4;
bool CMsgEffectData::has_angles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgEffectData::set_has_angles() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgEffectData::clear_has_angles() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgEffectData::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgEffectData::angles() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgEffectData::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgEffectData.angles)
  return angles_;
}
::CMsgQAngle* CMsgEffectData::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgEffectData::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgEffectData.angles)
}

// optional fixed32 entity = 5;
bool CMsgEffectData::has_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgEffectData::set_has_entity() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgEffectData::clear_has_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgEffectData::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
 ::google::protobuf::uint32 CMsgEffectData::entity() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.entity)
  return entity_;
}
 void CMsgEffectData::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.entity)
}

// optional fixed32 otherentity = 6;
bool CMsgEffectData::has_otherentity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgEffectData::set_has_otherentity() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgEffectData::clear_has_otherentity() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgEffectData::clear_otherentity() {
  otherentity_ = 0u;
  clear_has_otherentity();
}
 ::google::protobuf::uint32 CMsgEffectData::otherentity() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.otherentity)
  return otherentity_;
}
 void CMsgEffectData::set_otherentity(::google::protobuf::uint32 value) {
  set_has_otherentity();
  otherentity_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.otherentity)
}

// optional float scale = 7;
bool CMsgEffectData::has_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgEffectData::set_has_scale() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgEffectData::clear_has_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgEffectData::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgEffectData::scale() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.scale)
  return scale_;
}
 void CMsgEffectData::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.scale)
}

// optional float magnitude = 8;
bool CMsgEffectData::has_magnitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgEffectData::set_has_magnitude() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgEffectData::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgEffectData::clear_magnitude() {
  magnitude_ = 0;
  clear_has_magnitude();
}
 float CMsgEffectData::magnitude() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.magnitude)
  return magnitude_;
}
 void CMsgEffectData::set_magnitude(float value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.magnitude)
}

// optional float radius = 9;
bool CMsgEffectData::has_radius() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgEffectData::set_has_radius() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgEffectData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgEffectData::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
 float CMsgEffectData::radius() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.radius)
  return radius_;
}
 void CMsgEffectData::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.radius)
}

// optional fixed32 surfaceprop = 10;
bool CMsgEffectData::has_surfaceprop() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void CMsgEffectData::set_has_surfaceprop() {
  _has_bits_[0] |= 0x00000200u;
}
void CMsgEffectData::clear_has_surfaceprop() {
  _has_bits_[0] &= ~0x00000200u;
}
void CMsgEffectData::clear_surfaceprop() {
  surfaceprop_ = 0u;
  clear_has_surfaceprop();
}
 ::google::protobuf::uint32 CMsgEffectData::surfaceprop() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.surfaceprop)
  return surfaceprop_;
}
 void CMsgEffectData::set_surfaceprop(::google::protobuf::uint32 value) {
  set_has_surfaceprop();
  surfaceprop_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.surfaceprop)
}

// optional fixed64 effectindex = 11;
bool CMsgEffectData::has_effectindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void CMsgEffectData::set_has_effectindex() {
  _has_bits_[0] |= 0x00000400u;
}
void CMsgEffectData::clear_has_effectindex() {
  _has_bits_[0] &= ~0x00000400u;
}
void CMsgEffectData::clear_effectindex() {
  effectindex_ = GOOGLE_ULONGLONG(0);
  clear_has_effectindex();
}
 ::google::protobuf::uint64 CMsgEffectData::effectindex() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.effectindex)
  return effectindex_;
}
 void CMsgEffectData::set_effectindex(::google::protobuf::uint64 value) {
  set_has_effectindex();
  effectindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.effectindex)
}

// optional uint32 damagetype = 12;
bool CMsgEffectData::has_damagetype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void CMsgEffectData::set_has_damagetype() {
  _has_bits_[0] |= 0x00000800u;
}
void CMsgEffectData::clear_has_damagetype() {
  _has_bits_[0] &= ~0x00000800u;
}
void CMsgEffectData::clear_damagetype() {
  damagetype_ = 0u;
  clear_has_damagetype();
}
 ::google::protobuf::uint32 CMsgEffectData::damagetype() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.damagetype)
  return damagetype_;
}
 void CMsgEffectData::set_damagetype(::google::protobuf::uint32 value) {
  set_has_damagetype();
  damagetype_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.damagetype)
}

// optional uint32 material = 13;
bool CMsgEffectData::has_material() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void CMsgEffectData::set_has_material() {
  _has_bits_[0] |= 0x00001000u;
}
void CMsgEffectData::clear_has_material() {
  _has_bits_[0] &= ~0x00001000u;
}
void CMsgEffectData::clear_material() {
  material_ = 0u;
  clear_has_material();
}
 ::google::protobuf::uint32 CMsgEffectData::material() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.material)
  return material_;
}
 void CMsgEffectData::set_material(::google::protobuf::uint32 value) {
  set_has_material();
  material_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.material)
}

// optional uint32 hitbox = 14;
bool CMsgEffectData::has_hitbox() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void CMsgEffectData::set_has_hitbox() {
  _has_bits_[0] |= 0x00002000u;
}
void CMsgEffectData::clear_has_hitbox() {
  _has_bits_[0] &= ~0x00002000u;
}
void CMsgEffectData::clear_hitbox() {
  hitbox_ = 0u;
  clear_has_hitbox();
}
 ::google::protobuf::uint32 CMsgEffectData::hitbox() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.hitbox)
  return hitbox_;
}
 void CMsgEffectData::set_hitbox(::google::protobuf::uint32 value) {
  set_has_hitbox();
  hitbox_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.hitbox)
}

// optional uint32 color = 15;
bool CMsgEffectData::has_color() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void CMsgEffectData::set_has_color() {
  _has_bits_[0] |= 0x00004000u;
}
void CMsgEffectData::clear_has_color() {
  _has_bits_[0] &= ~0x00004000u;
}
void CMsgEffectData::clear_color() {
  color_ = 0u;
  clear_has_color();
}
 ::google::protobuf::uint32 CMsgEffectData::color() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.color)
  return color_;
}
 void CMsgEffectData::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.color)
}

// optional uint32 flags = 16;
bool CMsgEffectData::has_flags() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void CMsgEffectData::set_has_flags() {
  _has_bits_[0] |= 0x00008000u;
}
void CMsgEffectData::clear_has_flags() {
  _has_bits_[0] &= ~0x00008000u;
}
void CMsgEffectData::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 CMsgEffectData::flags() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.flags)
  return flags_;
}
 void CMsgEffectData::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.flags)
}

// optional int32 attachmentindex = 17;
bool CMsgEffectData::has_attachmentindex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void CMsgEffectData::set_has_attachmentindex() {
  _has_bits_[0] |= 0x00010000u;
}
void CMsgEffectData::clear_has_attachmentindex() {
  _has_bits_[0] &= ~0x00010000u;
}
void CMsgEffectData::clear_attachmentindex() {
  attachmentindex_ = 0;
  clear_has_attachmentindex();
}
 ::google::protobuf::int32 CMsgEffectData::attachmentindex() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.attachmentindex)
  return attachmentindex_;
}
 void CMsgEffectData::set_attachmentindex(::google::protobuf::int32 value) {
  set_has_attachmentindex();
  attachmentindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.attachmentindex)
}

// optional uint32 effectname = 18;
bool CMsgEffectData::has_effectname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void CMsgEffectData::set_has_effectname() {
  _has_bits_[0] |= 0x00020000u;
}
void CMsgEffectData::clear_has_effectname() {
  _has_bits_[0] &= ~0x00020000u;
}
void CMsgEffectData::clear_effectname() {
  effectname_ = 0u;
  clear_has_effectname();
}
 ::google::protobuf::uint32 CMsgEffectData::effectname() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.effectname)
  return effectname_;
}
 void CMsgEffectData::set_effectname(::google::protobuf::uint32 value) {
  set_has_effectname();
  effectname_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.effectname)
}

// optional uint32 attachmentname = 19;
bool CMsgEffectData::has_attachmentname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void CMsgEffectData::set_has_attachmentname() {
  _has_bits_[0] |= 0x00040000u;
}
void CMsgEffectData::clear_has_attachmentname() {
  _has_bits_[0] &= ~0x00040000u;
}
void CMsgEffectData::clear_attachmentname() {
  attachmentname_ = 0u;
  clear_has_attachmentname();
}
 ::google::protobuf::uint32 CMsgEffectData::attachmentname() const {
  // @@protoc_insertion_point(field_get:CMsgEffectData.attachmentname)
  return attachmentname_;
}
 void CMsgEffectData::set_attachmentname(::google::protobuf::uint32 value) {
  set_has_attachmentname();
  attachmentname_ = value;
  // @@protoc_insertion_point(field_set:CMsgEffectData.attachmentname)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEEffectDispatch::kEffectdataFieldNumber;
#endif  // !_MSC_VER

CMsgTEEffectDispatch::CMsgTEEffectDispatch()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEEffectDispatch)
}

void CMsgTEEffectDispatch::InitAsDefaultInstance() {
  effectdata_ = const_cast< ::CMsgEffectData*>(&::CMsgEffectData::default_instance());
}

CMsgTEEffectDispatch::CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEEffectDispatch)
}

void CMsgTEEffectDispatch::SharedCtor() {
  _cached_size_ = 0;
  effectdata_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEEffectDispatch::~CMsgTEEffectDispatch() {
  // @@protoc_insertion_point(destructor:CMsgTEEffectDispatch)
  SharedDtor();
}

void CMsgTEEffectDispatch::SharedDtor() {
  if (this != default_instance_) {
    delete effectdata_;
  }
}

void CMsgTEEffectDispatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEEffectDispatch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEEffectDispatch_descriptor_;
}

const CMsgTEEffectDispatch& CMsgTEEffectDispatch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEEffectDispatch* CMsgTEEffectDispatch::default_instance_ = NULL;

CMsgTEEffectDispatch* CMsgTEEffectDispatch::New(::google::protobuf::Arena* arena) const {
  CMsgTEEffectDispatch* n = new CMsgTEEffectDispatch;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEEffectDispatch::Clear() {
  if (has_effectdata()) {
    if (effectdata_ != NULL) effectdata_->::CMsgEffectData::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEEffectDispatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEEffectDispatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgEffectData effectdata = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_effectdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEEffectDispatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEEffectDispatch)
  return false;
#undef DO_
}

void CMsgTEEffectDispatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEEffectDispatch)
  // optional .CMsgEffectData effectdata = 1;
  if (has_effectdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->effectdata_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEEffectDispatch)
}

::google::protobuf::uint8* CMsgTEEffectDispatch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEffectDispatch)
  // optional .CMsgEffectData effectdata = 1;
  if (has_effectdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->effectdata_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEffectDispatch)
  return target;
}

int CMsgTEEffectDispatch::ByteSize() const {
  int total_size = 0;

  // optional .CMsgEffectData effectdata = 1;
  if (has_effectdata()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->effectdata_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEEffectDispatch::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEEffectDispatch* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEEffectDispatch>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEEffectDispatch::MergeFrom(const CMsgTEEffectDispatch& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_effectdata()) {
      mutable_effectdata()->::CMsgEffectData::MergeFrom(from.effectdata());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEEffectDispatch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEffectDispatch::CopyFrom(const CMsgTEEffectDispatch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEffectDispatch::IsInitialized() const {

  return true;
}

void CMsgTEEffectDispatch::Swap(CMsgTEEffectDispatch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEEffectDispatch::InternalSwap(CMsgTEEffectDispatch* other) {
  std::swap(effectdata_, other->effectdata_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEEffectDispatch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEEffectDispatch_descriptor_;
  metadata.reflection = CMsgTEEffectDispatch_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEEffectDispatch

// optional .CMsgEffectData effectdata = 1;
bool CMsgTEEffectDispatch::has_effectdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEEffectDispatch::set_has_effectdata() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEEffectDispatch::clear_has_effectdata() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEffectDispatch::clear_effectdata() {
  if (effectdata_ != NULL) effectdata_->::CMsgEffectData::Clear();
  clear_has_effectdata();
}
const ::CMsgEffectData& CMsgTEEffectDispatch::effectdata() const {
  // @@protoc_insertion_point(field_get:CMsgTEEffectDispatch.effectdata)
  return effectdata_ != NULL ? *effectdata_ : *default_instance_->effectdata_;
}
::CMsgEffectData* CMsgTEEffectDispatch::mutable_effectdata() {
  set_has_effectdata();
  if (effectdata_ == NULL) {
    effectdata_ = new ::CMsgEffectData;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEEffectDispatch.effectdata)
  return effectdata_;
}
::CMsgEffectData* CMsgTEEffectDispatch::release_effectdata() {
  clear_has_effectdata();
  ::CMsgEffectData* temp = effectdata_;
  effectdata_ = NULL;
  return temp;
}
void CMsgTEEffectDispatch::set_allocated_effectdata(::CMsgEffectData* effectdata) {
  delete effectdata_;
  effectdata_ = effectdata;
  if (effectdata) {
    set_has_effectdata();
  } else {
    clear_has_effectdata();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEEffectDispatch.effectdata)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEEnergySplash::kPosFieldNumber;
const int CMsgTEEnergySplash::kDirFieldNumber;
const int CMsgTEEnergySplash::kExplosiveFieldNumber;
#endif  // !_MSC_VER

CMsgTEEnergySplash::CMsgTEEnergySplash()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEEnergySplash)
}

void CMsgTEEnergySplash::InitAsDefaultInstance() {
  pos_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  dir_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEEnergySplash::CMsgTEEnergySplash(const CMsgTEEnergySplash& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEEnergySplash)
}

void CMsgTEEnergySplash::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  dir_ = NULL;
  explosive_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEEnergySplash::~CMsgTEEnergySplash() {
  // @@protoc_insertion_point(destructor:CMsgTEEnergySplash)
  SharedDtor();
}

void CMsgTEEnergySplash::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete dir_;
  }
}

void CMsgTEEnergySplash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEEnergySplash::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEEnergySplash_descriptor_;
}

const CMsgTEEnergySplash& CMsgTEEnergySplash::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEEnergySplash* CMsgTEEnergySplash::default_instance_ = NULL;

CMsgTEEnergySplash* CMsgTEEnergySplash::New(::google::protobuf::Arena* arena) const {
  CMsgTEEnergySplash* n = new CMsgTEEnergySplash;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEEnergySplash::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::CMsgVector::Clear();
    }
    if (has_dir()) {
      if (dir_ != NULL) dir_->::CMsgVector::Clear();
    }
    explosive_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEEnergySplash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEEnergySplash)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_dir;
        break;
      }

      // optional .CMsgVector dir = 2;
      case 2: {
        if (tag == 18) {
         parse_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dir()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_explosive;
        break;
      }

      // optional bool explosive = 3;
      case 3: {
        if (tag == 24) {
         parse_explosive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &explosive_)));
          set_has_explosive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEEnergySplash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEEnergySplash)
  return false;
#undef DO_
}

void CMsgTEEnergySplash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEEnergySplash)
  // optional .CMsgVector pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // optional .CMsgVector dir = 2;
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->dir_, output);
  }

  // optional bool explosive = 3;
  if (has_explosive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->explosive(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEEnergySplash)
}

::google::protobuf::uint8* CMsgTEEnergySplash::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEnergySplash)
  // optional .CMsgVector pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->pos_, target);
  }

  // optional .CMsgVector dir = 2;
  if (has_dir()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->dir_, target);
  }

  // optional bool explosive = 3;
  if (has_explosive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->explosive(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEnergySplash)
  return target;
}

int CMsgTEEnergySplash::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgVector pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pos_);
    }

    // optional .CMsgVector dir = 2;
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->dir_);
    }

    // optional bool explosive = 3;
    if (has_explosive()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEEnergySplash::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEEnergySplash* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEEnergySplash>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEEnergySplash::MergeFrom(const CMsgTEEnergySplash& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::CMsgVector::MergeFrom(from.pos());
    }
    if (from.has_dir()) {
      mutable_dir()->::CMsgVector::MergeFrom(from.dir());
    }
    if (from.has_explosive()) {
      set_explosive(from.explosive());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEEnergySplash::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEnergySplash::CopyFrom(const CMsgTEEnergySplash& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEnergySplash::IsInitialized() const {

  return true;
}

void CMsgTEEnergySplash::Swap(CMsgTEEnergySplash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEEnergySplash::InternalSwap(CMsgTEEnergySplash* other) {
  std::swap(pos_, other->pos_);
  std::swap(dir_, other->dir_);
  std::swap(explosive_, other->explosive_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEEnergySplash::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEEnergySplash_descriptor_;
  metadata.reflection = CMsgTEEnergySplash_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEEnergySplash

// optional .CMsgVector pos = 1;
bool CMsgTEEnergySplash::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEEnergySplash::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEEnergySplash::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEnergySplash::clear_pos() {
  if (pos_ != NULL) pos_->::CMsgVector::Clear();
  clear_has_pos();
}
const ::CMsgVector& CMsgTEEnergySplash::pos() const {
  // @@protoc_insertion_point(field_get:CMsgTEEnergySplash.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::CMsgVector* CMsgTEEnergySplash::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEEnergySplash.pos)
  return pos_;
}
::CMsgVector* CMsgTEEnergySplash::release_pos() {
  clear_has_pos();
  ::CMsgVector* temp = pos_;
  pos_ = NULL;
  return temp;
}
void CMsgTEEnergySplash::set_allocated_pos(::CMsgVector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEEnergySplash.pos)
}

// optional .CMsgVector dir = 2;
bool CMsgTEEnergySplash::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEEnergySplash::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEEnergySplash::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEEnergySplash::clear_dir() {
  if (dir_ != NULL) dir_->::CMsgVector::Clear();
  clear_has_dir();
}
const ::CMsgVector& CMsgTEEnergySplash::dir() const {
  // @@protoc_insertion_point(field_get:CMsgTEEnergySplash.dir)
  return dir_ != NULL ? *dir_ : *default_instance_->dir_;
}
::CMsgVector* CMsgTEEnergySplash::mutable_dir() {
  set_has_dir();
  if (dir_ == NULL) {
    dir_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEEnergySplash.dir)
  return dir_;
}
::CMsgVector* CMsgTEEnergySplash::release_dir() {
  clear_has_dir();
  ::CMsgVector* temp = dir_;
  dir_ = NULL;
  return temp;
}
void CMsgTEEnergySplash::set_allocated_dir(::CMsgVector* dir) {
  delete dir_;
  dir_ = dir;
  if (dir) {
    set_has_dir();
  } else {
    clear_has_dir();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEEnergySplash.dir)
}

// optional bool explosive = 3;
bool CMsgTEEnergySplash::has_explosive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEEnergySplash::set_has_explosive() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEEnergySplash::clear_has_explosive() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEEnergySplash::clear_explosive() {
  explosive_ = false;
  clear_has_explosive();
}
 bool CMsgTEEnergySplash::explosive() const {
  // @@protoc_insertion_point(field_get:CMsgTEEnergySplash.explosive)
  return explosive_;
}
 void CMsgTEEnergySplash::set_explosive(bool value) {
  set_has_explosive();
  explosive_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEEnergySplash.explosive)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEFizz::kEntityFieldNumber;
const int CMsgTEFizz::kDensityFieldNumber;
const int CMsgTEFizz::kCurrentFieldNumber;
#endif  // !_MSC_VER

CMsgTEFizz::CMsgTEFizz()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEFizz)
}

void CMsgTEFizz::InitAsDefaultInstance() {
}

CMsgTEFizz::CMsgTEFizz(const CMsgTEFizz& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEFizz)
}

void CMsgTEFizz::SharedCtor() {
  _cached_size_ = 0;
  entity_ = 0u;
  density_ = 0u;
  current_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEFizz::~CMsgTEFizz() {
  // @@protoc_insertion_point(destructor:CMsgTEFizz)
  SharedDtor();
}

void CMsgTEFizz::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CMsgTEFizz::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEFizz::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEFizz_descriptor_;
}

const CMsgTEFizz& CMsgTEFizz::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEFizz* CMsgTEFizz::default_instance_ = NULL;

CMsgTEFizz* CMsgTEFizz::New(::google::protobuf::Arena* arena) const {
  CMsgTEFizz* n = new CMsgTEFizz;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEFizz::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEFizz*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(entity_, current_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEFizz::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEFizz)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 entity = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_density;
        break;
      }

      // optional uint32 density = 2;
      case 2: {
        if (tag == 16) {
         parse_density:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &density_)));
          set_has_density();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_current;
        break;
      }

      // optional int32 current = 3;
      case 3: {
        if (tag == 24) {
         parse_current:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_)));
          set_has_current();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEFizz)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEFizz)
  return false;
#undef DO_
}

void CMsgTEFizz::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEFizz)
  // optional uint32 entity = 1;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->entity(), output);
  }

  // optional uint32 density = 2;
  if (has_density()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->density(), output);
  }

  // optional int32 current = 3;
  if (has_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->current(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEFizz)
}

::google::protobuf::uint8* CMsgTEFizz::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEFizz)
  // optional uint32 entity = 1;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->entity(), target);
  }

  // optional uint32 density = 2;
  if (has_density()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->density(), target);
  }

  // optional int32 current = 3;
  if (has_current()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->current(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEFizz)
  return target;
}

int CMsgTEFizz::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 entity = 1;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 density = 2;
    if (has_density()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->density());
    }

    // optional int32 current = 3;
    if (has_current()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEFizz::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEFizz* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEFizz>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEFizz::MergeFrom(const CMsgTEFizz& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entity()) {
      set_entity(from.entity());
    }
    if (from.has_density()) {
      set_density(from.density());
    }
    if (from.has_current()) {
      set_current(from.current());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEFizz::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEFizz::CopyFrom(const CMsgTEFizz& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEFizz::IsInitialized() const {

  return true;
}

void CMsgTEFizz::Swap(CMsgTEFizz* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEFizz::InternalSwap(CMsgTEFizz* other) {
  std::swap(entity_, other->entity_);
  std::swap(density_, other->density_);
  std::swap(current_, other->current_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEFizz::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEFizz_descriptor_;
  metadata.reflection = CMsgTEFizz_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEFizz

// optional uint32 entity = 1;
bool CMsgTEFizz::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEFizz::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEFizz::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEFizz::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
 ::google::protobuf::uint32 CMsgTEFizz::entity() const {
  // @@protoc_insertion_point(field_get:CMsgTEFizz.entity)
  return entity_;
}
 void CMsgTEFizz::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEFizz.entity)
}

// optional uint32 density = 2;
bool CMsgTEFizz::has_density() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEFizz::set_has_density() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEFizz::clear_has_density() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEFizz::clear_density() {
  density_ = 0u;
  clear_has_density();
}
 ::google::protobuf::uint32 CMsgTEFizz::density() const {
  // @@protoc_insertion_point(field_get:CMsgTEFizz.density)
  return density_;
}
 void CMsgTEFizz::set_density(::google::protobuf::uint32 value) {
  set_has_density();
  density_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEFizz.density)
}

// optional int32 current = 3;
bool CMsgTEFizz::has_current() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEFizz::set_has_current() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEFizz::clear_has_current() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEFizz::clear_current() {
  current_ = 0;
  clear_has_current();
}
 ::google::protobuf::int32 CMsgTEFizz::current() const {
  // @@protoc_insertion_point(field_get:CMsgTEFizz.current)
  return current_;
}
 void CMsgTEFizz::set_current(::google::protobuf::int32 value) {
  set_has_current();
  current_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEFizz.current)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEShatterSurface::kOriginFieldNumber;
const int CMsgTEShatterSurface::kAnglesFieldNumber;
const int CMsgTEShatterSurface::kForceFieldNumber;
const int CMsgTEShatterSurface::kForceposFieldNumber;
const int CMsgTEShatterSurface::kWidthFieldNumber;
const int CMsgTEShatterSurface::kHeightFieldNumber;
const int CMsgTEShatterSurface::kShardsizeFieldNumber;
const int CMsgTEShatterSurface::kSurfacetypeFieldNumber;
const int CMsgTEShatterSurface::kFrontcolorFieldNumber;
const int CMsgTEShatterSurface::kBackcolorFieldNumber;
#endif  // !_MSC_VER

CMsgTEShatterSurface::CMsgTEShatterSurface()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEShatterSurface)
}

void CMsgTEShatterSurface::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
  force_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  forcepos_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEShatterSurface::CMsgTEShatterSurface(const CMsgTEShatterSurface& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEShatterSurface)
}

void CMsgTEShatterSurface::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  angles_ = NULL;
  force_ = NULL;
  forcepos_ = NULL;
  width_ = 0;
  height_ = 0;
  shardsize_ = 0;
  surfacetype_ = 0u;
  frontcolor_ = 0u;
  backcolor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEShatterSurface::~CMsgTEShatterSurface() {
  // @@protoc_insertion_point(destructor:CMsgTEShatterSurface)
  SharedDtor();
}

void CMsgTEShatterSurface::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete angles_;
    delete force_;
    delete forcepos_;
  }
}

void CMsgTEShatterSurface::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEShatterSurface::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEShatterSurface_descriptor_;
}

const CMsgTEShatterSurface& CMsgTEShatterSurface::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEShatterSurface* CMsgTEShatterSurface::default_instance_ = NULL;

CMsgTEShatterSurface* CMsgTEShatterSurface::New(::google::protobuf::Arena* arena) const {
  CMsgTEShatterSurface* n = new CMsgTEShatterSurface;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEShatterSurface::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEShatterSurface*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(width_, surfacetype_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
    if (has_force()) {
      if (force_ != NULL) force_->::CMsgVector::Clear();
    }
    if (has_forcepos()) {
      if (forcepos_ != NULL) forcepos_->::CMsgVector::Clear();
    }
  }
  ZR_(frontcolor_, backcolor_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEShatterSurface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEShatterSurface)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 2;
      case 2: {
        if (tag == 18) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_force;
        break;
      }

      // optional .CMsgVector force = 3;
      case 3: {
        if (tag == 26) {
         parse_force:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_force()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_forcepos;
        break;
      }

      // optional .CMsgVector forcepos = 4;
      case 4: {
        if (tag == 34) {
         parse_forcepos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_forcepos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_width;
        break;
      }

      // optional float width = 5;
      case 5: {
        if (tag == 45) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_height;
        break;
      }

      // optional float height = 6;
      case 6: {
        if (tag == 53) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_shardsize;
        break;
      }

      // optional float shardsize = 7;
      case 7: {
        if (tag == 61) {
         parse_shardsize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &shardsize_)));
          set_has_shardsize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_surfacetype;
        break;
      }

      // optional uint32 surfacetype = 8;
      case 8: {
        if (tag == 64) {
         parse_surfacetype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surfacetype_)));
          set_has_surfacetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_frontcolor;
        break;
      }

      // optional fixed32 frontcolor = 9;
      case 9: {
        if (tag == 77) {
         parse_frontcolor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &frontcolor_)));
          set_has_frontcolor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_backcolor;
        break;
      }

      // optional fixed32 backcolor = 10;
      case 10: {
        if (tag == 85) {
         parse_backcolor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &backcolor_)));
          set_has_backcolor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEShatterSurface)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEShatterSurface)
  return false;
#undef DO_
}

void CMsgTEShatterSurface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEShatterSurface)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angles_, output);
  }

  // optional .CMsgVector force = 3;
  if (has_force()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->force_, output);
  }

  // optional .CMsgVector forcepos = 4;
  if (has_forcepos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->forcepos_, output);
  }

  // optional float width = 5;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->width(), output);
  }

  // optional float height = 6;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->height(), output);
  }

  // optional float shardsize = 7;
  if (has_shardsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->shardsize(), output);
  }

  // optional uint32 surfacetype = 8;
  if (has_surfacetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->surfacetype(), output);
  }

  // optional fixed32 frontcolor = 9;
  if (has_frontcolor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(9, this->frontcolor(), output);
  }

  // optional fixed32 backcolor = 10;
  if (has_backcolor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->backcolor(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEShatterSurface)
}

::google::protobuf::uint8* CMsgTEShatterSurface::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEShatterSurface)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->angles_, target);
  }

  // optional .CMsgVector force = 3;
  if (has_force()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->force_, target);
  }

  // optional .CMsgVector forcepos = 4;
  if (has_forcepos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->forcepos_, target);
  }

  // optional float width = 5;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->width(), target);
  }

  // optional float height = 6;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->height(), target);
  }

  // optional float shardsize = 7;
  if (has_shardsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->shardsize(), target);
  }

  // optional uint32 surfacetype = 8;
  if (has_surfacetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->surfacetype(), target);
  }

  // optional fixed32 frontcolor = 9;
  if (has_frontcolor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(9, this->frontcolor(), target);
  }

  // optional fixed32 backcolor = 10;
  if (has_backcolor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->backcolor(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEShatterSurface)
  return target;
}

int CMsgTEShatterSurface::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional .CMsgVector force = 3;
    if (has_force()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->force_);
    }

    // optional .CMsgVector forcepos = 4;
    if (has_forcepos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->forcepos_);
    }

    // optional float width = 5;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // optional float height = 6;
    if (has_height()) {
      total_size += 1 + 4;
    }

    // optional float shardsize = 7;
    if (has_shardsize()) {
      total_size += 1 + 4;
    }

    // optional uint32 surfacetype = 8;
    if (has_surfacetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->surfacetype());
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional fixed32 frontcolor = 9;
    if (has_frontcolor()) {
      total_size += 1 + 4;
    }

    // optional fixed32 backcolor = 10;
    if (has_backcolor()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEShatterSurface::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEShatterSurface* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEShatterSurface>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEShatterSurface::MergeFrom(const CMsgTEShatterSurface& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_force()) {
      mutable_force()->::CMsgVector::MergeFrom(from.force());
    }
    if (from.has_forcepos()) {
      mutable_forcepos()->::CMsgVector::MergeFrom(from.forcepos());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_shardsize()) {
      set_shardsize(from.shardsize());
    }
    if (from.has_surfacetype()) {
      set_surfacetype(from.surfacetype());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_frontcolor()) {
      set_frontcolor(from.frontcolor());
    }
    if (from.has_backcolor()) {
      set_backcolor(from.backcolor());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEShatterSurface::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEShatterSurface::CopyFrom(const CMsgTEShatterSurface& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEShatterSurface::IsInitialized() const {

  return true;
}

void CMsgTEShatterSurface::Swap(CMsgTEShatterSurface* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEShatterSurface::InternalSwap(CMsgTEShatterSurface* other) {
  std::swap(origin_, other->origin_);
  std::swap(angles_, other->angles_);
  std::swap(force_, other->force_);
  std::swap(forcepos_, other->forcepos_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(shardsize_, other->shardsize_);
  std::swap(surfacetype_, other->surfacetype_);
  std::swap(frontcolor_, other->frontcolor_);
  std::swap(backcolor_, other->backcolor_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEShatterSurface::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEShatterSurface_descriptor_;
  metadata.reflection = CMsgTEShatterSurface_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEShatterSurface

// optional .CMsgVector origin = 1;
bool CMsgTEShatterSurface::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEShatterSurface::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEShatterSurface::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEShatterSurface::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEShatterSurface::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEShatterSurface::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEShatterSurface.origin)
  return origin_;
}
::CMsgVector* CMsgTEShatterSurface::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEShatterSurface::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEShatterSurface.origin)
}

// optional .CMsgQAngle angles = 2;
bool CMsgTEShatterSurface::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEShatterSurface::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEShatterSurface::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEShatterSurface::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgTEShatterSurface::angles() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgTEShatterSurface::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEShatterSurface.angles)
  return angles_;
}
::CMsgQAngle* CMsgTEShatterSurface::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgTEShatterSurface::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEShatterSurface.angles)
}

// optional .CMsgVector force = 3;
bool CMsgTEShatterSurface::has_force() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEShatterSurface::set_has_force() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEShatterSurface::clear_has_force() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEShatterSurface::clear_force() {
  if (force_ != NULL) force_->::CMsgVector::Clear();
  clear_has_force();
}
const ::CMsgVector& CMsgTEShatterSurface::force() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.force)
  return force_ != NULL ? *force_ : *default_instance_->force_;
}
::CMsgVector* CMsgTEShatterSurface::mutable_force() {
  set_has_force();
  if (force_ == NULL) {
    force_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEShatterSurface.force)
  return force_;
}
::CMsgVector* CMsgTEShatterSurface::release_force() {
  clear_has_force();
  ::CMsgVector* temp = force_;
  force_ = NULL;
  return temp;
}
void CMsgTEShatterSurface::set_allocated_force(::CMsgVector* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEShatterSurface.force)
}

// optional .CMsgVector forcepos = 4;
bool CMsgTEShatterSurface::has_forcepos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEShatterSurface::set_has_forcepos() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEShatterSurface::clear_has_forcepos() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEShatterSurface::clear_forcepos() {
  if (forcepos_ != NULL) forcepos_->::CMsgVector::Clear();
  clear_has_forcepos();
}
const ::CMsgVector& CMsgTEShatterSurface::forcepos() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.forcepos)
  return forcepos_ != NULL ? *forcepos_ : *default_instance_->forcepos_;
}
::CMsgVector* CMsgTEShatterSurface::mutable_forcepos() {
  set_has_forcepos();
  if (forcepos_ == NULL) {
    forcepos_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEShatterSurface.forcepos)
  return forcepos_;
}
::CMsgVector* CMsgTEShatterSurface::release_forcepos() {
  clear_has_forcepos();
  ::CMsgVector* temp = forcepos_;
  forcepos_ = NULL;
  return temp;
}
void CMsgTEShatterSurface::set_allocated_forcepos(::CMsgVector* forcepos) {
  delete forcepos_;
  forcepos_ = forcepos;
  if (forcepos) {
    set_has_forcepos();
  } else {
    clear_has_forcepos();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEShatterSurface.forcepos)
}

// optional float width = 5;
bool CMsgTEShatterSurface::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEShatterSurface::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEShatterSurface::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEShatterSurface::clear_width() {
  width_ = 0;
  clear_has_width();
}
 float CMsgTEShatterSurface::width() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.width)
  return width_;
}
 void CMsgTEShatterSurface::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.width)
}

// optional float height = 6;
bool CMsgTEShatterSurface::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgTEShatterSurface::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgTEShatterSurface::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgTEShatterSurface::clear_height() {
  height_ = 0;
  clear_has_height();
}
 float CMsgTEShatterSurface::height() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.height)
  return height_;
}
 void CMsgTEShatterSurface::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.height)
}

// optional float shardsize = 7;
bool CMsgTEShatterSurface::has_shardsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgTEShatterSurface::set_has_shardsize() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgTEShatterSurface::clear_has_shardsize() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgTEShatterSurface::clear_shardsize() {
  shardsize_ = 0;
  clear_has_shardsize();
}
 float CMsgTEShatterSurface::shardsize() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.shardsize)
  return shardsize_;
}
 void CMsgTEShatterSurface::set_shardsize(float value) {
  set_has_shardsize();
  shardsize_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.shardsize)
}

// optional uint32 surfacetype = 8;
bool CMsgTEShatterSurface::has_surfacetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgTEShatterSurface::set_has_surfacetype() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgTEShatterSurface::clear_has_surfacetype() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgTEShatterSurface::clear_surfacetype() {
  surfacetype_ = 0u;
  clear_has_surfacetype();
}
 ::google::protobuf::uint32 CMsgTEShatterSurface::surfacetype() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.surfacetype)
  return surfacetype_;
}
 void CMsgTEShatterSurface::set_surfacetype(::google::protobuf::uint32 value) {
  set_has_surfacetype();
  surfacetype_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.surfacetype)
}

// optional fixed32 frontcolor = 9;
bool CMsgTEShatterSurface::has_frontcolor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgTEShatterSurface::set_has_frontcolor() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgTEShatterSurface::clear_has_frontcolor() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgTEShatterSurface::clear_frontcolor() {
  frontcolor_ = 0u;
  clear_has_frontcolor();
}
 ::google::protobuf::uint32 CMsgTEShatterSurface::frontcolor() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.frontcolor)
  return frontcolor_;
}
 void CMsgTEShatterSurface::set_frontcolor(::google::protobuf::uint32 value) {
  set_has_frontcolor();
  frontcolor_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.frontcolor)
}

// optional fixed32 backcolor = 10;
bool CMsgTEShatterSurface::has_backcolor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void CMsgTEShatterSurface::set_has_backcolor() {
  _has_bits_[0] |= 0x00000200u;
}
void CMsgTEShatterSurface::clear_has_backcolor() {
  _has_bits_[0] &= ~0x00000200u;
}
void CMsgTEShatterSurface::clear_backcolor() {
  backcolor_ = 0u;
  clear_has_backcolor();
}
 ::google::protobuf::uint32 CMsgTEShatterSurface::backcolor() const {
  // @@protoc_insertion_point(field_get:CMsgTEShatterSurface.backcolor)
  return backcolor_;
}
 void CMsgTEShatterSurface::set_backcolor(::google::protobuf::uint32 value) {
  set_has_backcolor();
  backcolor_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEShatterSurface.backcolor)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEGlowSprite::kOriginFieldNumber;
const int CMsgTEGlowSprite::kScaleFieldNumber;
const int CMsgTEGlowSprite::kLifeFieldNumber;
const int CMsgTEGlowSprite::kBrightnessFieldNumber;
#endif  // !_MSC_VER

CMsgTEGlowSprite::CMsgTEGlowSprite()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEGlowSprite)
}

void CMsgTEGlowSprite::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEGlowSprite::CMsgTEGlowSprite(const CMsgTEGlowSprite& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEGlowSprite)
}

void CMsgTEGlowSprite::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  scale_ = 0;
  life_ = 0;
  brightness_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEGlowSprite::~CMsgTEGlowSprite() {
  // @@protoc_insertion_point(destructor:CMsgTEGlowSprite)
  SharedDtor();
}

void CMsgTEGlowSprite::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
  }
}

void CMsgTEGlowSprite::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEGlowSprite::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEGlowSprite_descriptor_;
}

const CMsgTEGlowSprite& CMsgTEGlowSprite::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEGlowSprite* CMsgTEGlowSprite::default_instance_ = NULL;

CMsgTEGlowSprite* CMsgTEGlowSprite::New(::google::protobuf::Arena* arena) const {
  CMsgTEGlowSprite* n = new CMsgTEGlowSprite;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEGlowSprite::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEGlowSprite*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(scale_, brightness_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEGlowSprite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEGlowSprite)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_scale;
        break;
      }

      // optional float scale = 2;
      case 2: {
        if (tag == 21) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_life;
        break;
      }

      // optional float life = 3;
      case 3: {
        if (tag == 29) {
         parse_life:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &life_)));
          set_has_life();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_brightness;
        break;
      }

      // optional uint32 brightness = 4;
      case 4: {
        if (tag == 32) {
         parse_brightness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &brightness_)));
          set_has_brightness();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEGlowSprite)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEGlowSprite)
  return false;
#undef DO_
}

void CMsgTEGlowSprite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEGlowSprite)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional float scale = 2;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->scale(), output);
  }

  // optional float life = 3;
  if (has_life()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->life(), output);
  }

  // optional uint32 brightness = 4;
  if (has_brightness()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->brightness(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEGlowSprite)
}

::google::protobuf::uint8* CMsgTEGlowSprite::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEGlowSprite)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional float scale = 2;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->scale(), target);
  }

  // optional float life = 3;
  if (has_life()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->life(), target);
  }

  // optional uint32 brightness = 4;
  if (has_brightness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->brightness(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEGlowSprite)
  return target;
}

int CMsgTEGlowSprite::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional float scale = 2;
    if (has_scale()) {
      total_size += 1 + 4;
    }

    // optional float life = 3;
    if (has_life()) {
      total_size += 1 + 4;
    }

    // optional uint32 brightness = 4;
    if (has_brightness()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->brightness());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEGlowSprite::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEGlowSprite* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEGlowSprite>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEGlowSprite::MergeFrom(const CMsgTEGlowSprite& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_life()) {
      set_life(from.life());
    }
    if (from.has_brightness()) {
      set_brightness(from.brightness());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEGlowSprite::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEGlowSprite::CopyFrom(const CMsgTEGlowSprite& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEGlowSprite::IsInitialized() const {

  return true;
}

void CMsgTEGlowSprite::Swap(CMsgTEGlowSprite* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEGlowSprite::InternalSwap(CMsgTEGlowSprite* other) {
  std::swap(origin_, other->origin_);
  std::swap(scale_, other->scale_);
  std::swap(life_, other->life_);
  std::swap(brightness_, other->brightness_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEGlowSprite::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEGlowSprite_descriptor_;
  metadata.reflection = CMsgTEGlowSprite_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEGlowSprite

// optional .CMsgVector origin = 1;
bool CMsgTEGlowSprite::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEGlowSprite::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEGlowSprite::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEGlowSprite::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEGlowSprite::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEGlowSprite.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEGlowSprite::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEGlowSprite.origin)
  return origin_;
}
::CMsgVector* CMsgTEGlowSprite::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEGlowSprite::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEGlowSprite.origin)
}

// optional float scale = 2;
bool CMsgTEGlowSprite::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEGlowSprite::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEGlowSprite::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEGlowSprite::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgTEGlowSprite::scale() const {
  // @@protoc_insertion_point(field_get:CMsgTEGlowSprite.scale)
  return scale_;
}
 void CMsgTEGlowSprite::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEGlowSprite.scale)
}

// optional float life = 3;
bool CMsgTEGlowSprite::has_life() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEGlowSprite::set_has_life() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEGlowSprite::clear_has_life() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEGlowSprite::clear_life() {
  life_ = 0;
  clear_has_life();
}
 float CMsgTEGlowSprite::life() const {
  // @@protoc_insertion_point(field_get:CMsgTEGlowSprite.life)
  return life_;
}
 void CMsgTEGlowSprite::set_life(float value) {
  set_has_life();
  life_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEGlowSprite.life)
}

// optional uint32 brightness = 4;
bool CMsgTEGlowSprite::has_brightness() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEGlowSprite::set_has_brightness() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEGlowSprite::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEGlowSprite::clear_brightness() {
  brightness_ = 0u;
  clear_has_brightness();
}
 ::google::protobuf::uint32 CMsgTEGlowSprite::brightness() const {
  // @@protoc_insertion_point(field_get:CMsgTEGlowSprite.brightness)
  return brightness_;
}
 void CMsgTEGlowSprite::set_brightness(::google::protobuf::uint32 value) {
  set_has_brightness();
  brightness_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEGlowSprite.brightness)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEImpact::kOriginFieldNumber;
const int CMsgTEImpact::kNormalFieldNumber;
const int CMsgTEImpact::kTypeFieldNumber;
#endif  // !_MSC_VER

CMsgTEImpact::CMsgTEImpact()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEImpact)
}

void CMsgTEImpact::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  normal_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEImpact::CMsgTEImpact(const CMsgTEImpact& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEImpact)
}

void CMsgTEImpact::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  normal_ = NULL;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEImpact::~CMsgTEImpact() {
  // @@protoc_insertion_point(destructor:CMsgTEImpact)
  SharedDtor();
}

void CMsgTEImpact::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete normal_;
  }
}

void CMsgTEImpact::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEImpact::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEImpact_descriptor_;
}

const CMsgTEImpact& CMsgTEImpact::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEImpact* CMsgTEImpact::default_instance_ = NULL;

CMsgTEImpact* CMsgTEImpact::New(::google::protobuf::Arena* arena) const {
  CMsgTEImpact* n = new CMsgTEImpact;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEImpact::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::CMsgVector::Clear();
    }
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEImpact::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEImpact)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_normal;
        break;
      }

      // optional .CMsgVector normal = 2;
      case 2: {
        if (tag == 18) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional uint32 type = 3;
      case 3: {
        if (tag == 24) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEImpact)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEImpact)
  return false;
#undef DO_
}

void CMsgTEImpact::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEImpact)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->normal_, output);
  }

  // optional uint32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEImpact)
}

::google::protobuf::uint8* CMsgTEImpact::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEImpact)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->normal_, target);
  }

  // optional uint32 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEImpact)
  return target;
}

int CMsgTEImpact::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector normal = 2;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->normal_);
    }

    // optional uint32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEImpact::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEImpact* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEImpact>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEImpact::MergeFrom(const CMsgTEImpact& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_normal()) {
      mutable_normal()->::CMsgVector::MergeFrom(from.normal());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEImpact::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEImpact::CopyFrom(const CMsgTEImpact& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEImpact::IsInitialized() const {

  return true;
}

void CMsgTEImpact::Swap(CMsgTEImpact* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEImpact::InternalSwap(CMsgTEImpact* other) {
  std::swap(origin_, other->origin_);
  std::swap(normal_, other->normal_);
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEImpact::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEImpact_descriptor_;
  metadata.reflection = CMsgTEImpact_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEImpact

// optional .CMsgVector origin = 1;
bool CMsgTEImpact::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEImpact::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEImpact::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEImpact::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEImpact::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEImpact.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEImpact::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEImpact.origin)
  return origin_;
}
::CMsgVector* CMsgTEImpact::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEImpact::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEImpact.origin)
}

// optional .CMsgVector normal = 2;
bool CMsgTEImpact::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEImpact::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEImpact::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEImpact::clear_normal() {
  if (normal_ != NULL) normal_->::CMsgVector::Clear();
  clear_has_normal();
}
const ::CMsgVector& CMsgTEImpact::normal() const {
  // @@protoc_insertion_point(field_get:CMsgTEImpact.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
::CMsgVector* CMsgTEImpact::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEImpact.normal)
  return normal_;
}
::CMsgVector* CMsgTEImpact::release_normal() {
  clear_has_normal();
  ::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
void CMsgTEImpact::set_allocated_normal(::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEImpact.normal)
}

// optional uint32 type = 3;
bool CMsgTEImpact::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEImpact::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEImpact::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEImpact::clear_type() {
  type_ = 0u;
  clear_has_type();
}
 ::google::protobuf::uint32 CMsgTEImpact::type() const {
  // @@protoc_insertion_point(field_get:CMsgTEImpact.type)
  return type_;
}
 void CMsgTEImpact::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEImpact.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEMuzzleFlash::kOriginFieldNumber;
const int CMsgTEMuzzleFlash::kAnglesFieldNumber;
const int CMsgTEMuzzleFlash::kScaleFieldNumber;
const int CMsgTEMuzzleFlash::kTypeFieldNumber;
#endif  // !_MSC_VER

CMsgTEMuzzleFlash::CMsgTEMuzzleFlash()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEMuzzleFlash)
}

void CMsgTEMuzzleFlash::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
}

CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEMuzzleFlash)
}

void CMsgTEMuzzleFlash::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  angles_ = NULL;
  scale_ = 0;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEMuzzleFlash::~CMsgTEMuzzleFlash() {
  // @@protoc_insertion_point(destructor:CMsgTEMuzzleFlash)
  SharedDtor();
}

void CMsgTEMuzzleFlash::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete angles_;
  }
}

void CMsgTEMuzzleFlash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEMuzzleFlash::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEMuzzleFlash_descriptor_;
}

const CMsgTEMuzzleFlash& CMsgTEMuzzleFlash::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEMuzzleFlash* CMsgTEMuzzleFlash::default_instance_ = NULL;

CMsgTEMuzzleFlash* CMsgTEMuzzleFlash::New(::google::protobuf::Arena* arena) const {
  CMsgTEMuzzleFlash* n = new CMsgTEMuzzleFlash;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEMuzzleFlash::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEMuzzleFlash*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(scale_, type_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEMuzzleFlash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEMuzzleFlash)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 2;
      case 2: {
        if (tag == 18) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_scale;
        break;
      }

      // optional float scale = 3;
      case 3: {
        if (tag == 29) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional uint32 type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEMuzzleFlash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEMuzzleFlash)
  return false;
#undef DO_
}

void CMsgTEMuzzleFlash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEMuzzleFlash)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angles_, output);
  }

  // optional float scale = 3;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->scale(), output);
  }

  // optional uint32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEMuzzleFlash)
}

::google::protobuf::uint8* CMsgTEMuzzleFlash::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEMuzzleFlash)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->angles_, target);
  }

  // optional float scale = 3;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->scale(), target);
  }

  // optional uint32 type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEMuzzleFlash)
  return target;
}

int CMsgTEMuzzleFlash::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional float scale = 3;
    if (has_scale()) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEMuzzleFlash::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEMuzzleFlash* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEMuzzleFlash>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEMuzzleFlash::MergeFrom(const CMsgTEMuzzleFlash& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEMuzzleFlash::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEMuzzleFlash::CopyFrom(const CMsgTEMuzzleFlash& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEMuzzleFlash::IsInitialized() const {

  return true;
}

void CMsgTEMuzzleFlash::Swap(CMsgTEMuzzleFlash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEMuzzleFlash::InternalSwap(CMsgTEMuzzleFlash* other) {
  std::swap(origin_, other->origin_);
  std::swap(angles_, other->angles_);
  std::swap(scale_, other->scale_);
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEMuzzleFlash::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEMuzzleFlash_descriptor_;
  metadata.reflection = CMsgTEMuzzleFlash_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEMuzzleFlash

// optional .CMsgVector origin = 1;
bool CMsgTEMuzzleFlash::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEMuzzleFlash::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEMuzzleFlash::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEMuzzleFlash::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEMuzzleFlash::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEMuzzleFlash.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEMuzzleFlash::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEMuzzleFlash.origin)
  return origin_;
}
::CMsgVector* CMsgTEMuzzleFlash::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEMuzzleFlash::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEMuzzleFlash.origin)
}

// optional .CMsgQAngle angles = 2;
bool CMsgTEMuzzleFlash::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEMuzzleFlash::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEMuzzleFlash::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEMuzzleFlash::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgTEMuzzleFlash::angles() const {
  // @@protoc_insertion_point(field_get:CMsgTEMuzzleFlash.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgTEMuzzleFlash::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEMuzzleFlash.angles)
  return angles_;
}
::CMsgQAngle* CMsgTEMuzzleFlash::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgTEMuzzleFlash::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEMuzzleFlash.angles)
}

// optional float scale = 3;
bool CMsgTEMuzzleFlash::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEMuzzleFlash::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEMuzzleFlash::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEMuzzleFlash::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgTEMuzzleFlash::scale() const {
  // @@protoc_insertion_point(field_get:CMsgTEMuzzleFlash.scale)
  return scale_;
}
 void CMsgTEMuzzleFlash::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEMuzzleFlash.scale)
}

// optional uint32 type = 4;
bool CMsgTEMuzzleFlash::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEMuzzleFlash::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEMuzzleFlash::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEMuzzleFlash::clear_type() {
  type_ = 0u;
  clear_has_type();
}
 ::google::protobuf::uint32 CMsgTEMuzzleFlash::type() const {
  // @@protoc_insertion_point(field_get:CMsgTEMuzzleFlash.type)
  return type_;
}
 void CMsgTEMuzzleFlash::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEMuzzleFlash.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEBloodStream::kOriginFieldNumber;
const int CMsgTEBloodStream::kDirectionFieldNumber;
const int CMsgTEBloodStream::kColorFieldNumber;
const int CMsgTEBloodStream::kAmountFieldNumber;
#endif  // !_MSC_VER

CMsgTEBloodStream::CMsgTEBloodStream()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEBloodStream)
}

void CMsgTEBloodStream::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  direction_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEBloodStream::CMsgTEBloodStream(const CMsgTEBloodStream& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBloodStream)
}

void CMsgTEBloodStream::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  direction_ = NULL;
  color_ = 0u;
  amount_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEBloodStream::~CMsgTEBloodStream() {
  // @@protoc_insertion_point(destructor:CMsgTEBloodStream)
  SharedDtor();
}

void CMsgTEBloodStream::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete direction_;
  }
}

void CMsgTEBloodStream::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEBloodStream::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEBloodStream_descriptor_;
}

const CMsgTEBloodStream& CMsgTEBloodStream::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEBloodStream* CMsgTEBloodStream::default_instance_ = NULL;

CMsgTEBloodStream* CMsgTEBloodStream::New(::google::protobuf::Arena* arena) const {
  CMsgTEBloodStream* n = new CMsgTEBloodStream;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEBloodStream::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEBloodStream*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(color_, amount_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_direction()) {
      if (direction_ != NULL) direction_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEBloodStream::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEBloodStream)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_direction;
        break;
      }

      // optional .CMsgVector direction = 2;
      case 2: {
        if (tag == 18) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_color;
        break;
      }

      // optional fixed32 color = 3;
      case 3: {
        if (tag == 29) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_amount;
        break;
      }

      // optional uint32 amount = 4;
      case 4: {
        if (tag == 32) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEBloodStream)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEBloodStream)
  return false;
#undef DO_
}

void CMsgTEBloodStream::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEBloodStream)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->direction_, output);
  }

  // optional fixed32 color = 3;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->color(), output);
  }

  // optional uint32 amount = 4;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->amount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEBloodStream)
}

::google::protobuf::uint8* CMsgTEBloodStream::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBloodStream)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector direction = 2;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->direction_, target);
  }

  // optional fixed32 color = 3;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(3, this->color(), target);
  }

  // optional uint32 amount = 4;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->amount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBloodStream)
  return target;
}

int CMsgTEBloodStream::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector direction = 2;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->direction_);
    }

    // optional fixed32 color = 3;
    if (has_color()) {
      total_size += 1 + 4;
    }

    // optional uint32 amount = 4;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->amount());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEBloodStream::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEBloodStream* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEBloodStream>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEBloodStream::MergeFrom(const CMsgTEBloodStream& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_direction()) {
      mutable_direction()->::CMsgVector::MergeFrom(from.direction());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEBloodStream::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBloodStream::CopyFrom(const CMsgTEBloodStream& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBloodStream::IsInitialized() const {

  return true;
}

void CMsgTEBloodStream::Swap(CMsgTEBloodStream* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBloodStream::InternalSwap(CMsgTEBloodStream* other) {
  std::swap(origin_, other->origin_);
  std::swap(direction_, other->direction_);
  std::swap(color_, other->color_);
  std::swap(amount_, other->amount_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEBloodStream::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEBloodStream_descriptor_;
  metadata.reflection = CMsgTEBloodStream_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEBloodStream

// optional .CMsgVector origin = 1;
bool CMsgTEBloodStream::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEBloodStream::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEBloodStream::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBloodStream::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEBloodStream::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEBloodStream.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEBloodStream::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBloodStream.origin)
  return origin_;
}
::CMsgVector* CMsgTEBloodStream::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEBloodStream::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBloodStream.origin)
}

// optional .CMsgVector direction = 2;
bool CMsgTEBloodStream::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEBloodStream::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEBloodStream::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBloodStream::clear_direction() {
  if (direction_ != NULL) direction_->::CMsgVector::Clear();
  clear_has_direction();
}
const ::CMsgVector& CMsgTEBloodStream::direction() const {
  // @@protoc_insertion_point(field_get:CMsgTEBloodStream.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
::CMsgVector* CMsgTEBloodStream::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEBloodStream.direction)
  return direction_;
}
::CMsgVector* CMsgTEBloodStream::release_direction() {
  clear_has_direction();
  ::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
void CMsgTEBloodStream::set_allocated_direction(::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEBloodStream.direction)
}

// optional fixed32 color = 3;
bool CMsgTEBloodStream::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEBloodStream::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEBloodStream::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBloodStream::clear_color() {
  color_ = 0u;
  clear_has_color();
}
 ::google::protobuf::uint32 CMsgTEBloodStream::color() const {
  // @@protoc_insertion_point(field_get:CMsgTEBloodStream.color)
  return color_;
}
 void CMsgTEBloodStream::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBloodStream.color)
}

// optional uint32 amount = 4;
bool CMsgTEBloodStream::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEBloodStream::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEBloodStream::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEBloodStream::clear_amount() {
  amount_ = 0u;
  clear_has_amount();
}
 ::google::protobuf::uint32 CMsgTEBloodStream::amount() const {
  // @@protoc_insertion_point(field_get:CMsgTEBloodStream.amount)
  return amount_;
}
 void CMsgTEBloodStream::set_amount(::google::protobuf::uint32 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEBloodStream.amount)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEExplosion::kOriginFieldNumber;
const int CMsgTEExplosion::kFramerateFieldNumber;
const int CMsgTEExplosion::kFlagsFieldNumber;
const int CMsgTEExplosion::kNormalFieldNumber;
const int CMsgTEExplosion::kMaterialtypeFieldNumber;
const int CMsgTEExplosion::kRadiusFieldNumber;
const int CMsgTEExplosion::kMagnitudeFieldNumber;
const int CMsgTEExplosion::kScaleFieldNumber;
const int CMsgTEExplosion::kAffectRagdollsFieldNumber;
#endif  // !_MSC_VER

CMsgTEExplosion::CMsgTEExplosion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEExplosion)
}

void CMsgTEExplosion::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  normal_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEExplosion::CMsgTEExplosion(const CMsgTEExplosion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEExplosion)
}

void CMsgTEExplosion::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  framerate_ = 0u;
  flags_ = 0u;
  normal_ = NULL;
  materialtype_ = 0u;
  radius_ = 0u;
  magnitude_ = 0u;
  scale_ = 0;
  affect_ragdolls_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEExplosion::~CMsgTEExplosion() {
  // @@protoc_insertion_point(destructor:CMsgTEExplosion)
  SharedDtor();
}

void CMsgTEExplosion::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete normal_;
  }
}

void CMsgTEExplosion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEExplosion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEExplosion_descriptor_;
}

const CMsgTEExplosion& CMsgTEExplosion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEExplosion* CMsgTEExplosion::default_instance_ = NULL;

CMsgTEExplosion* CMsgTEExplosion::New(::google::protobuf::Arena* arena) const {
  CMsgTEExplosion* n = new CMsgTEExplosion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEExplosion::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEExplosion*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(framerate_, flags_);
    ZR_(materialtype_, scale_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::CMsgVector::Clear();
    }
  }
  affect_ragdolls_ = false;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEExplosion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEExplosion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_framerate;
        break;
      }

      // optional uint32 framerate = 2;
      case 2: {
        if (tag == 16) {
         parse_framerate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framerate_)));
          set_has_framerate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (tag == 24) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_normal;
        break;
      }

      // optional .CMsgVector normal = 4;
      case 4: {
        if (tag == 34) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_materialtype;
        break;
      }

      // optional uint32 materialtype = 5;
      case 5: {
        if (tag == 40) {
         parse_materialtype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &materialtype_)));
          set_has_materialtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_radius;
        break;
      }

      // optional uint32 radius = 6;
      case 6: {
        if (tag == 48) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_magnitude;
        break;
      }

      // optional uint32 magnitude = 7;
      case 7: {
        if (tag == 56) {
         parse_magnitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magnitude_)));
          set_has_magnitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_scale;
        break;
      }

      // optional float scale = 8;
      case 8: {
        if (tag == 69) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_affect_ragdolls;
        break;
      }

      // optional bool affect_ragdolls = 9;
      case 9: {
        if (tag == 72) {
         parse_affect_ragdolls:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &affect_ragdolls_)));
          set_has_affect_ragdolls();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEExplosion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEExplosion)
  return false;
#undef DO_
}

void CMsgTEExplosion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEExplosion)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional uint32 framerate = 2;
  if (has_framerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->framerate(), output);
  }

  // optional uint32 flags = 3;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional .CMsgVector normal = 4;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->normal_, output);
  }

  // optional uint32 materialtype = 5;
  if (has_materialtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->materialtype(), output);
  }

  // optional uint32 radius = 6;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->radius(), output);
  }

  // optional uint32 magnitude = 7;
  if (has_magnitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->magnitude(), output);
  }

  // optional float scale = 8;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->scale(), output);
  }

  // optional bool affect_ragdolls = 9;
  if (has_affect_ragdolls()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->affect_ragdolls(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEExplosion)
}

::google::protobuf::uint8* CMsgTEExplosion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEExplosion)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional uint32 framerate = 2;
  if (has_framerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->framerate(), target);
  }

  // optional uint32 flags = 3;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->flags(), target);
  }

  // optional .CMsgVector normal = 4;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->normal_, target);
  }

  // optional uint32 materialtype = 5;
  if (has_materialtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->materialtype(), target);
  }

  // optional uint32 radius = 6;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->radius(), target);
  }

  // optional uint32 magnitude = 7;
  if (has_magnitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->magnitude(), target);
  }

  // optional float scale = 8;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->scale(), target);
  }

  // optional bool affect_ragdolls = 9;
  if (has_affect_ragdolls()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->affect_ragdolls(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEExplosion)
  return target;
}

int CMsgTEExplosion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional uint32 framerate = 2;
    if (has_framerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framerate());
    }

    // optional uint32 flags = 3;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional .CMsgVector normal = 4;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->normal_);
    }

    // optional uint32 materialtype = 5;
    if (has_materialtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->materialtype());
    }

    // optional uint32 radius = 6;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

    // optional uint32 magnitude = 7;
    if (has_magnitude()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magnitude());
    }

    // optional float scale = 8;
    if (has_scale()) {
      total_size += 1 + 4;
    }

  }
  // optional bool affect_ragdolls = 9;
  if (has_affect_ragdolls()) {
    total_size += 1 + 1;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEExplosion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEExplosion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEExplosion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEExplosion::MergeFrom(const CMsgTEExplosion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_framerate()) {
      set_framerate(from.framerate());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_normal()) {
      mutable_normal()->::CMsgVector::MergeFrom(from.normal());
    }
    if (from.has_materialtype()) {
      set_materialtype(from.materialtype());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_magnitude()) {
      set_magnitude(from.magnitude());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_affect_ragdolls()) {
      set_affect_ragdolls(from.affect_ragdolls());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEExplosion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEExplosion::CopyFrom(const CMsgTEExplosion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEExplosion::IsInitialized() const {

  return true;
}

void CMsgTEExplosion::Swap(CMsgTEExplosion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEExplosion::InternalSwap(CMsgTEExplosion* other) {
  std::swap(origin_, other->origin_);
  std::swap(framerate_, other->framerate_);
  std::swap(flags_, other->flags_);
  std::swap(normal_, other->normal_);
  std::swap(materialtype_, other->materialtype_);
  std::swap(radius_, other->radius_);
  std::swap(magnitude_, other->magnitude_);
  std::swap(scale_, other->scale_);
  std::swap(affect_ragdolls_, other->affect_ragdolls_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEExplosion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEExplosion_descriptor_;
  metadata.reflection = CMsgTEExplosion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEExplosion

// optional .CMsgVector origin = 1;
bool CMsgTEExplosion::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEExplosion::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEExplosion::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEExplosion::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEExplosion::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEExplosion::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEExplosion.origin)
  return origin_;
}
::CMsgVector* CMsgTEExplosion::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEExplosion::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEExplosion.origin)
}

// optional uint32 framerate = 2;
bool CMsgTEExplosion::has_framerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEExplosion::set_has_framerate() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEExplosion::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEExplosion::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
 ::google::protobuf::uint32 CMsgTEExplosion::framerate() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.framerate)
  return framerate_;
}
 void CMsgTEExplosion::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.framerate)
}

// optional uint32 flags = 3;
bool CMsgTEExplosion::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEExplosion::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEExplosion::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEExplosion::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 CMsgTEExplosion::flags() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.flags)
  return flags_;
}
 void CMsgTEExplosion::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.flags)
}

// optional .CMsgVector normal = 4;
bool CMsgTEExplosion::has_normal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEExplosion::set_has_normal() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEExplosion::clear_has_normal() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEExplosion::clear_normal() {
  if (normal_ != NULL) normal_->::CMsgVector::Clear();
  clear_has_normal();
}
const ::CMsgVector& CMsgTEExplosion::normal() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
::CMsgVector* CMsgTEExplosion::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEExplosion.normal)
  return normal_;
}
::CMsgVector* CMsgTEExplosion::release_normal() {
  clear_has_normal();
  ::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
void CMsgTEExplosion::set_allocated_normal(::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEExplosion.normal)
}

// optional uint32 materialtype = 5;
bool CMsgTEExplosion::has_materialtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEExplosion::set_has_materialtype() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEExplosion::clear_has_materialtype() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEExplosion::clear_materialtype() {
  materialtype_ = 0u;
  clear_has_materialtype();
}
 ::google::protobuf::uint32 CMsgTEExplosion::materialtype() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.materialtype)
  return materialtype_;
}
 void CMsgTEExplosion::set_materialtype(::google::protobuf::uint32 value) {
  set_has_materialtype();
  materialtype_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.materialtype)
}

// optional uint32 radius = 6;
bool CMsgTEExplosion::has_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgTEExplosion::set_has_radius() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgTEExplosion::clear_has_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgTEExplosion::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
 ::google::protobuf::uint32 CMsgTEExplosion::radius() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.radius)
  return radius_;
}
 void CMsgTEExplosion::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.radius)
}

// optional uint32 magnitude = 7;
bool CMsgTEExplosion::has_magnitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgTEExplosion::set_has_magnitude() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgTEExplosion::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgTEExplosion::clear_magnitude() {
  magnitude_ = 0u;
  clear_has_magnitude();
}
 ::google::protobuf::uint32 CMsgTEExplosion::magnitude() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.magnitude)
  return magnitude_;
}
 void CMsgTEExplosion::set_magnitude(::google::protobuf::uint32 value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.magnitude)
}

// optional float scale = 8;
bool CMsgTEExplosion::has_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgTEExplosion::set_has_scale() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgTEExplosion::clear_has_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgTEExplosion::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgTEExplosion::scale() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.scale)
  return scale_;
}
 void CMsgTEExplosion::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.scale)
}

// optional bool affect_ragdolls = 9;
bool CMsgTEExplosion::has_affect_ragdolls() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgTEExplosion::set_has_affect_ragdolls() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgTEExplosion::clear_has_affect_ragdolls() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgTEExplosion::clear_affect_ragdolls() {
  affect_ragdolls_ = false;
  clear_has_affect_ragdolls();
}
 bool CMsgTEExplosion::affect_ragdolls() const {
  // @@protoc_insertion_point(field_get:CMsgTEExplosion.affect_ragdolls)
  return affect_ragdolls_;
}
 void CMsgTEExplosion::set_affect_ragdolls(bool value) {
  set_has_affect_ragdolls();
  affect_ragdolls_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEExplosion.affect_ragdolls)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEDust::kOriginFieldNumber;
const int CMsgTEDust::kSizeFieldNumber;
const int CMsgTEDust::kSpeedFieldNumber;
const int CMsgTEDust::kDirectionFieldNumber;
#endif  // !_MSC_VER

CMsgTEDust::CMsgTEDust()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEDust)
}

void CMsgTEDust::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  direction_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEDust::CMsgTEDust(const CMsgTEDust& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEDust)
}

void CMsgTEDust::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  size_ = 0;
  speed_ = 0;
  direction_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEDust::~CMsgTEDust() {
  // @@protoc_insertion_point(destructor:CMsgTEDust)
  SharedDtor();
}

void CMsgTEDust::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete direction_;
  }
}

void CMsgTEDust::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEDust::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEDust_descriptor_;
}

const CMsgTEDust& CMsgTEDust::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEDust* CMsgTEDust::default_instance_ = NULL;

CMsgTEDust* CMsgTEDust::New(::google::protobuf::Arena* arena) const {
  CMsgTEDust* n = new CMsgTEDust;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEDust::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEDust*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(size_, speed_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_direction()) {
      if (direction_ != NULL) direction_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEDust::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEDust)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_size;
        break;
      }

      // optional float size = 2;
      case 2: {
        if (tag == 21) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_speed;
        break;
      }

      // optional float speed = 3;
      case 3: {
        if (tag == 29) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_direction;
        break;
      }

      // optional .CMsgVector direction = 4;
      case 4: {
        if (tag == 34) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEDust)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEDust)
  return false;
#undef DO_
}

void CMsgTEDust::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEDust)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional float size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->size(), output);
  }

  // optional float speed = 3;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speed(), output);
  }

  // optional .CMsgVector direction = 4;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->direction_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEDust)
}

::google::protobuf::uint8* CMsgTEDust::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDust)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional float size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->size(), target);
  }

  // optional float speed = 3;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->speed(), target);
  }

  // optional .CMsgVector direction = 4;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->direction_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDust)
  return target;
}

int CMsgTEDust::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional float size = 2;
    if (has_size()) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // optional .CMsgVector direction = 4;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->direction_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEDust::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEDust* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEDust>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEDust::MergeFrom(const CMsgTEDust& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_direction()) {
      mutable_direction()->::CMsgVector::MergeFrom(from.direction());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEDust::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDust::CopyFrom(const CMsgTEDust& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDust::IsInitialized() const {

  return true;
}

void CMsgTEDust::Swap(CMsgTEDust* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEDust::InternalSwap(CMsgTEDust* other) {
  std::swap(origin_, other->origin_);
  std::swap(size_, other->size_);
  std::swap(speed_, other->speed_);
  std::swap(direction_, other->direction_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEDust::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEDust_descriptor_;
  metadata.reflection = CMsgTEDust_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEDust

// optional .CMsgVector origin = 1;
bool CMsgTEDust::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEDust::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEDust::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDust::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEDust::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEDust.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEDust::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEDust.origin)
  return origin_;
}
::CMsgVector* CMsgTEDust::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEDust::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEDust.origin)
}

// optional float size = 2;
bool CMsgTEDust::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEDust::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEDust::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEDust::clear_size() {
  size_ = 0;
  clear_has_size();
}
 float CMsgTEDust::size() const {
  // @@protoc_insertion_point(field_get:CMsgTEDust.size)
  return size_;
}
 void CMsgTEDust::set_size(float value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEDust.size)
}

// optional float speed = 3;
bool CMsgTEDust::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEDust::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEDust::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEDust::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float CMsgTEDust::speed() const {
  // @@protoc_insertion_point(field_get:CMsgTEDust.speed)
  return speed_;
}
 void CMsgTEDust::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEDust.speed)
}

// optional .CMsgVector direction = 4;
bool CMsgTEDust::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEDust::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEDust::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEDust::clear_direction() {
  if (direction_ != NULL) direction_->::CMsgVector::Clear();
  clear_has_direction();
}
const ::CMsgVector& CMsgTEDust::direction() const {
  // @@protoc_insertion_point(field_get:CMsgTEDust.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
::CMsgVector* CMsgTEDust::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEDust.direction)
  return direction_;
}
::CMsgVector* CMsgTEDust::release_direction() {
  clear_has_direction();
  ::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
void CMsgTEDust::set_allocated_direction(::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEDust.direction)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTELargeFunnel::kOriginFieldNumber;
const int CMsgTELargeFunnel::kReversedFieldNumber;
#endif  // !_MSC_VER

CMsgTELargeFunnel::CMsgTELargeFunnel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTELargeFunnel)
}

void CMsgTELargeFunnel::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTELargeFunnel::CMsgTELargeFunnel(const CMsgTELargeFunnel& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTELargeFunnel)
}

void CMsgTELargeFunnel::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  reversed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTELargeFunnel::~CMsgTELargeFunnel() {
  // @@protoc_insertion_point(destructor:CMsgTELargeFunnel)
  SharedDtor();
}

void CMsgTELargeFunnel::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
  }
}

void CMsgTELargeFunnel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTELargeFunnel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTELargeFunnel_descriptor_;
}

const CMsgTELargeFunnel& CMsgTELargeFunnel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTELargeFunnel* CMsgTELargeFunnel::default_instance_ = NULL;

CMsgTELargeFunnel* CMsgTELargeFunnel::New(::google::protobuf::Arena* arena) const {
  CMsgTELargeFunnel* n = new CMsgTELargeFunnel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTELargeFunnel::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    reversed_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTELargeFunnel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTELargeFunnel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_reversed;
        break;
      }

      // optional uint32 reversed = 2;
      case 2: {
        if (tag == 16) {
         parse_reversed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reversed_)));
          set_has_reversed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTELargeFunnel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTELargeFunnel)
  return false;
#undef DO_
}

void CMsgTELargeFunnel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTELargeFunnel)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional uint32 reversed = 2;
  if (has_reversed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->reversed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTELargeFunnel)
}

::google::protobuf::uint8* CMsgTELargeFunnel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTELargeFunnel)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional uint32 reversed = 2;
  if (has_reversed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->reversed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTELargeFunnel)
  return target;
}

int CMsgTELargeFunnel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional uint32 reversed = 2;
    if (has_reversed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reversed());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTELargeFunnel::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTELargeFunnel* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTELargeFunnel>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTELargeFunnel::MergeFrom(const CMsgTELargeFunnel& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_reversed()) {
      set_reversed(from.reversed());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTELargeFunnel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTELargeFunnel::CopyFrom(const CMsgTELargeFunnel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTELargeFunnel::IsInitialized() const {

  return true;
}

void CMsgTELargeFunnel::Swap(CMsgTELargeFunnel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTELargeFunnel::InternalSwap(CMsgTELargeFunnel* other) {
  std::swap(origin_, other->origin_);
  std::swap(reversed_, other->reversed_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTELargeFunnel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTELargeFunnel_descriptor_;
  metadata.reflection = CMsgTELargeFunnel_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTELargeFunnel

// optional .CMsgVector origin = 1;
bool CMsgTELargeFunnel::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTELargeFunnel::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTELargeFunnel::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTELargeFunnel::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTELargeFunnel::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTELargeFunnel.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTELargeFunnel::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTELargeFunnel.origin)
  return origin_;
}
::CMsgVector* CMsgTELargeFunnel::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTELargeFunnel::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTELargeFunnel.origin)
}

// optional uint32 reversed = 2;
bool CMsgTELargeFunnel::has_reversed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTELargeFunnel::set_has_reversed() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTELargeFunnel::clear_has_reversed() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTELargeFunnel::clear_reversed() {
  reversed_ = 0u;
  clear_has_reversed();
}
 ::google::protobuf::uint32 CMsgTELargeFunnel::reversed() const {
  // @@protoc_insertion_point(field_get:CMsgTELargeFunnel.reversed)
  return reversed_;
}
 void CMsgTELargeFunnel::set_reversed(::google::protobuf::uint32 value) {
  set_has_reversed();
  reversed_ = value;
  // @@protoc_insertion_point(field_set:CMsgTELargeFunnel.reversed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTESparks::kOriginFieldNumber;
const int CMsgTESparks::kMagnitudeFieldNumber;
const int CMsgTESparks::kLengthFieldNumber;
const int CMsgTESparks::kDirectionFieldNumber;
#endif  // !_MSC_VER

CMsgTESparks::CMsgTESparks()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTESparks)
}

void CMsgTESparks::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  direction_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTESparks::CMsgTESparks(const CMsgTESparks& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTESparks)
}

void CMsgTESparks::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  magnitude_ = 0u;
  length_ = 0u;
  direction_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTESparks::~CMsgTESparks() {
  // @@protoc_insertion_point(destructor:CMsgTESparks)
  SharedDtor();
}

void CMsgTESparks::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete direction_;
  }
}

void CMsgTESparks::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTESparks::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTESparks_descriptor_;
}

const CMsgTESparks& CMsgTESparks::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTESparks* CMsgTESparks::default_instance_ = NULL;

CMsgTESparks* CMsgTESparks::New(::google::protobuf::Arena* arena) const {
  CMsgTESparks* n = new CMsgTESparks;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTESparks::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTESparks*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(magnitude_, length_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_direction()) {
      if (direction_ != NULL) direction_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTESparks::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTESparks)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_magnitude;
        break;
      }

      // optional uint32 magnitude = 2;
      case 2: {
        if (tag == 16) {
         parse_magnitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magnitude_)));
          set_has_magnitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_length;
        break;
      }

      // optional uint32 length = 3;
      case 3: {
        if (tag == 24) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_direction;
        break;
      }

      // optional .CMsgVector direction = 4;
      case 4: {
        if (tag == 34) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTESparks)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTESparks)
  return false;
#undef DO_
}

void CMsgTESparks::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTESparks)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional uint32 magnitude = 2;
  if (has_magnitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->magnitude(), output);
  }

  // optional uint32 length = 3;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->length(), output);
  }

  // optional .CMsgVector direction = 4;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->direction_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTESparks)
}

::google::protobuf::uint8* CMsgTESparks::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESparks)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional uint32 magnitude = 2;
  if (has_magnitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->magnitude(), target);
  }

  // optional uint32 length = 3;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->length(), target);
  }

  // optional .CMsgVector direction = 4;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->direction_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESparks)
  return target;
}

int CMsgTESparks::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional uint32 magnitude = 2;
    if (has_magnitude()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magnitude());
    }

    // optional uint32 length = 3;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

    // optional .CMsgVector direction = 4;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->direction_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTESparks::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTESparks* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTESparks>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTESparks::MergeFrom(const CMsgTESparks& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_magnitude()) {
      set_magnitude(from.magnitude());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_direction()) {
      mutable_direction()->::CMsgVector::MergeFrom(from.direction());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTESparks::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESparks::CopyFrom(const CMsgTESparks& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESparks::IsInitialized() const {

  return true;
}

void CMsgTESparks::Swap(CMsgTESparks* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTESparks::InternalSwap(CMsgTESparks* other) {
  std::swap(origin_, other->origin_);
  std::swap(magnitude_, other->magnitude_);
  std::swap(length_, other->length_);
  std::swap(direction_, other->direction_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTESparks::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTESparks_descriptor_;
  metadata.reflection = CMsgTESparks_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTESparks

// optional .CMsgVector origin = 1;
bool CMsgTESparks::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTESparks::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTESparks::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTESparks::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTESparks::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTESparks.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTESparks::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTESparks.origin)
  return origin_;
}
::CMsgVector* CMsgTESparks::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTESparks::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTESparks.origin)
}

// optional uint32 magnitude = 2;
bool CMsgTESparks::has_magnitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTESparks::set_has_magnitude() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTESparks::clear_has_magnitude() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTESparks::clear_magnitude() {
  magnitude_ = 0u;
  clear_has_magnitude();
}
 ::google::protobuf::uint32 CMsgTESparks::magnitude() const {
  // @@protoc_insertion_point(field_get:CMsgTESparks.magnitude)
  return magnitude_;
}
 void CMsgTESparks::set_magnitude(::google::protobuf::uint32 value) {
  set_has_magnitude();
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:CMsgTESparks.magnitude)
}

// optional uint32 length = 3;
bool CMsgTESparks::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTESparks::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTESparks::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTESparks::clear_length() {
  length_ = 0u;
  clear_has_length();
}
 ::google::protobuf::uint32 CMsgTESparks::length() const {
  // @@protoc_insertion_point(field_get:CMsgTESparks.length)
  return length_;
}
 void CMsgTESparks::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:CMsgTESparks.length)
}

// optional .CMsgVector direction = 4;
bool CMsgTESparks::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTESparks::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTESparks::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTESparks::clear_direction() {
  if (direction_ != NULL) direction_->::CMsgVector::Clear();
  clear_has_direction();
}
const ::CMsgVector& CMsgTESparks::direction() const {
  // @@protoc_insertion_point(field_get:CMsgTESparks.direction)
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
::CMsgVector* CMsgTESparks::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTESparks.direction)
  return direction_;
}
::CMsgVector* CMsgTESparks::release_direction() {
  clear_has_direction();
  ::CMsgVector* temp = direction_;
  direction_ = NULL;
  return temp;
}
void CMsgTESparks::set_allocated_direction(::CMsgVector* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTESparks.direction)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEPhysicsProp::kOriginFieldNumber;
const int CMsgTEPhysicsProp::kVelocityFieldNumber;
const int CMsgTEPhysicsProp::kAnglesFieldNumber;
const int CMsgTEPhysicsProp::kSkinFieldNumber;
const int CMsgTEPhysicsProp::kFlagsFieldNumber;
const int CMsgTEPhysicsProp::kEffectsFieldNumber;
const int CMsgTEPhysicsProp::kColorFieldNumber;
const int CMsgTEPhysicsProp::kModelindexFieldNumber;
const int CMsgTEPhysicsProp::kBreakmodelsnottomakeFieldNumber;
const int CMsgTEPhysicsProp::kScaleFieldNumber;
#endif  // !_MSC_VER

CMsgTEPhysicsProp::CMsgTEPhysicsProp()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEPhysicsProp)
}

void CMsgTEPhysicsProp::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  velocity_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
}

CMsgTEPhysicsProp::CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEPhysicsProp)
}

void CMsgTEPhysicsProp::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  velocity_ = NULL;
  angles_ = NULL;
  skin_ = 0u;
  flags_ = 0u;
  effects_ = 0u;
  color_ = 0u;
  modelindex_ = GOOGLE_ULONGLONG(0);
  breakmodelsnottomake_ = 0u;
  scale_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEPhysicsProp::~CMsgTEPhysicsProp() {
  // @@protoc_insertion_point(destructor:CMsgTEPhysicsProp)
  SharedDtor();
}

void CMsgTEPhysicsProp::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete velocity_;
    delete angles_;
  }
}

void CMsgTEPhysicsProp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEPhysicsProp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEPhysicsProp_descriptor_;
}

const CMsgTEPhysicsProp& CMsgTEPhysicsProp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEPhysicsProp* CMsgTEPhysicsProp::default_instance_ = NULL;

CMsgTEPhysicsProp* CMsgTEPhysicsProp::New(::google::protobuf::Arena* arena) const {
  CMsgTEPhysicsProp* n = new CMsgTEPhysicsProp;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEPhysicsProp::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEPhysicsProp*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(skin_, modelindex_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
  }
  ZR_(breakmodelsnottomake_, scale_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEPhysicsProp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEPhysicsProp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_velocity;
        break;
      }

      // optional .CMsgVector velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 3;
      case 3: {
        if (tag == 26) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_skin;
        break;
      }

      // optional fixed32 skin = 4;
      case 4: {
        if (tag == 37) {
         parse_skin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &skin_)));
          set_has_skin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (tag == 40) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_effects;
        break;
      }

      // optional uint32 effects = 6;
      case 6: {
        if (tag == 48) {
         parse_effects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &effects_)));
          set_has_effects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_color;
        break;
      }

      // optional fixed32 color = 7;
      case 7: {
        if (tag == 61) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_modelindex;
        break;
      }

      // optional fixed64 modelindex = 8;
      case 8: {
        if (tag == 65) {
         parse_modelindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
          set_has_modelindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_breakmodelsnottomake;
        break;
      }

      // optional uint32 breakmodelsnottomake = 9;
      case 9: {
        if (tag == 72) {
         parse_breakmodelsnottomake:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &breakmodelsnottomake_)));
          set_has_breakmodelsnottomake();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_scale;
        break;
      }

      // optional float scale = 10;
      case 10: {
        if (tag == 85) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEPhysicsProp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEPhysicsProp)
  return false;
#undef DO_
}

void CMsgTEPhysicsProp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEPhysicsProp)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->velocity_, output);
  }

  // optional .CMsgQAngle angles = 3;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->angles_, output);
  }

  // optional fixed32 skin = 4;
  if (has_skin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->skin(), output);
  }

  // optional uint32 flags = 5;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  // optional uint32 effects = 6;
  if (has_effects()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->effects(), output);
  }

  // optional fixed32 color = 7;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(7, this->color(), output);
  }

  // optional fixed64 modelindex = 8;
  if (has_modelindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(8, this->modelindex(), output);
  }

  // optional uint32 breakmodelsnottomake = 9;
  if (has_breakmodelsnottomake()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->breakmodelsnottomake(), output);
  }

  // optional float scale = 10;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->scale(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEPhysicsProp)
}

::google::protobuf::uint8* CMsgTEPhysicsProp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPhysicsProp)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->velocity_, target);
  }

  // optional .CMsgQAngle angles = 3;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->angles_, target);
  }

  // optional fixed32 skin = 4;
  if (has_skin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->skin(), target);
  }

  // optional uint32 flags = 5;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->flags(), target);
  }

  // optional uint32 effects = 6;
  if (has_effects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->effects(), target);
  }

  // optional fixed32 color = 7;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(7, this->color(), target);
  }

  // optional fixed64 modelindex = 8;
  if (has_modelindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(8, this->modelindex(), target);
  }

  // optional uint32 breakmodelsnottomake = 9;
  if (has_breakmodelsnottomake()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->breakmodelsnottomake(), target);
  }

  // optional float scale = 10;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->scale(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPhysicsProp)
  return target;
}

int CMsgTEPhysicsProp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->velocity_);
    }

    // optional .CMsgQAngle angles = 3;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional fixed32 skin = 4;
    if (has_skin()) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 5;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 effects = 6;
    if (has_effects()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->effects());
    }

    // optional fixed32 color = 7;
    if (has_color()) {
      total_size += 1 + 4;
    }

    // optional fixed64 modelindex = 8;
    if (has_modelindex()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional uint32 breakmodelsnottomake = 9;
    if (has_breakmodelsnottomake()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->breakmodelsnottomake());
    }

    // optional float scale = 10;
    if (has_scale()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEPhysicsProp::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEPhysicsProp* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEPhysicsProp>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEPhysicsProp::MergeFrom(const CMsgTEPhysicsProp& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::CMsgVector::MergeFrom(from.velocity());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_skin()) {
      set_skin(from.skin());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_effects()) {
      set_effects(from.effects());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_modelindex()) {
      set_modelindex(from.modelindex());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_breakmodelsnottomake()) {
      set_breakmodelsnottomake(from.breakmodelsnottomake());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEPhysicsProp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPhysicsProp::CopyFrom(const CMsgTEPhysicsProp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPhysicsProp::IsInitialized() const {

  return true;
}

void CMsgTEPhysicsProp::Swap(CMsgTEPhysicsProp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEPhysicsProp::InternalSwap(CMsgTEPhysicsProp* other) {
  std::swap(origin_, other->origin_);
  std::swap(velocity_, other->velocity_);
  std::swap(angles_, other->angles_);
  std::swap(skin_, other->skin_);
  std::swap(flags_, other->flags_);
  std::swap(effects_, other->effects_);
  std::swap(color_, other->color_);
  std::swap(modelindex_, other->modelindex_);
  std::swap(breakmodelsnottomake_, other->breakmodelsnottomake_);
  std::swap(scale_, other->scale_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEPhysicsProp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEPhysicsProp_descriptor_;
  metadata.reflection = CMsgTEPhysicsProp_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEPhysicsProp

// optional .CMsgVector origin = 1;
bool CMsgTEPhysicsProp::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEPhysicsProp::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEPhysicsProp::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPhysicsProp::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEPhysicsProp::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEPhysicsProp::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEPhysicsProp.origin)
  return origin_;
}
::CMsgVector* CMsgTEPhysicsProp::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEPhysicsProp::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEPhysicsProp.origin)
}

// optional .CMsgVector velocity = 2;
bool CMsgTEPhysicsProp::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEPhysicsProp::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEPhysicsProp::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPhysicsProp::clear_velocity() {
  if (velocity_ != NULL) velocity_->::CMsgVector::Clear();
  clear_has_velocity();
}
const ::CMsgVector& CMsgTEPhysicsProp::velocity() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
::CMsgVector* CMsgTEPhysicsProp::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEPhysicsProp.velocity)
  return velocity_;
}
::CMsgVector* CMsgTEPhysicsProp::release_velocity() {
  clear_has_velocity();
  ::CMsgVector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
void CMsgTEPhysicsProp::set_allocated_velocity(::CMsgVector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEPhysicsProp.velocity)
}

// optional .CMsgQAngle angles = 3;
bool CMsgTEPhysicsProp::has_angles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEPhysicsProp::set_has_angles() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEPhysicsProp::clear_has_angles() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEPhysicsProp::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgTEPhysicsProp::angles() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgTEPhysicsProp::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEPhysicsProp.angles)
  return angles_;
}
::CMsgQAngle* CMsgTEPhysicsProp::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgTEPhysicsProp::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEPhysicsProp.angles)
}

// optional fixed32 skin = 4;
bool CMsgTEPhysicsProp::has_skin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEPhysicsProp::set_has_skin() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEPhysicsProp::clear_has_skin() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEPhysicsProp::clear_skin() {
  skin_ = 0u;
  clear_has_skin();
}
 ::google::protobuf::uint32 CMsgTEPhysicsProp::skin() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.skin)
  return skin_;
}
 void CMsgTEPhysicsProp::set_skin(::google::protobuf::uint32 value) {
  set_has_skin();
  skin_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.skin)
}

// optional uint32 flags = 5;
bool CMsgTEPhysicsProp::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CMsgTEPhysicsProp::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
void CMsgTEPhysicsProp::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
void CMsgTEPhysicsProp::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 CMsgTEPhysicsProp::flags() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.flags)
  return flags_;
}
 void CMsgTEPhysicsProp::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.flags)
}

// optional uint32 effects = 6;
bool CMsgTEPhysicsProp::has_effects() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CMsgTEPhysicsProp::set_has_effects() {
  _has_bits_[0] |= 0x00000020u;
}
void CMsgTEPhysicsProp::clear_has_effects() {
  _has_bits_[0] &= ~0x00000020u;
}
void CMsgTEPhysicsProp::clear_effects() {
  effects_ = 0u;
  clear_has_effects();
}
 ::google::protobuf::uint32 CMsgTEPhysicsProp::effects() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.effects)
  return effects_;
}
 void CMsgTEPhysicsProp::set_effects(::google::protobuf::uint32 value) {
  set_has_effects();
  effects_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.effects)
}

// optional fixed32 color = 7;
bool CMsgTEPhysicsProp::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CMsgTEPhysicsProp::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
void CMsgTEPhysicsProp::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
void CMsgTEPhysicsProp::clear_color() {
  color_ = 0u;
  clear_has_color();
}
 ::google::protobuf::uint32 CMsgTEPhysicsProp::color() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.color)
  return color_;
}
 void CMsgTEPhysicsProp::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.color)
}

// optional fixed64 modelindex = 8;
bool CMsgTEPhysicsProp::has_modelindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CMsgTEPhysicsProp::set_has_modelindex() {
  _has_bits_[0] |= 0x00000080u;
}
void CMsgTEPhysicsProp::clear_has_modelindex() {
  _has_bits_[0] &= ~0x00000080u;
}
void CMsgTEPhysicsProp::clear_modelindex() {
  modelindex_ = GOOGLE_ULONGLONG(0);
  clear_has_modelindex();
}
 ::google::protobuf::uint64 CMsgTEPhysicsProp::modelindex() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.modelindex)
  return modelindex_;
}
 void CMsgTEPhysicsProp::set_modelindex(::google::protobuf::uint64 value) {
  set_has_modelindex();
  modelindex_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.modelindex)
}

// optional uint32 breakmodelsnottomake = 9;
bool CMsgTEPhysicsProp::has_breakmodelsnottomake() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CMsgTEPhysicsProp::set_has_breakmodelsnottomake() {
  _has_bits_[0] |= 0x00000100u;
}
void CMsgTEPhysicsProp::clear_has_breakmodelsnottomake() {
  _has_bits_[0] &= ~0x00000100u;
}
void CMsgTEPhysicsProp::clear_breakmodelsnottomake() {
  breakmodelsnottomake_ = 0u;
  clear_has_breakmodelsnottomake();
}
 ::google::protobuf::uint32 CMsgTEPhysicsProp::breakmodelsnottomake() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.breakmodelsnottomake)
  return breakmodelsnottomake_;
}
 void CMsgTEPhysicsProp::set_breakmodelsnottomake(::google::protobuf::uint32 value) {
  set_has_breakmodelsnottomake();
  breakmodelsnottomake_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.breakmodelsnottomake)
}

// optional float scale = 10;
bool CMsgTEPhysicsProp::has_scale() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void CMsgTEPhysicsProp::set_has_scale() {
  _has_bits_[0] |= 0x00000200u;
}
void CMsgTEPhysicsProp::clear_has_scale() {
  _has_bits_[0] &= ~0x00000200u;
}
void CMsgTEPhysicsProp::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgTEPhysicsProp::scale() const {
  // @@protoc_insertion_point(field_get:CMsgTEPhysicsProp.scale)
  return scale_;
}
 void CMsgTEPhysicsProp::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPhysicsProp.scale)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEPlayerDecal::kOriginFieldNumber;
const int CMsgTEPlayerDecal::kPlayerFieldNumber;
const int CMsgTEPlayerDecal::kEntityFieldNumber;
#endif  // !_MSC_VER

CMsgTEPlayerDecal::CMsgTEPlayerDecal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEPlayerDecal)
}

void CMsgTEPlayerDecal::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEPlayerDecal::CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEPlayerDecal)
}

void CMsgTEPlayerDecal::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  player_ = 0u;
  entity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEPlayerDecal::~CMsgTEPlayerDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEPlayerDecal)
  SharedDtor();
}

void CMsgTEPlayerDecal::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
  }
}

void CMsgTEPlayerDecal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEPlayerDecal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEPlayerDecal_descriptor_;
}

const CMsgTEPlayerDecal& CMsgTEPlayerDecal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEPlayerDecal* CMsgTEPlayerDecal::default_instance_ = NULL;

CMsgTEPlayerDecal* CMsgTEPlayerDecal::New(::google::protobuf::Arena* arena) const {
  CMsgTEPlayerDecal* n = new CMsgTEPlayerDecal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEPlayerDecal::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEPlayerDecal*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(player_, entity_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEPlayerDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEPlayerDecal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player;
        break;
      }

      // optional uint32 player = 2;
      case 2: {
        if (tag == 16) {
         parse_player:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_)));
          set_has_player();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_entity;
        break;
      }

      // optional uint32 entity = 3;
      case 3: {
        if (tag == 24) {
         parse_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEPlayerDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEPlayerDecal)
  return false;
#undef DO_
}

void CMsgTEPlayerDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEPlayerDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional uint32 player = 2;
  if (has_player()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player(), output);
  }

  // optional uint32 entity = 3;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->entity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEPlayerDecal)
}

::google::protobuf::uint8* CMsgTEPlayerDecal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPlayerDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional uint32 player = 2;
  if (has_player()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->player(), target);
  }

  // optional uint32 entity = 3;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->entity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPlayerDecal)
  return target;
}

int CMsgTEPlayerDecal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional uint32 player = 2;
    if (has_player()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player());
    }

    // optional uint32 entity = 3;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEPlayerDecal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEPlayerDecal* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEPlayerDecal>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEPlayerDecal::MergeFrom(const CMsgTEPlayerDecal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_player()) {
      set_player(from.player());
    }
    if (from.has_entity()) {
      set_entity(from.entity());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEPlayerDecal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPlayerDecal::CopyFrom(const CMsgTEPlayerDecal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPlayerDecal::IsInitialized() const {

  return true;
}

void CMsgTEPlayerDecal::Swap(CMsgTEPlayerDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEPlayerDecal::InternalSwap(CMsgTEPlayerDecal* other) {
  std::swap(origin_, other->origin_);
  std::swap(player_, other->player_);
  std::swap(entity_, other->entity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEPlayerDecal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEPlayerDecal_descriptor_;
  metadata.reflection = CMsgTEPlayerDecal_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEPlayerDecal

// optional .CMsgVector origin = 1;
bool CMsgTEPlayerDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEPlayerDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEPlayerDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPlayerDecal::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEPlayerDecal::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEPlayerDecal.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEPlayerDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEPlayerDecal.origin)
  return origin_;
}
::CMsgVector* CMsgTEPlayerDecal::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEPlayerDecal::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEPlayerDecal.origin)
}

// optional uint32 player = 2;
bool CMsgTEPlayerDecal::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEPlayerDecal::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEPlayerDecal::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPlayerDecal::clear_player() {
  player_ = 0u;
  clear_has_player();
}
 ::google::protobuf::uint32 CMsgTEPlayerDecal::player() const {
  // @@protoc_insertion_point(field_get:CMsgTEPlayerDecal.player)
  return player_;
}
 void CMsgTEPlayerDecal::set_player(::google::protobuf::uint32 value) {
  set_has_player();
  player_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPlayerDecal.player)
}

// optional uint32 entity = 3;
bool CMsgTEPlayerDecal::has_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEPlayerDecal::set_has_entity() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEPlayerDecal::clear_has_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEPlayerDecal::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
 ::google::protobuf::uint32 CMsgTEPlayerDecal::entity() const {
  // @@protoc_insertion_point(field_get:CMsgTEPlayerDecal.entity)
  return entity_;
}
 void CMsgTEPlayerDecal::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEPlayerDecal.entity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEProjectedDecal::kOriginFieldNumber;
const int CMsgTEProjectedDecal::kAnglesFieldNumber;
const int CMsgTEProjectedDecal::kIndexFieldNumber;
const int CMsgTEProjectedDecal::kDistanceFieldNumber;
#endif  // !_MSC_VER

CMsgTEProjectedDecal::CMsgTEProjectedDecal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEProjectedDecal)
}

void CMsgTEProjectedDecal::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  angles_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
}

CMsgTEProjectedDecal::CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEProjectedDecal)
}

void CMsgTEProjectedDecal::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  angles_ = NULL;
  index_ = 0u;
  distance_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEProjectedDecal::~CMsgTEProjectedDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEProjectedDecal)
  SharedDtor();
}

void CMsgTEProjectedDecal::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete angles_;
  }
}

void CMsgTEProjectedDecal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEProjectedDecal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEProjectedDecal_descriptor_;
}

const CMsgTEProjectedDecal& CMsgTEProjectedDecal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEProjectedDecal* CMsgTEProjectedDecal::default_instance_ = NULL;

CMsgTEProjectedDecal* CMsgTEProjectedDecal::New(::google::protobuf::Arena* arena) const {
  CMsgTEProjectedDecal* n = new CMsgTEProjectedDecal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEProjectedDecal::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CMsgTEProjectedDecal*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(index_, distance_);
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_angles()) {
      if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEProjectedDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEProjectedDecal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angles;
        break;
      }

      // optional .CMsgQAngle angles = 2;
      case 2: {
        if (tag == 18) {
         parse_angles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // optional uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_distance;
        break;
      }

      // optional float distance = 4;
      case 4: {
        if (tag == 37) {
         parse_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &distance_)));
          set_has_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEProjectedDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEProjectedDecal)
  return false;
#undef DO_
}

void CMsgTEProjectedDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEProjectedDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angles_, output);
  }

  // optional uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // optional float distance = 4;
  if (has_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEProjectedDecal)
}

::google::protobuf::uint8* CMsgTEProjectedDecal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEProjectedDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgQAngle angles = 2;
  if (has_angles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->angles_, target);
  }

  // optional uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // optional float distance = 4;
  if (has_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEProjectedDecal)
  return target;
}

int CMsgTEProjectedDecal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (has_angles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->angles_);
    }

    // optional uint32 index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional float distance = 4;
    if (has_distance()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEProjectedDecal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEProjectedDecal* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEProjectedDecal>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEProjectedDecal::MergeFrom(const CMsgTEProjectedDecal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_angles()) {
      mutable_angles()->::CMsgQAngle::MergeFrom(from.angles());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_distance()) {
      set_distance(from.distance());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEProjectedDecal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEProjectedDecal::CopyFrom(const CMsgTEProjectedDecal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEProjectedDecal::IsInitialized() const {

  return true;
}

void CMsgTEProjectedDecal::Swap(CMsgTEProjectedDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEProjectedDecal::InternalSwap(CMsgTEProjectedDecal* other) {
  std::swap(origin_, other->origin_);
  std::swap(angles_, other->angles_);
  std::swap(index_, other->index_);
  std::swap(distance_, other->distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEProjectedDecal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEProjectedDecal_descriptor_;
  metadata.reflection = CMsgTEProjectedDecal_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEProjectedDecal

// optional .CMsgVector origin = 1;
bool CMsgTEProjectedDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEProjectedDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEProjectedDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEProjectedDecal::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEProjectedDecal::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEProjectedDecal.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEProjectedDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEProjectedDecal.origin)
  return origin_;
}
::CMsgVector* CMsgTEProjectedDecal::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEProjectedDecal::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEProjectedDecal.origin)
}

// optional .CMsgQAngle angles = 2;
bool CMsgTEProjectedDecal::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEProjectedDecal::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEProjectedDecal::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEProjectedDecal::clear_angles() {
  if (angles_ != NULL) angles_->::CMsgQAngle::Clear();
  clear_has_angles();
}
const ::CMsgQAngle& CMsgTEProjectedDecal::angles() const {
  // @@protoc_insertion_point(field_get:CMsgTEProjectedDecal.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
::CMsgQAngle* CMsgTEProjectedDecal::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    angles_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEProjectedDecal.angles)
  return angles_;
}
::CMsgQAngle* CMsgTEProjectedDecal::release_angles() {
  clear_has_angles();
  ::CMsgQAngle* temp = angles_;
  angles_ = NULL;
  return temp;
}
void CMsgTEProjectedDecal::set_allocated_angles(::CMsgQAngle* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEProjectedDecal.angles)
}

// optional uint32 index = 3;
bool CMsgTEProjectedDecal::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEProjectedDecal::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEProjectedDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEProjectedDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 CMsgTEProjectedDecal::index() const {
  // @@protoc_insertion_point(field_get:CMsgTEProjectedDecal.index)
  return index_;
}
 void CMsgTEProjectedDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEProjectedDecal.index)
}

// optional float distance = 4;
bool CMsgTEProjectedDecal::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CMsgTEProjectedDecal::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void CMsgTEProjectedDecal::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void CMsgTEProjectedDecal::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
 float CMsgTEProjectedDecal::distance() const {
  // @@protoc_insertion_point(field_get:CMsgTEProjectedDecal.distance)
  return distance_;
}
 void CMsgTEProjectedDecal::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEProjectedDecal.distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTESmoke::kOriginFieldNumber;
const int CMsgTESmoke::kScaleFieldNumber;
#endif  // !_MSC_VER

CMsgTESmoke::CMsgTESmoke()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTESmoke)
}

void CMsgTESmoke::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTESmoke::CMsgTESmoke(const CMsgTESmoke& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTESmoke)
}

void CMsgTESmoke::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  scale_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTESmoke::~CMsgTESmoke() {
  // @@protoc_insertion_point(destructor:CMsgTESmoke)
  SharedDtor();
}

void CMsgTESmoke::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
  }
}

void CMsgTESmoke::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTESmoke::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTESmoke_descriptor_;
}

const CMsgTESmoke& CMsgTESmoke::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTESmoke* CMsgTESmoke::default_instance_ = NULL;

CMsgTESmoke* CMsgTESmoke::New(::google::protobuf::Arena* arena) const {
  CMsgTESmoke* n = new CMsgTESmoke;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTESmoke::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    scale_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTESmoke::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTESmoke)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_scale;
        break;
      }

      // optional float scale = 2;
      case 2: {
        if (tag == 21) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTESmoke)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTESmoke)
  return false;
#undef DO_
}

void CMsgTESmoke::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTESmoke)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional float scale = 2;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->scale(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTESmoke)
}

::google::protobuf::uint8* CMsgTESmoke::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESmoke)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional float scale = 2;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->scale(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESmoke)
  return target;
}

int CMsgTESmoke::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional float scale = 2;
    if (has_scale()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTESmoke::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTESmoke* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTESmoke>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTESmoke::MergeFrom(const CMsgTESmoke& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTESmoke::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESmoke::CopyFrom(const CMsgTESmoke& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESmoke::IsInitialized() const {

  return true;
}

void CMsgTESmoke::Swap(CMsgTESmoke* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTESmoke::InternalSwap(CMsgTESmoke* other) {
  std::swap(origin_, other->origin_);
  std::swap(scale_, other->scale_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTESmoke::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTESmoke_descriptor_;
  metadata.reflection = CMsgTESmoke_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTESmoke

// optional .CMsgVector origin = 1;
bool CMsgTESmoke::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTESmoke::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTESmoke::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTESmoke::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTESmoke::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTESmoke.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTESmoke::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTESmoke.origin)
  return origin_;
}
::CMsgVector* CMsgTESmoke::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTESmoke::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTESmoke.origin)
}

// optional float scale = 2;
bool CMsgTESmoke::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTESmoke::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTESmoke::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTESmoke::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
 float CMsgTESmoke::scale() const {
  // @@protoc_insertion_point(field_get:CMsgTESmoke.scale)
  return scale_;
}
 void CMsgTESmoke::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:CMsgTESmoke.scale)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int CMsgTEWorldDecal::kOriginFieldNumber;
const int CMsgTEWorldDecal::kNormalFieldNumber;
const int CMsgTEWorldDecal::kIndexFieldNumber;
#endif  // !_MSC_VER

CMsgTEWorldDecal::CMsgTEWorldDecal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CMsgTEWorldDecal)
}

void CMsgTEWorldDecal::InitAsDefaultInstance() {
  origin_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  normal_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

CMsgTEWorldDecal::CMsgTEWorldDecal(const CMsgTEWorldDecal& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CMsgTEWorldDecal)
}

void CMsgTEWorldDecal::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  normal_ = NULL;
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CMsgTEWorldDecal::~CMsgTEWorldDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEWorldDecal)
  SharedDtor();
}

void CMsgTEWorldDecal::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete normal_;
  }
}

void CMsgTEWorldDecal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CMsgTEWorldDecal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CMsgTEWorldDecal_descriptor_;
}

const CMsgTEWorldDecal& CMsgTEWorldDecal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_te_2eproto();
  return *default_instance_;
}

CMsgTEWorldDecal* CMsgTEWorldDecal::default_instance_ = NULL;

CMsgTEWorldDecal* CMsgTEWorldDecal::New(::google::protobuf::Arena* arena) const {
  CMsgTEWorldDecal* n = new CMsgTEWorldDecal;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CMsgTEWorldDecal::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::CMsgVector::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::CMsgVector::Clear();
    }
    index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CMsgTEWorldDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CMsgTEWorldDecal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CMsgVector origin = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_normal;
        break;
      }

      // optional .CMsgVector normal = 2;
      case 2: {
        if (tag == 18) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // optional uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CMsgTEWorldDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CMsgTEWorldDecal)
  return false;
#undef DO_
}

void CMsgTEWorldDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CMsgTEWorldDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->origin_, output);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->normal_, output);
  }

  // optional uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CMsgTEWorldDecal)
}

::google::protobuf::uint8* CMsgTEWorldDecal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEWorldDecal)
  // optional .CMsgVector origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->origin_, target);
  }

  // optional .CMsgVector normal = 2;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->normal_, target);
  }

  // optional uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEWorldDecal)
  return target;
}

int CMsgTEWorldDecal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .CMsgVector origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional .CMsgVector normal = 2;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->normal_);
    }

    // optional uint32 index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CMsgTEWorldDecal::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CMsgTEWorldDecal* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CMsgTEWorldDecal>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CMsgTEWorldDecal::MergeFrom(const CMsgTEWorldDecal& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::CMsgVector::MergeFrom(from.origin());
    }
    if (from.has_normal()) {
      mutable_normal()->::CMsgVector::MergeFrom(from.normal());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CMsgTEWorldDecal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEWorldDecal::CopyFrom(const CMsgTEWorldDecal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEWorldDecal::IsInitialized() const {

  return true;
}

void CMsgTEWorldDecal::Swap(CMsgTEWorldDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEWorldDecal::InternalSwap(CMsgTEWorldDecal* other) {
  std::swap(origin_, other->origin_);
  std::swap(normal_, other->normal_);
  std::swap(index_, other->index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CMsgTEWorldDecal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CMsgTEWorldDecal_descriptor_;
  metadata.reflection = CMsgTEWorldDecal_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgTEWorldDecal

// optional .CMsgVector origin = 1;
bool CMsgTEWorldDecal::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CMsgTEWorldDecal::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void CMsgTEWorldDecal::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEWorldDecal::clear_origin() {
  if (origin_ != NULL) origin_->::CMsgVector::Clear();
  clear_has_origin();
}
const ::CMsgVector& CMsgTEWorldDecal::origin() const {
  // @@protoc_insertion_point(field_get:CMsgTEWorldDecal.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::CMsgVector* CMsgTEWorldDecal::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEWorldDecal.origin)
  return origin_;
}
::CMsgVector* CMsgTEWorldDecal::release_origin() {
  clear_has_origin();
  ::CMsgVector* temp = origin_;
  origin_ = NULL;
  return temp;
}
void CMsgTEWorldDecal::set_allocated_origin(::CMsgVector* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEWorldDecal.origin)
}

// optional .CMsgVector normal = 2;
bool CMsgTEWorldDecal::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CMsgTEWorldDecal::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
void CMsgTEWorldDecal::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEWorldDecal::clear_normal() {
  if (normal_ != NULL) normal_->::CMsgVector::Clear();
  clear_has_normal();
}
const ::CMsgVector& CMsgTEWorldDecal::normal() const {
  // @@protoc_insertion_point(field_get:CMsgTEWorldDecal.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
::CMsgVector* CMsgTEWorldDecal::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    normal_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:CMsgTEWorldDecal.normal)
  return normal_;
}
::CMsgVector* CMsgTEWorldDecal::release_normal() {
  clear_has_normal();
  ::CMsgVector* temp = normal_;
  normal_ = NULL;
  return temp;
}
void CMsgTEWorldDecal::set_allocated_normal(::CMsgVector* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgTEWorldDecal.normal)
}

// optional uint32 index = 3;
bool CMsgTEWorldDecal::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CMsgTEWorldDecal::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void CMsgTEWorldDecal::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEWorldDecal::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 CMsgTEWorldDecal::index() const {
  // @@protoc_insertion_point(field_get:CMsgTEWorldDecal.index)
  return index_;
}
 void CMsgTEWorldDecal::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:CMsgTEWorldDecal.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
